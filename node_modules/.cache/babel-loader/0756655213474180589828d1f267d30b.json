{"ast":null,"code":"/**\n * To import utils\n */\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * @private\n */\n\nvar CanvasRenderer =\n/** @class */\nfunction () {\n  /* End-Properties */\n  function CanvasRenderer(rootID) {\n    this.rootId = rootID;\n  } // method to get the attributes value\n\n  /* tslint:disable */\n\n\n  CanvasRenderer.prototype.getOptionValue = function (options, key) {\n    return options[key];\n  };\n  /* tslint:enable */\n\n  /**\n   * To create a Html5 canvas element\n   * @param {BaseAttibutes} options - Options to create canvas\n   * @return {HTMLCanvasElement}\n   */\n\n\n  CanvasRenderer.prototype.createCanvas = function (options) {\n    var canvasObj = document.createElement('canvas');\n    canvasObj.setAttribute('id', this.rootId + '_canvas');\n    this.ctx = canvasObj.getContext('2d');\n    this.canvasObj = canvasObj;\n    this.setCanvasSize(options.width, options.height);\n    return this.canvasObj;\n  };\n  /**\n   * To set the width and height for the Html5 canvas element\n   * @param {number} width - width of the canvas\n   * @param {number} height - height of the canvas\n   * @return {void}\n   */\n\n\n  CanvasRenderer.prototype.setCanvasSize = function (width, height) {\n    var element = document.getElementById(this.rootId);\n    var size = !isNullOrUndefined(element) ? element.getBoundingClientRect() : null;\n\n    if (isNullOrUndefined(this.width)) {\n      this.canvasObj.setAttribute('width', width ? width.toString() : size.width.toString());\n    } else {\n      this.canvasObj.setAttribute('width', this.width.toString());\n    }\n\n    if (isNullOrUndefined(this.height)) {\n      this.canvasObj.setAttribute('height', height ? height.toString() : '450');\n    } else {\n      this.canvasObj.setAttribute('height', this.height.toString());\n    }\n  }; // To set the values to the attributes\n\n\n  CanvasRenderer.prototype.setAttributes = function (options) {\n    this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');\n    var dashArray = this.getOptionValue(options, 'stroke-dasharray');\n\n    if (!isNullOrUndefined(dashArray)) {\n      var dashArrayString = dashArray.split(',');\n      this.ctx.setLineDash([parseInt(dashArrayString[0], 10), parseInt(dashArrayString[1], 10)]);\n    }\n\n    this.ctx.strokeStyle = this.getOptionValue(options, 'stroke');\n  };\n  /**\n   * To draw a line\n   * @param {LineAttributes} options - required options to draw a line on the canvas\n   * @return {void}\n   */\n\n\n  CanvasRenderer.prototype.drawLine = function (options) {\n    this.ctx.save();\n    this.ctx.beginPath();\n    this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');\n    this.ctx.strokeStyle = options.stroke;\n    this.ctx.moveTo(options.x1, options.y1);\n    this.ctx.lineTo(options.x2, options.y2);\n    this.ctx.stroke();\n    this.ctx.restore();\n  };\n  /**\n   * To draw a rectangle\n   * @param {RectAttributes} options - required options to draw a rectangle on the canvas\n   * @return {void}\n   */\n\n\n  CanvasRenderer.prototype.drawRectangle = function (options, canvasTranslate) {\n    var canvasCtx = this.ctx;\n    var cornerRadius = options.rx;\n    this.ctx.save();\n    this.ctx.beginPath();\n\n    if (canvasTranslate) {\n      this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);\n    }\n\n    this.ctx.globalAlpha = this.getOptionValue(options, 'opacity');\n    this.setAttributes(options);\n    this.ctx.rect(options.x, options.y, options.width, options.height);\n\n    if (cornerRadius !== null && cornerRadius >= 0) {\n      this.drawCornerRadius(options);\n    } else {\n      if (options.fill === 'none') {\n        options.fill = 'transparent';\n      }\n\n      this.ctx.fillStyle = options.fill;\n      this.ctx.fillRect(options.x, options.y, options.width, options.height);\n      this.ctx.stroke();\n    }\n\n    this.ctx.restore();\n    this.ctx = canvasCtx;\n    return this.canvasObj;\n  }; // To draw the corner of a rectangle\n\n\n  CanvasRenderer.prototype.drawCornerRadius = function (options) {\n    var cornerRadius = options.rx;\n    var x = options.x;\n    var y = options.y;\n    var width = options.width;\n    var height = options.height;\n\n    if (options.fill === 'none') {\n      options.fill = 'transparent';\n    }\n\n    this.ctx.fillStyle = options.fill;\n\n    if (width < 2 * cornerRadius) {\n      cornerRadius = width / 2;\n    }\n\n    if (height < 2 * cornerRadius) {\n      cornerRadius = height / 2;\n    }\n\n    this.ctx.beginPath();\n    this.ctx.moveTo(x + width - cornerRadius, y);\n    this.ctx.arcTo(x + width, y, x + width, y + height, cornerRadius);\n    this.ctx.arcTo(x + width, y + height, x, y + height, cornerRadius);\n    this.ctx.arcTo(x, y + height, x, y, cornerRadius);\n    this.ctx.arcTo(x, y, x + width, y, cornerRadius);\n    this.ctx.closePath();\n    this.ctx.fill();\n    this.ctx.stroke();\n  };\n  /**\n   * To draw a path on the canvas\n   * @param {PathAttributes} options - options needed to draw path\n   * @param {Int32Array} canvasTranslate - Array of numbers to translate the canvas\n   * @return {void}\n   */\n\n\n  CanvasRenderer.prototype.drawPath = function (options, canvasTranslate) {\n    var path = options.d;\n    var dataSplit = path.split(' ');\n    var borderWidth = this.getOptionValue(options, 'stroke-width');\n    var canvasCtx = this.ctx;\n    var flag = true;\n    this.ctx.save();\n    this.ctx.beginPath();\n\n    if (canvasTranslate) {\n      this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);\n    }\n\n    this.ctx.globalAlpha = options.opacity ? options.opacity : this.getOptionValue(options, 'fill-opacity');\n    this.setAttributes(options);\n\n    for (var i = 0; i < dataSplit.length; i = i + 3) {\n      var x1 = parseFloat(dataSplit[i + 1]);\n      var y1 = parseFloat(dataSplit[i + 2]);\n\n      switch (dataSplit[i]) {\n        case 'M':\n          if (!options.innerR && !options.cx) {\n            this.ctx.moveTo(x1, y1);\n          }\n\n          break;\n\n        case 'L':\n          if (!options.innerR) {\n            this.ctx.lineTo(x1, y1);\n          }\n\n          break;\n\n        case 'Q':\n          var q1 = parseFloat(dataSplit[i + 3]);\n          var q2 = parseFloat(dataSplit[i + 4]);\n          this.ctx.quadraticCurveTo(x1, y1, q1, q2);\n          i = i + 2;\n          break;\n\n        case 'C':\n          var c1 = parseFloat(dataSplit[i + 3]);\n          var c2 = parseFloat(dataSplit[i + 4]);\n          var c3 = parseFloat(dataSplit[i + 5]);\n          var c4 = parseFloat(dataSplit[i + 6]);\n          this.ctx.bezierCurveTo(x1, y1, c1, c2, c3, c4);\n          i = i + 4;\n          break;\n\n        case 'A':\n          if (!options.innerR) {\n            if (options.cx) {\n              this.ctx.arc(options.cx, options.cy, options.radius, 0, 2 * Math.PI, options.counterClockWise);\n            } else {\n              this.ctx.moveTo(options.x, options.y);\n              this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);\n              this.ctx.lineTo(options.x, options.y);\n            }\n          } else if (flag) {\n            this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);\n            this.ctx.arc(options.x, options.y, options.innerR, options.end, options.start, !options.counterClockWise);\n            flag = false;\n          }\n\n          i = i + 5;\n          break;\n\n        case 'z':\n        case 'Z':\n          this.ctx.closePath(); //since for loop is incremented by 3, to get next value after 'z' i is decremented for 2.\n\n          i = i - 2;\n          break;\n      }\n    }\n\n    if (options.fill !== 'none' && options.fill !== undefined) {\n      this.ctx.fillStyle = options.fill;\n      this.ctx.fill();\n    }\n\n    if (borderWidth > 0) {\n      this.ctx.stroke();\n    }\n\n    this.ctx.restore();\n    this.ctx = canvasCtx;\n    return this.canvasObj;\n  };\n  /**\n   * To draw a text\n   * @param {TextAttributes} options - options required to draw text\n   * @param {string} label - Specifies the text which has to be drawn on the canvas\n   * @return {void}\n   */\n\n\n  CanvasRenderer.prototype.createText = function (options, label, transX, transY) {\n    var fontWeight = this.getOptionValue(options, 'font-weight');\n\n    if (!isNullOrUndefined(fontWeight) && fontWeight.toLowerCase() === 'regular') {\n      fontWeight = 'normal';\n    }\n\n    var fontSize = this.getOptionValue(options, 'font-size');\n    var fontFamily = this.getOptionValue(options, 'font-family');\n    var fontStyle = this.getOptionValue(options, 'font-style').toLowerCase();\n    var font = fontStyle + ' ' + fontWeight + ' ' + fontSize + ' ' + fontFamily;\n    var anchor = this.getOptionValue(options, 'text-anchor');\n    var opacity = options.opacity !== undefined ? options.opacity : 1;\n\n    if (anchor === 'middle') {\n      anchor = 'center';\n    }\n\n    this.ctx.save();\n    this.ctx.fillStyle = options.fill;\n    this.ctx.font = font;\n    this.ctx.textAlign = anchor;\n    this.ctx.globalAlpha = opacity;\n\n    if (options.baseline) {\n      this.ctx.textBaseline = options.baseline;\n    }\n\n    var txtlngth = 0;\n    this.ctx.translate(options.x + txtlngth / 2 + (transX ? transX : 0), options.y + (transY ? transY : 0));\n    this.ctx.rotate(options.labelRotation * Math.PI / 180);\n    this.ctx.fillText(label, 0, 0);\n    this.ctx.restore();\n    return this.canvasObj;\n  };\n  /**\n   * To draw circle on the canvas\n   * @param {CircleAttributes} options - required options to draw the circle\n   * @return {void}\n   */\n\n\n  CanvasRenderer.prototype.drawCircle = function (options, canvasTranslate) {\n    var canvasCtx = this.ctx;\n    this.ctx.save();\n    this.ctx.beginPath();\n    this.ctx.arc(options.cx, options.cy, options.r, 0, 2 * Math.PI);\n    this.ctx.fillStyle = options.fill;\n    this.ctx.globalAlpha = options.opacity;\n    this.ctx.fill();\n\n    if (canvasTranslate) {\n      this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);\n    }\n\n    this.setAttributes(options);\n    this.ctx.stroke();\n    this.ctx.restore();\n    this.ctx = canvasCtx;\n    return this.canvasObj;\n  };\n  /**\n   * To draw polyline\n   * @param {PolylineAttributes} options - options needed to draw polyline\n   * @return {void}\n   */\n\n\n  CanvasRenderer.prototype.drawPolyline = function (options) {\n    this.ctx.save();\n    this.ctx.beginPath();\n    var points = options.points.split(' ');\n\n    for (var i = 0; i < points.length - 1; i++) {\n      var point = points[i].split(',');\n      var x = parseFloat(point[0]);\n      var y = parseFloat(point[1]);\n\n      if (i === 0) {\n        this.ctx.moveTo(x, y);\n      } else {\n        this.ctx.lineTo(x, y);\n      }\n    }\n\n    this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');\n    this.ctx.strokeStyle = options.stroke;\n    this.ctx.stroke();\n    this.ctx.restore();\n  };\n  /**\n   * To draw an ellipse on the canvas\n   * @param {EllipseAttributes} options - options needed to draw ellipse\n   * @return {void}\n   */\n\n\n  CanvasRenderer.prototype.drawEllipse = function (options, canvasTranslate) {\n    var canvasCtx = this.ctx;\n    var circumference = Math.max(options.rx, options.ry);\n    var scaleX = options.rx / circumference;\n    var scaleY = options.ry / circumference;\n    this.ctx.save();\n    this.ctx.beginPath();\n    this.ctx.translate(options.cx, options.cy);\n\n    if (canvasTranslate) {\n      this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);\n    }\n\n    this.ctx.save();\n    this.ctx.scale(scaleX, scaleY);\n    this.ctx.arc(0, 0, circumference, 0, 2 * Math.PI, false);\n    this.ctx.fillStyle = options.fill;\n    this.ctx.fill();\n    this.ctx.restore();\n    this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');\n    this.ctx.strokeStyle = options.stroke;\n    this.ctx.stroke();\n    this.ctx.restore();\n    this.ctx = canvasCtx;\n  };\n  /**\n   * To draw an image\n   * @param {ImageAttributes} options - options required to draw an image on the canvas\n   * @return {void}\n   */\n\n\n  CanvasRenderer.prototype.drawImage = function (options) {\n    this.ctx.save();\n    var imageObj = new Image();\n\n    if (!isNullOrUndefined(options.href)) {\n      imageObj.src = options.href;\n      this.ctx.drawImage(imageObj, options.x, options.y, options.width, options.height);\n    }\n\n    this.ctx.restore();\n  };\n  /**\n   * To create a linear gradient\n   * @param {string[]} colors - Specifies the colors required to create linear gradient\n   * @return {string}\n   */\n\n\n  CanvasRenderer.prototype.createLinearGradient = function (colors) {\n    var myGradient;\n\n    if (!isNullOrUndefined(colors[0].colorStop)) {\n      myGradient = this.ctx.createLinearGradient(0, 0, 0, this.canvasObj.height);\n    }\n\n    var color = this.setGradientValues(colors, myGradient);\n    return color;\n  };\n  /**\n   * To create a radial gradient\n   * @param {string[]} colors - Specifies the colors required to create linear gradient\n   * @return {string}\n   */\n\n\n  CanvasRenderer.prototype.createRadialGradient = function (colors) {\n    var myGradient;\n\n    if (!isNullOrUndefined(colors[0].colorStop)) {\n      myGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.canvasObj.height);\n    }\n\n    var colorName = this.setGradientValues(colors, myGradient);\n    return colorName;\n  }; // To set the gradient values\n\n\n  CanvasRenderer.prototype.setGradientValues = function (colors, myGradient) {\n    var colorName;\n\n    if (!isNullOrUndefined(colors[0].colorStop)) {\n      for (var i = 0; i <= colors.length - 1; i++) {\n        var color = colors[i].color;\n        var newColorStop = colors[i].colorStop.slice(0, -1);\n        var stopColor = parseInt(newColorStop, 10) / 100;\n        myGradient.addColorStop(stopColor, color);\n      }\n\n      colorName = myGradient.toString();\n    } else {\n      colorName = colors[0].color.toString();\n    }\n\n    return colorName;\n  };\n  /**\n   * To set the attributes to the element\n   * @param {SVGCanvasAttributes} options - Attributes to set for the element\n   * @param {HTMLElement} element - The element to which the attributes need to be set\n   * @return {HTMLElement}\n   */\n\n\n  CanvasRenderer.prototype.setElementAttributes = function (options, element) {\n    var keys = Object.keys(options);\n    var values = Object.keys(options).map(function (key) {\n      return options[key];\n    });\n\n    for (var i = 0; i < keys.length; i++) {\n      element.setAttribute(keys[i], values[i]);\n    }\n\n    return null;\n  };\n  /**\n   * To update the values of the canvas element attributes\n   * @param {SVGCanvasAttributes} options - Specifies the colors required to create gradient\n   * @return {void}\n   */\n\n\n  CanvasRenderer.prototype.updateCanvasAttributes = function (options) {\n    this.setElementAttributes(options, this.canvasObj);\n    var ctx = this.ctx;\n\n    if (!isNullOrUndefined(this.dataUrl)) {\n      var img_1 = new Image();\n\n      img_1.onload = function () {\n        ctx.drawImage(img_1, 0, 0);\n      };\n\n      img_1.src = this.dataUrl;\n    }\n  };\n  /**\n   * This method clears the given rectangle region\n   * @param options\n   */\n\n\n  CanvasRenderer.prototype.clearRect = function (rect) {\n    this.ctx.restore();\n    this.ctx.clearRect(rect.x, rect.y, rect.width, rect.height);\n  };\n\n  ;\n  /**\n   * For canvas rendering in chart\n   * Dummy method for using canvas/svg render in the same variable name in chart control\n   * @param {BaseAttibutes} options - Options needed to create group\n   * @return {Element}\n   */\n\n  CanvasRenderer.prototype.createGroup = function (options) {\n    return null;\n  };\n  /**\n   * To render a clip path\n   * Dummy method for using canvas/svg render in the same variable name in chart control\n   * @param {BaseAttibutes} options - Options required to render a clip path\n   * @return {Element}\n   */\n\n\n  CanvasRenderer.prototype.drawClipPath = function (options) {\n    return null;\n  };\n  /**\n   * Clip method to perform clip in canvas mode\n   * @param options\n   */\n\n\n  CanvasRenderer.prototype.canvasClip = function (options) {\n    this.ctx.save();\n    this.ctx.fillStyle = 'transparent';\n    this.ctx.rect(options.x, options.y, options.width, options.height);\n    this.ctx.fill();\n    this.ctx.clip();\n  };\n  /**\n   * Tp restore the canvas\n   * @param options\n   */\n\n\n  CanvasRenderer.prototype.canvasRestore = function () {\n    this.ctx.restore();\n  };\n  /**\n   * To draw a polygon\n   * Dummy method for using canvas/svg render in the same variable name in chart control\n   * @param {PolylineAttributes} options - Options needed to draw a polygon in SVG\n   * @return {Element}\n   */\n\n\n  CanvasRenderer.prototype.drawPolygon = function (options) {\n    return null;\n  };\n  /**\n   * To create defs element in SVG\n   * Dummy method for using canvas/svg render in the same variable name in chart control\n   * @return {Element}\n   */\n\n\n  CanvasRenderer.prototype.createDefs = function () {\n    return null;\n  };\n  /**\n   * To create clip path in SVG\n   * Dummy method for using canvas/svg render in the same variable name in chart control\n   * @param {BaseAttibutes} options - Options needed to create clip path\n   * @return {Element}\n   */\n\n\n  CanvasRenderer.prototype.createClipPath = function (options) {\n    return null;\n  };\n  /**\n   * To create a Html5 SVG element\n   * Dummy method for using canvas/svg render in the same variable name in chart control\n   * @param {SVGAttributes} options - Options to create SVG\n   * @return {Element}\n   */\n\n\n  CanvasRenderer.prototype.createSvg = function (options) {\n    return null;\n  };\n\n  return CanvasRenderer;\n}();\n\nexport { CanvasRenderer };","map":null,"metadata":{},"sourceType":"module"}