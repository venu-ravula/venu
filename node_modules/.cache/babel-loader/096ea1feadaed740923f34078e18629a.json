{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nimport { isNullOrUndefined, extend, createElement, Ajax } from '@syncfusion/ej2-base';\nimport { getShapeColor } from '../model/theme';\nimport { GeoLocation, isCustomPath, convertGeoToPoint, Point, PathOption, Size, PolylineOption, getElementByID } from '../utils/helper';\nimport { MapLocation, RectOption, getTranslate, convertTileLatLongToPoint, checkShapeDataFields, CircleOption } from '../utils/helper';\nimport { getZoomTranslate } from '../utils/helper';\nimport { Tile } from '../model/base';\nimport { BingMap } from './bing-map';\nimport { ColorMapping } from './color-mapping';\nimport { layerRendering, shapeRendering } from '../index';\n/**\n * To calculate and render the shape layer\n */\n\nvar LayerPanel =\n/** @class */\nfunction () {\n  function LayerPanel(map) {\n    this.tileTranslatePoint = new MapLocation(0, 0);\n    this.isMapCoordinates = true;\n    this.ajaxProcessCount = 0;\n    this.mapObject = map;\n    this.ajaxModule = new Ajax();\n    this.ajaxResponse = [];\n  }\n  /* tslint:disable:no-string-literal */\n\n\n  LayerPanel.prototype.measureLayerPanel = function () {\n    var _this = this;\n\n    var imageSize = 30;\n    var layerCollection = this.mapObject.layersCollection;\n    var areaRect = this.mapObject.mapAreaRect;\n    var padding = 10;\n    var secondaryEle = getElementByID(this.mapObject.element.id + '_Secondary_Element');\n\n    if (this.mapObject.isTileMap && secondaryEle) {\n      this.tileSvgObject = this.mapObject.renderer.createSvg({\n        id: this.mapObject.element.id + '_Tile_SVG',\n        width: areaRect.width,\n        height: areaRect.height\n      });\n      secondaryEle.appendChild(this.tileSvgObject);\n    }\n\n    this.layerGroup = this.mapObject.renderer.createGroup({\n      id: this.mapObject.element.id + '_Layer_Collections',\n      'clip-path': 'url(#' + this.mapObject.element.id + '_MapArea_ClipRect)'\n    });\n    this.clipRectElement = this.mapObject.renderer.drawClipPath(new RectOption(this.mapObject.element.id + '_MapArea_ClipRect', 'transparent', {\n      width: 1,\n      color: 'Gray'\n    }, 1, {\n      x: this.mapObject.isTileMap ? 0 : areaRect.x,\n      y: this.mapObject.isTileMap ? 0 : areaRect.y,\n      width: areaRect.width,\n      height: areaRect.height\n    }));\n    this.layerGroup.appendChild(this.clipRectElement);\n    this.mapObject.baseMapBounds = null;\n    this.mapObject.baseMapRectBounds = null;\n    this.mapObject.baseSize = null;\n    var layerCount = layerCollection.length - 1;\n    layerCollection.forEach(function (layer, index) {\n      _this.currentLayer = layer;\n\n      _this.processLayers(layer, index);\n    });\n  };\n\n  LayerPanel.prototype.renderTileLayer = function (panel, layer, layerIndex, bing) {\n    var center = new Point(panel.mapObject.centerPosition.longitude, panel.mapObject.centerPosition.latitude);\n    panel.currentFactor = panel.calculateFactor(layer);\n\n    if (isNullOrUndefined(panel.mapObject.tileZoomLevel)) {\n      panel.mapObject.tileZoomLevel = panel.mapObject.zoomSettings.zoomFactor;\n    } else if (panel.mapObject.zoomSettings.zoomFactor !== 1) {\n      panel.mapObject.tileZoomLevel = panel.mapObject.zoomSettings.zoomFactor;\n\n      if (!isNullOrUndefined(panel.mapObject.tileTranslatePoint)) {\n        panel.mapObject.tileTranslatePoint.x = 0;\n        panel.mapObject.tileTranslatePoint.y = 0;\n      }\n    }\n\n    panel.mapObject.tileTranslatePoint = panel.panTileMap(panel.mapObject.availableSize.width, panel.mapObject.availableSize.height, center);\n    panel.generateTiles(panel.mapObject.tileZoomLevel, panel.mapObject.tileTranslatePoint, bing);\n\n    if (panel.mapObject.navigationLineModule) {\n      panel.layerObject.appendChild(panel.mapObject.navigationLineModule.renderNavigation(panel.currentLayer, panel.mapObject.tileZoomLevel, layerIndex));\n    }\n\n    if (panel.mapObject.markerModule) {\n      panel.mapObject.markerModule.markerRender(panel.layerObject, layerIndex, panel.mapObject.tileZoomLevel, null);\n    }\n\n    panel.translateLayerElements(panel.layerObject, layerIndex);\n    panel.layerGroup.appendChild(panel.layerObject);\n  };\n\n  LayerPanel.prototype.processLayers = function (layer, layerIndex) {\n    var _this = this;\n\n    this.layerObject = this.mapObject.renderer.createGroup({\n      id: this.mapObject.element.id + '_LayerIndex_' + layerIndex\n    });\n    var eventArgs = {\n      cancel: false,\n      name: layerRendering,\n      index: layerIndex,\n      layer: layer,\n      maps: this.mapObject,\n      visible: layer.visible\n    };\n\n    if (this.mapObject.isBlazor) {\n      var maps = eventArgs.maps,\n          layer_1 = eventArgs.layer,\n          blazorEventArgs = __rest(eventArgs, [\"maps\", \"layer\"]);\n\n      eventArgs = blazorEventArgs;\n    }\n\n    this.mapObject.trigger('layerRendering', eventArgs, function (observedArgs) {\n      if (!eventArgs.cancel && eventArgs.visible) {\n        if (layer.layerType !== 'Geometry') {\n          if (layer.layerType !== 'Bing' || _this.bing) {\n            _this.renderTileLayer(_this, layer, layerIndex);\n          } else if (layer.key && layer.key.length > 1) {\n            var proxy_1 = _this;\n            var bing_1 = new BingMap(_this.mapObject);\n            var url = 'https://dev.virtualearth.net/REST/V1/Imagery/Metadata/' + layer.bingMapType;\n            var ajax = new Ajax({\n              url: url + '?output=json&include=ImageryProviders&key=' + layer.key\n            });\n\n            ajax.onSuccess = function (json) {\n              var jsonObject = JSON.parse(json);\n              var resource = jsonObject['resourceSets'][0]['resources'][0];\n              var imageUrl = resource['imageUrl'];\n              var subDomains = resource['imageUrlSubdomains'];\n              var maxZoom = resource['zoomMax'];\n\n              if (imageUrl !== null && imageUrl !== undefined && imageUrl !== bing_1.imageUrl) {\n                bing_1.imageUrl = imageUrl;\n              }\n\n              if (subDomains !== null && subDomains !== undefined && subDomains !== bing_1.subDomains) {\n                bing_1.subDomains = subDomains;\n              }\n\n              if (maxZoom !== null && maxZoom !== undefined && maxZoom !== bing_1.maxZoom) {\n                bing_1.maxZoom = maxZoom;\n              }\n\n              proxy_1.mapObject['bingMap'] = bing_1;\n              proxy_1.renderTileLayer(proxy_1, layer, layerIndex, bing_1);\n            };\n\n            ajax.send();\n          }\n        } else {\n          if (!isNullOrUndefined(layer.shapeData) && (!isNullOrUndefined(layer.shapeData['geometries']) || !isNullOrUndefined(layer.shapeData['features']))) {\n            var featureData = !isNullOrUndefined(layer.shapeData['geometries']) && layer.shapeData['geometries'].length > 0 ? layer.shapeData['geometries'] : layer.shapeData['features'];\n            layer.layerData = [];\n            var bbox = layer.shapeData['bbox'];\n\n            if (!isNullOrUndefined(bbox) && layer.isBaseLayer) {\n              _this.mapObject.baseMapBounds = new GeoLocation({\n                min: bbox[0][1],\n                max: bbox[1][1]\n              }, {\n                min: bbox[0][0],\n                max: bbox[1][0]\n              });\n            } else if (isNullOrUndefined(_this.mapObject.baseMapBounds) && !isCustomPath(featureData)) {\n              _this.calculateRectBounds(featureData); // if (isNullOrUndefined(this.mapObject.baseSize)) {\n              //     let minSize: Point = convertGeoToPoint(\n              //         this.mapObject.baseMapBounds.latitude.min,\n              //         this.mapObject.baseMapBounds.longitude.min, this.calculateFactor(layer), layer, this.mapObject\n              //     );\n              //     let maxSize: Point = convertGeoToPoint(\n              //         this.mapObject.baseMapBounds.latitude.max,\n              //         this.mapObject.baseMapBounds.longitude.max, this.calculateFactor(layer), layer, this.mapObject\n              //     );\n              //     this.mapObject.baseSize = new Size(Math.abs(minSize.x - maxSize.x), Math.abs(minSize.y - maxSize.y));\n              // }\n\n            }\n\n            _this.calculatePathCollection(layerIndex, featureData);\n          }\n        }\n      }\n    });\n\n    if (!this.mapObject.isTileMap) {\n      this.mapObject.svgObject.appendChild(this.layerGroup);\n    } else if (this.tileSvgObject) {\n      this.tileSvgObject.appendChild(this.layerGroup);\n    }\n  }; //tslint:disable:max-func-body-length\n\n\n  LayerPanel.prototype.bubbleCalculation = function (bubbleSettings, range) {\n    if (bubbleSettings.dataSource != null && bubbleSettings != null) {\n      for (var i = 0; i < bubbleSettings.dataSource.length; i++) {\n        var bubbledata = parseFloat(bubbleSettings.dataSource[i][bubbleSettings.valuePath]);\n\n        if (i !== 0) {\n          if (bubbledata > range.max) {\n            range.max = bubbledata;\n          } else if (bubbledata < range.min) {\n            range.min = bubbledata;\n          }\n        } else {\n          range.max = range.min = bubbledata;\n        }\n      }\n    }\n  }; // tslint:disable-next-line:max-func-body-length\n\n\n  LayerPanel.prototype.calculatePathCollection = function (layerIndex, renderData) {\n    var _this = this;\n\n    this.groupElements = [];\n\n    if (!isCustomPath(renderData)) {\n      this.currentFactor = this.calculateFactor(this.currentLayer);\n    }\n\n    this.rectBounds = null;\n    var shapeSettings = this.currentLayer.shapeSettings;\n    var bubbleSettings = this.currentLayer.bubbleSettings;\n    renderData.forEach(function (geometryData, index) {\n      if (!isNullOrUndefined(geometryData['geometry']) || !isNullOrUndefined(geometryData['coordinates'])) {\n        var type = !isNullOrUndefined(geometryData['geometry']) ? geometryData['geometry']['type'] : geometryData['type'];\n        var coords = !isNullOrUndefined(geometryData['geometry']) ? geometryData['geometry']['coordinates'] : geometryData['coordinates'];\n        var data = geometryData['geometry'];\n        var properties = geometryData['properties'];\n\n        _this.generatePoints(type, coords, data, properties);\n      }\n    });\n    this.currentLayer.rectBounds = this.rectBounds;\n\n    if (isNullOrUndefined(this.mapObject.baseMapRectBounds) && this.currentLayer.isBaseLayer) {\n      this.mapObject.baseMapRectBounds = this.rectBounds;\n    }\n\n    var colors = shapeSettings.palette.length > 1 ? shapeSettings.palette : getShapeColor(this.mapObject.theme);\n    var labelTemplateEle = createElement('div', {\n      id: this.mapObject.element.id + '_LayerIndex_' + layerIndex + '_Label_Template_Group',\n      className: 'template',\n      styles: 'pointer-events: none; overflow: hidden; position: absolute;' + 'top:' + this.mapObject.mapAreaRect.y + 'px;' + 'left:' + this.mapObject.mapAreaRect.x + 'px;' + 'height:' + this.mapObject.mapAreaRect.height + 'px;' + 'width:' + this.mapObject.mapAreaRect.width + 'px;'\n    });\n\n    var _loop_1 = function (i) {\n      var k = void 0;\n      var currentShapeData = this_1.currentLayer.layerData[i];\n      var pathOptions;\n      var polyLineOptions;\n      var circleOptions;\n      var groupElement;\n      var drawObject = void 0;\n      var path = '';\n      var points = '';\n      var getShapeColor_1 = void 0;\n      var fill = shapeSettings.autofill ? colors[i % colors.length] : shapeSettings.fill;\n      var opacity;\n\n      if (shapeSettings.colorValuePath !== null && !isNullOrUndefined(currentShapeData['property'])) {\n        k = checkShapeDataFields(this_1.currentLayer.dataSource, currentShapeData['property'], this_1.currentLayer.shapeDataPath, this_1.currentLayer.shapePropertyPath);\n\n        if (k !== null && shapeSettings.colorMapping.length === 0) {\n          fill = this_1.currentLayer.dataSource[k][shapeSettings.colorValuePath];\n        } else if (currentShapeData['property'][shapeSettings.colorValuePath] && this_1.currentLayer.dataSource.length === 0 && shapeSettings.colorMapping.length === 0) {\n          fill = currentShapeData['property'][shapeSettings.colorValuePath];\n        }\n      }\n\n      var shapeID = this_1.mapObject.element.id + '_LayerIndex_' + layerIndex + '_shapeIndex_' + i + '_dataIndex_' + k;\n      getShapeColor_1 = this_1.getShapeColorMapping(this_1.currentLayer, currentShapeData['property'], fill);\n      fill = Object.prototype.toString.call(getShapeColor_1) === '[object Object]' && !isNullOrUndefined(getShapeColor_1['fill']) ? getShapeColor_1['fill'] : fill;\n      opacity = Object.prototype.toString.call(getShapeColor_1) === '[object Object]' && !isNullOrUndefined(getShapeColor_1['opacity']) ? getShapeColor_1['opacity'] : shapeSettings.opacity;\n      var eventArgs = {\n        cancel: false,\n        name: shapeRendering,\n        index: i,\n        data: this_1.currentLayer.dataSource ? this_1.currentLayer.dataSource[k] : null,\n        maps: this_1.mapObject,\n        shape: shapeSettings,\n        fill: fill,\n        border: {\n          width: shapeSettings.border.width,\n          color: shapeSettings.border.color\n        }\n      };\n\n      if (this_1.mapObject.isBlazor) {\n        var maps = eventArgs.maps,\n            blazorEventArgs = __rest(eventArgs, [\"maps\"]);\n\n        eventArgs = blazorEventArgs;\n      } // tslint:disable-next-line:max-func-body-length\n\n\n      var shapeRenderingSuccess = function (eventArgs) {\n        var drawingType = !isNullOrUndefined(currentShapeData['_isMultiPolygon']) ? 'MultiPolygon' : isNullOrUndefined(currentShapeData['type']) ? currentShapeData[0]['type'] : currentShapeData['type'];\n        drawingType = drawingType === 'Polygon' || drawingType === 'MultiPolygon' ? 'Polygon' : drawingType;\n        eventArgs.fill = eventArgs.fill === '#A6A6A6' ? eventArgs.shape.fill : eventArgs.fill;\n        eventArgs.border.color = eventArgs.border.color === '#000000' ? eventArgs.shape.border.color : eventArgs.border.color;\n        eventArgs.border.width = eventArgs.border.width === 0 ? eventArgs.shape.border.width : eventArgs.border.width;\n        _this.mapObject.layers[layerIndex].shapeSettings.border = eventArgs.border;\n\n        if (_this.groupElements.length < 1) {\n          groupElement = _this.mapObject.renderer.createGroup({\n            id: _this.mapObject.element.id + '_LayerIndex_' + layerIndex + '_' + drawingType + '_Group',\n            transform: ''\n          });\n\n          _this.groupElements.push(groupElement);\n        } else {\n          for (var i_1 = 0; i_1 < _this.groupElements.length; i_1++) {\n            var ele = _this.groupElements[i_1];\n\n            if (ele.id.indexOf(drawingType) > -1) {\n              groupElement = ele;\n              break;\n            } else if (i_1 >= _this.groupElements.length - 1) {\n              groupElement = _this.mapObject.renderer.createGroup({\n                id: _this.mapObject.element.id + '_LayerIndex_' + layerIndex + '_' + drawingType + '_Group'\n              });\n\n              _this.groupElements.push(groupElement);\n\n              break;\n            }\n          }\n        }\n\n        var pathEle;\n\n        switch (drawingType) {\n          case 'Polygon':\n            if (!currentShapeData['_isMultiPolygon']) {\n              path += 'M' + currentShapeData[0]['point']['x'] + ' ' + currentShapeData[0]['point']['y'];\n              currentShapeData.map(function (shapeData) {\n                path += ' L ' + shapeData['point']['x'] + ' ' + shapeData['point']['y'];\n              });\n            } else {\n              path = _this.generateMultiPolygonPath(currentShapeData);\n            }\n\n            path += ' z ';\n\n            if (path.length > 3) {\n              pathOptions = new PathOption(shapeID, eventArgs.fill, eventArgs.border.width, eventArgs.border.color, opacity, shapeSettings.dashArray, path);\n              pathEle = _this.mapObject.renderer.drawPath(pathOptions);\n            }\n\n            break;\n\n          case 'LineString':\n            currentShapeData.map(function (lineData) {\n              points += lineData['point']['x'] + ' , ' + lineData['point']['y'] + ' ';\n            });\n            polyLineOptions = new PolylineOption(shapeID, points, eventArgs.fill, eventArgs.border.width, eventArgs.border.color, opacity, shapeSettings.dashArray);\n            pathEle = _this.mapObject.renderer.drawPolyline(polyLineOptions);\n            break;\n\n          case 'Point':\n            var pointData = currentShapeData['point'];\n            circleOptions = new CircleOption(shapeID, eventArgs.fill, eventArgs.border, opacity, pointData['x'], pointData['y'], shapeSettings.circleRadius, null);\n            pathEle = _this.mapObject.renderer.drawCircle(circleOptions);\n            break;\n\n          case 'Path':\n            path = currentShapeData['point'];\n            pathOptions = new PathOption(shapeID, eventArgs.fill, eventArgs.border.width, eventArgs.border.color, opacity, shapeSettings.dashArray, path);\n            pathEle = _this.mapObject.renderer.drawPath(pathOptions);\n            break;\n        }\n\n        if (!isNullOrUndefined(pathEle)) {\n          var property = Object.prototype.toString.call(_this.currentLayer.shapePropertyPath) === '[object Array]' ? _this.currentLayer.shapePropertyPath : [_this.currentLayer.shapePropertyPath]; // tslint:disable-next-line:align\n\n          var properties = void 0;\n\n          for (var j = 0; j < property.length; j++) {\n            if (!isNullOrUndefined(currentShapeData['property'])) {\n              properties = property[j];\n              break;\n            }\n          }\n\n          pathEle.setAttribute('aria-label', !isNullOrUndefined(currentShapeData['property']) ? currentShapeData['property'][properties] : '');\n          pathEle.setAttribute('tabindex', (_this.mapObject.tabIndex + i + 2).toString());\n          groupElement.appendChild(pathEle);\n        }\n\n        if (i === _this.currentLayer.layerData.length - 1) {\n          var bubbleG_1;\n\n          if (_this.currentLayer.bubbleSettings.length && _this.mapObject.bubbleModule) {\n            var length_1 = _this.currentLayer.bubbleSettings.length;\n            var bubble_1;\n\n            var _loop_2 = function (j) {\n              bubble_1 = _this.currentLayer.bubbleSettings[j];\n              bubbleG_1 = _this.mapObject.renderer.createGroup({\n                id: _this.mapObject.element.id + '_LayerIndex_' + layerIndex + '_bubble_Group_' + j\n              });\n              var range = {\n                min: 0,\n                max: 0\n              };\n\n              _this.bubbleCalculation(bubble_1, range);\n\n              bubble_1.dataSource.map(function (bubbleData, i) {\n                _this.renderBubble(_this.currentLayer, bubbleData, colors[i % colors.length], range, j, i, bubbleG_1, layerIndex, bubble_1);\n              });\n\n              _this.groupElements.push(bubbleG_1);\n            };\n\n            for (var j = 0; j < length_1; j++) {\n              _loop_2(j);\n            }\n          }\n\n          var group_1 = _this.mapObject.renderer.createGroup({\n            id: _this.mapObject.element.id + '_LayerIndex_' + layerIndex + '_dataLableIndex_Group',\n            style: 'pointer-events: none;'\n          });\n\n          if (_this.mapObject.dataLabelModule && _this.currentLayer.dataLabelSettings.visible) {\n            var intersect_1 = [];\n            renderData.map(function (currentShapeData, i) {\n              _this.renderLabel(_this.currentLayer, layerIndex, currentShapeData, group_1, i, labelTemplateEle, intersect_1);\n            });\n\n            _this.groupElements.push(group_1);\n          }\n\n          if (_this.mapObject.navigationLineModule) {\n            _this.groupElements.push(_this.mapObject.navigationLineModule.renderNavigation(_this.currentLayer, _this.currentFactor, layerIndex));\n          }\n\n          _this.groupElements.map(function (element) {\n            _this.layerObject.appendChild(element);\n          });\n\n          if (_this.mapObject.markerModule) {\n            _this.mapObject.markerModule.markerRender(_this.layerObject, layerIndex, _this.currentFactor, null);\n          }\n\n          _this.translateLayerElements(_this.layerObject, layerIndex);\n\n          _this.layerGroup.appendChild(_this.layerObject);\n        }\n      };\n\n      shapeRenderingSuccess.bind(this_1);\n      this_1.mapObject.trigger('shapeRendering', eventArgs, shapeRenderingSuccess);\n    };\n\n    var this_1 = this;\n\n    for (var i = 0; i < this.currentLayer.layerData.length; i++) {\n      _loop_1(i);\n    }\n  };\n  /**\n   *  render datalabel\n   */\n\n\n  LayerPanel.prototype.renderLabel = function (layer, layerIndex, shape, group, shapeIndex, labelTemplateEle, intersect) {\n    this.mapObject.dataLabelModule.renderLabel(layer, layerIndex, shape, layer.layerData, group, labelTemplateEle, shapeIndex, intersect);\n  };\n  /**\n   * To render path for multipolygon\n   */\n\n\n  LayerPanel.prototype.generateMultiPolygonPath = function (currentShapeData) {\n    var path = '';\n    var shape;\n\n    for (var j = 0; j < currentShapeData.length; j++) {\n      path += 'M' + currentShapeData[j][0]['point']['x'] + ' ' + currentShapeData[j][0]['point']['y'];\n      shape = currentShapeData[j];\n      shape.map(function (shapeData) {\n        path += ' L ' + shapeData['point']['x'] + ' ' + shapeData['point']['y'];\n      });\n    }\n\n    return path;\n  };\n  /**\n   * To render bubble\n   */\n\n\n  LayerPanel.prototype.renderBubble = function (layer, bubbleData, color, range, bubbleIndex, dataIndex, group, layerIndex, bubbleSettings) {\n    if (isNullOrUndefined(this.mapObject.bubbleModule) || !bubbleSettings.visible) {\n      return null;\n    }\n\n    color = bubbleSettings.fill ? bubbleSettings.fill : color;\n    this.mapObject.bubbleModule.id = this.mapObject.element.id + '_LayerIndex_' + layerIndex + '_BubbleIndex_' + bubbleIndex + '_dataIndex_' + dataIndex;\n    this.mapObject.bubbleModule.renderBubble(bubbleSettings, bubbleData, color, range, bubbleIndex, dataIndex, layerIndex, layer, group, this.mapObject.bubbleModule.id);\n  };\n  /**\n   * To get the shape color from color mapping module\n   */\n\n\n  LayerPanel.prototype.getShapeColorMapping = function (layer, shape, color) {\n    color = color ? color : layer.shapeSettings.fill;\n\n    if (layer.shapeSettings.colorMapping.length === 0 && isNullOrUndefined(layer.dataSource)) {\n      return color;\n    }\n\n    var index = checkShapeDataFields(layer.dataSource, shape, layer.shapeDataPath, layer.shapePropertyPath);\n    var colorMapping = new ColorMapping(this.mapObject);\n\n    if (isNullOrUndefined(layer.dataSource[index])) {\n      return color;\n    }\n\n    return colorMapping.getShapeColorMapping(layer.shapeSettings, layer.dataSource[index], color);\n  };\n\n  LayerPanel.prototype.generatePoints = function (type, coordinates, data, properties) {\n    var _this = this;\n\n    var latitude;\n    var longitude;\n    var newData = [];\n\n    switch (type.toLowerCase()) {\n      case 'polygon':\n        newData = this.calculatePolygonBox(coordinates[0], data, properties);\n\n        if (newData.length > 0) {\n          newData['property'] = properties;\n          newData['type'] = type;\n          newData['_isMultiPolygon'] = false;\n          this.currentLayer.layerData.push(newData);\n        }\n\n        break;\n\n      case 'multipolygon':\n        var multiPolygonDatas = [];\n\n        for (var i = 0; i < coordinates.length; i++) {\n          newData = this.calculatePolygonBox(coordinates[i][0], data, properties);\n\n          if (newData.length > 0) {\n            multiPolygonDatas.push(newData);\n          }\n        }\n\n        multiPolygonDatas['property'] = properties;\n        multiPolygonDatas['type'] = type;\n        multiPolygonDatas['_isMultiPolygon'] = true;\n        this.currentLayer.layerData.push(multiPolygonDatas);\n        break;\n\n      case 'linestring':\n        coordinates.map(function (points, index) {\n          latitude = points[1];\n          longitude = points[0];\n          var point = convertGeoToPoint(latitude, longitude, _this.currentFactor, _this.currentLayer, _this.mapObject);\n          newData.push({\n            point: point,\n            lat: latitude,\n            lng: longitude\n          });\n        });\n        newData['property'] = properties;\n        newData['type'] = type;\n        this.currentLayer.layerData.push(newData);\n        break;\n\n      case 'point':\n        var arrayCollections_1 = false;\n        coordinates.map(function (points, index) {\n          if (Object.prototype.toString.call(points) === '[object Array]') {\n            latitude = points[1];\n            longitude = points[0];\n            arrayCollections_1 = true;\n            var point = convertGeoToPoint(latitude, longitude, _this.currentFactor, _this.currentLayer, _this.mapObject);\n\n            _this.currentLayer.layerData.push({\n              point: point,\n              type: type,\n              lat: latitude,\n              lng: longitude,\n              property: properties\n            });\n          }\n        });\n\n        if (!arrayCollections_1) {\n          latitude = coordinates[1];\n          longitude = coordinates[0];\n          var point = convertGeoToPoint(latitude, longitude, this.currentFactor, this.currentLayer, this.mapObject);\n          this.currentLayer.layerData.push({\n            point: point,\n            type: type,\n            lat: latitude,\n            lng: longitude,\n            property: properties\n          });\n        }\n\n        break;\n\n      case 'path':\n        this.currentLayer.layerData.push({\n          point: data['d'],\n          type: type,\n          property: properties\n        });\n        break;\n    }\n  };\n\n  LayerPanel.prototype.calculateFactor = function (layer) {\n    var horFactor;\n    var verFactor = 1;\n    var divide = 10;\n    var exp = 'e+1';\n    var bounds = this.mapObject.baseMapBounds;\n    var mapSize = new Size(this.mapObject.mapAreaRect.width, this.mapObject.mapAreaRect.height - 5);\n    var mapHeight;\n    var mapWidth;\n\n    if (bounds) {\n      var start = convertGeoToPoint(bounds.latitude.min, bounds.longitude.min, null, layer, this.mapObject);\n      var end = convertGeoToPoint(bounds.latitude.max, bounds.longitude.max, null, layer, this.mapObject);\n      mapHeight = end.y - start.y;\n      mapWidth = end.x - start.x;\n    } else {\n      mapHeight = mapWidth = 500;\n    }\n\n    if (mapHeight < mapSize.height) {\n      horFactor = parseFloat(Math.abs(Number(mapSize.height / Number(mapHeight.toString() + exp)) * 100).toString().split('.')[0]) / divide;\n    } else {\n      horFactor = mapSize.height / mapHeight;\n    }\n\n    if (mapWidth < mapSize.width) {\n      verFactor = parseFloat(Math.abs(Number(mapSize.width / Number(mapWidth.toString() + exp)) * 100).toString().split('.')[0]) / divide;\n    } else {\n      verFactor = mapSize.width / mapWidth;\n    }\n\n    return Math.min(verFactor, horFactor);\n  };\n\n  LayerPanel.prototype.translateLayerElements = function (layerElement, index) {\n    var childNode;\n\n    if (!isNullOrUndefined(this.mapObject.baseMapRectBounds)) {\n      var duration = this.currentLayer.animationDuration;\n      var animate = duration !== 0 || isNullOrUndefined(this.mapObject.zoomModule);\n      this.mapObject.baseTranslatePoint = this.mapObject.zoomTranslatePoint;\n      var translate = void 0;\n\n      if (this.mapObject.zoomSettings.zoomFactor > 1 && !isNullOrUndefined(this.mapObject.zoomModule)) {\n        translate = getZoomTranslate(this.mapObject, this.currentLayer, animate);\n      } else {\n        translate = getTranslate(this.mapObject, this.currentLayer, animate);\n      }\n\n      var scale = this.mapObject.previousScale = translate['scale'];\n      var location_1 = this.mapObject.previousPoint = translate['location'];\n      this.mapObject.baseTranslatePoint = this.mapObject.translatePoint = location_1;\n      this.mapObject.baseScale = this.mapObject.scale = scale;\n\n      for (var i = 0; i < layerElement.childElementCount; i++) {\n        childNode = layerElement.childNodes[i];\n\n        if (!(childNode.id.indexOf('_Markers_Group') > -1) && !(childNode.id.indexOf('_bubble_Group') > -1) && !(childNode.id.indexOf('_dataLableIndex_Group') > -1)) {\n          var transform = 'scale( ' + scale + ' ) ' + 'translate( ' + location_1.x + ' ' + location_1.y + ' ) ';\n          childNode.setAttribute('transform', transform);\n\n          if (duration > 0 && !isNullOrUndefined(this.mapObject.zoomModule)) {\n            if (this.mapObject.zoomSettings.zoomFactor > 1) {\n              translate = getZoomTranslate(this.mapObject, this.currentLayer);\n            } else {\n              translate = getTranslate(this.mapObject, this.currentLayer);\n            }\n\n            this.mapObject.scale = translate['scale'];\n            this.mapObject.zoomTranslatePoint = this.mapObject.translatePoint = translate['location'];\n          }\n        }\n      }\n    } else if (this.mapObject.isTileMap && !isNullOrUndefined(this.mapObject.scale)) {\n      for (var j = 0; j < layerElement.childElementCount; j++) {\n        childNode = layerElement.childNodes[j];\n\n        if (!(childNode.id.indexOf('_Markers_Group') > -1) && !(childNode.id.indexOf('_bubble_Group') > -1) && !(childNode.id.indexOf('_dataLableIndex_Group') > -1) && !(childNode.id.indexOf('_line_Group') > -1)) {\n          var transform = 'scale( ' + this.mapObject.scale + ' ) ' + 'translate( ' + this.mapObject.translatePoint.x + ' ' + this.mapObject.translatePoint.y + ' ) ';\n          childNode.setAttribute('transform', transform);\n        }\n      }\n    }\n  };\n\n  LayerPanel.prototype.calculateRectBounds = function (layerData) {\n    var _this = this;\n\n    layerData.forEach(function (obj, index) {\n      if (!isNullOrUndefined(obj['geometry']) || !isNullOrUndefined(obj['coordinates'])) {\n        var type = !isNullOrUndefined(obj['geometry']) ? obj['geometry']['type'] : obj['type'];\n        var coordinates = !isNullOrUndefined(obj['geometry']) ? obj['geometry']['coordinates'] : obj['coordinates'];\n\n        switch (type.toLowerCase()) {\n          case 'polygon':\n            _this.calculateRectBox(coordinates[0]);\n\n            break;\n\n          case 'multipolygon':\n            coordinates.map(function (point, index) {\n              _this.calculateRectBox(point[0]);\n            });\n            break;\n        }\n      }\n    });\n  };\n\n  LayerPanel.prototype.calculatePolygonBox = function (coordinates, data, properties) {\n    var _this = this;\n\n    var newData = [];\n    var bounds = this.mapObject.baseMapBounds;\n    coordinates.map(function (currentPoint, index) {\n      var latitude = currentPoint[1];\n      var longitude = currentPoint[0];\n\n      if (longitude >= bounds.longitude.min && longitude <= bounds.longitude.max && latitude >= bounds.latitude.min && latitude <= bounds.latitude.max) {\n        var point = convertGeoToPoint(latitude, longitude, _this.currentFactor, _this.currentLayer, _this.mapObject);\n\n        if (isNullOrUndefined(_this.rectBounds)) {\n          _this.rectBounds = {\n            min: {\n              x: point.x,\n              y: point.y\n            },\n            max: {\n              x: point.x,\n              y: point.y\n            }\n          };\n        } else {\n          _this.rectBounds['min']['x'] = Math.min(_this.rectBounds['min']['x'], point.x);\n          _this.rectBounds['min']['y'] = Math.min(_this.rectBounds['min']['y'], point.y);\n          _this.rectBounds['max']['x'] = Math.max(_this.rectBounds['max']['x'], point.x);\n          _this.rectBounds['max']['y'] = Math.max(_this.rectBounds['max']['y'], point.y);\n        }\n\n        newData.push({\n          point: point,\n          lat: latitude,\n          lng: longitude\n        });\n      }\n    });\n    return newData;\n  };\n\n  LayerPanel.prototype.calculateRectBox = function (coordinates) {\n    var _this = this;\n\n    coordinates.forEach(function (currentCoords) {\n      if (isNullOrUndefined(_this.mapObject.baseMapBounds)) {\n        _this.mapObject.baseMapBounds = new GeoLocation({\n          min: currentCoords[1],\n          max: currentCoords[1]\n        }, {\n          min: currentCoords[0],\n          max: currentCoords[0]\n        });\n      } else {\n        _this.mapObject.baseMapBounds.latitude.min = Math.min(_this.mapObject.baseMapBounds.latitude.min, currentCoords[1]);\n        _this.mapObject.baseMapBounds.latitude.max = Math.max(_this.mapObject.baseMapBounds.latitude.max, currentCoords[1]);\n        _this.mapObject.baseMapBounds.longitude.min = Math.min(_this.mapObject.baseMapBounds.longitude.min, currentCoords[0]);\n        _this.mapObject.baseMapBounds.longitude.max = Math.max(_this.mapObject.baseMapBounds.longitude.max, currentCoords[0]);\n      }\n    });\n  };\n\n  LayerPanel.prototype.generateTiles = function (zoomLevel, tileTranslatePoint, bing) {\n    var userLang = this.mapObject.locale;\n    var size = this.mapObject.availableSize;\n    this.tiles = [];\n    var xcount;\n    var ycount;\n    xcount = ycount = Math.pow(2, zoomLevel);\n    var width = size.width / 2;\n    var height = size.height / 2;\n    var baseLayer = this.mapObject.layers[this.mapObject.baseLayerIndex];\n    this.urlTemplate = baseLayer.urlTemplate;\n    var endY = Math.min(ycount, (-tileTranslatePoint.y + size.height) / 256 + 1);\n    var endX = Math.min(xcount, (-tileTranslatePoint.x + size.width) / 256 + 1);\n    var startX = -(tileTranslatePoint.x + 256) / 256;\n    var startY = -(tileTranslatePoint.y + 256) / 256;\n    bing = bing || this.bing || this.mapObject['bingMap'];\n\n    for (var i = Math.round(startX); i < Math.round(endX); i++) {\n      for (var j = Math.round(startY); j < Math.round(endY); j++) {\n        var x = 256 * i + tileTranslatePoint.x;\n        var y = 256 * j + tileTranslatePoint.y;\n\n        if (x > -256 && x <= size.width && y > -256 && y < size.height) {\n          if (i >= 0 && j >= 0) {\n            var tile = new Tile(i, j);\n            tile.left = x;\n            tile.top = y;\n\n            if (baseLayer.layerType === 'Bing') {\n              var key = baseLayer.key;\n              tile.src = bing.getBingMap(tile, key, baseLayer.bingMapType, userLang, bing.imageUrl, bing.subDomains);\n            } else {\n              tile.src = this.urlTemplate.replace('level', zoomLevel.toString()).replace('tileX', tile.x.toString()).replace('tileY', tile.y.toString());\n            }\n\n            this.tiles.push(tile);\n          }\n        }\n      }\n    }\n\n    var proxTiles = extend([], this.tiles, [], true);\n\n    for (var _i = 0, _a = this.mapObject.layers; _i < _a.length; _i++) {\n      var layer = _a[_i];\n\n      if (!(layer.type === 'SubLayer' && layer.visible)) {\n        continue;\n      }\n\n      if (layer.layerType === 'OSM' || layer.layerType === 'Bing') {\n        for (var _b = 0, proxTiles_1 = proxTiles; _b < proxTiles_1.length; _b++) {\n          var baseTile = proxTiles_1[_b];\n          var subtile = extend(baseTile, {}, {}, true);\n\n          if (layer.layerType === 'Bing') {\n            subtile.src = bing.getBingMap(subtile, layer.key, layer.bingMapType, userLang, bing.imageUrl, bing.subDomains);\n          } else {\n            subtile.src = layer.urlTemplate.replace('level', zoomLevel.toString()).replace('tileX', baseTile.x.toString()).replace('tileY', baseTile.y.toString());\n          }\n\n          this.tiles.push(subtile);\n        }\n      }\n    }\n\n    this.arrangeTiles();\n  };\n\n  LayerPanel.prototype.arrangeTiles = function () {\n    var htmlString = this.templateCompiler(this.tiles);\n\n    if (getElementByID(this.mapObject.element.id + '_tile_parent')) {\n      document.getElementById(this.mapObject.element.id + '_tile_parent').innerHTML = htmlString;\n    }\n  };\n\n  LayerPanel.prototype.templateCompiler = function (tiles) {\n    var tileElment = '';\n    var id = 0;\n\n    for (var _i = 0, tiles_1 = tiles; _i < tiles_1.length; _i++) {\n      var tile = tiles_1[_i];\n\n      if (this.urlTemplate.indexOf('tileX') !== -1) {\n        tileElment += '<div><div id=\"tile' + id + '\" style=\"position:absolute;left: ' + tile.left + 'px;top: ' + tile.top + 'px;height: ' + tile.height + 'px;width: ' + tile.width + 'px;\"><img src=\"' + tile.src + '\"></img></div></div>';\n        id++;\n      } else {\n        tileElment = '<div style=\"position:absolute;\"><img src=\"' + this.urlTemplate + '\"></div>';\n        break;\n      }\n    }\n\n    return tileElment;\n  };\n\n  LayerPanel.prototype.panTileMap = function (factorX, factorY, centerPosition) {\n    var level = this.mapObject.tileZoomLevel;\n    var padding = 20;\n    var x;\n    var y;\n    var totalSize = Math.pow(2, level) * 256;\n    x = factorX / 2 - totalSize / 2;\n    y = factorY / 2 - totalSize / 2;\n    var position = convertTileLatLongToPoint(centerPosition, level, {\n      x: x,\n      y: y\n    }, this.isMapCoordinates);\n    x -= position.x - factorX / 2;\n    y = y - (position.y - factorY / 2) + padding;\n    this.mapObject.scale = Math.pow(2, level - 1);\n\n    if (!isNullOrUndefined(this.mapObject.tileTranslatePoint)) {\n      if (this.mapObject.tileTranslatePoint.x !== 0 && this.mapObject.tileTranslatePoint.x !== x) {\n        x = this.mapObject.tileTranslatePoint.x;\n      }\n\n      if (this.mapObject.tileTranslatePoint.y !== 0 && this.mapObject.tileTranslatePoint.y !== y) {\n        y = this.mapObject.tileTranslatePoint.y;\n      }\n    }\n\n    this.mapObject.translatePoint = new Point((x - 0.01 * this.mapObject.scale) / this.mapObject.scale, (y - 0.01 * this.mapObject.scale) / this.mapObject.scale);\n    return new Point(x, y);\n  };\n\n  return LayerPanel;\n}();\n\nexport { LayerPanel };","map":null,"metadata":{},"sourceType":"module"}