{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nimport { findMidPointOfPolygon, Rect, filter, getTemplateFunction, getTranslate, RectOption, convertElementFromLabel, Point, TextOption, renderTextElement, textTrim, measureText, Internalize } from '../utils/helper';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { dataLabelRendering } from '../model/constants';\n/**\n * DataLabel Module used to render the maps datalabel\n */\n\nvar DataLabel =\n/** @class */\nfunction () {\n  function DataLabel(maps) {\n    this.value = {\n      rightWidth: 0,\n      leftWidth: 0,\n      heightTop: 0,\n      heightBottom: 0\n    };\n    this.maps = maps;\n    this.dataLabelCollections = [];\n  } //tslint:disable:max-func-body-length\n\n\n  DataLabel.prototype.getDataLabel = function (dataSource, labelPath, shapeName, shapeDataPath) {\n    var text;\n\n    for (var i = 0; i < dataSource.length; i++) {\n      var data = dataSource[i];\n\n      if (data[shapeDataPath] === shapeName) {\n        text = data;\n        break;\n      }\n    }\n\n    return text;\n  };\n  /**\n   * To render label for maps\n   * @param layer\n   * @param layerIndex\n   * @param shape\n   * @param layerData\n   * @param group\n   * @param labelTemplateElement\n   * @param index\n   */\n\n\n  DataLabel.prototype.renderLabel = function (layer, layerIndex, shape, layerData, group, labelTemplateElement, index, intersect) {\n    var _this = this;\n\n    var dataLabel = layer.dataLabelSettings;\n    var style = layer.dataLabelSettings.textStyle;\n    var markerEle;\n    var templateFn;\n    var options;\n    var dataLabelSettings = layer.dataLabelSettings;\n    var labelpath = layer.dataLabelSettings.labelPath;\n    var shapePoint = [[]];\n    var midIndex = 0;\n    var pointsLength = 0;\n    var shapeData = shape;\n    var element;\n    var data;\n    var text = '';\n    var datasrcObj;\n    var currentLength = 0;\n    var oldIndex;\n    var location;\n    var sublayerIndexLabel = false;\n    var shapeProperties = shape['properties'];\n    var labelId = this.maps.element.id + '_LayerIndex_' + layerIndex + '_shapeIndex_' + index + '_LabelIndex_' + index;\n    var textLocation = new Point(0, 0);\n    /* tslint:disable:no-string-literal */\n\n    var shapes = layerData[index];\n    var locationX;\n    var locationY;\n    style.fontFamily = this.maps.themeStyle.labelFontFamily;\n    shape = shapes['property'];\n    var properties = Object.prototype.toString.call(layer.shapePropertyPath) === '[object Array]' ? layer.shapePropertyPath : [layer.shapePropertyPath];\n    var propertyPath;\n    var animate = layer.animationDuration !== 0 || isNullOrUndefined(this.maps.zoomModule);\n    var translate = this.maps.isTileMap ? new Object() : getTranslate(this.maps, layer, animate);\n    var scale = this.maps.isTileMap ? this.maps.scale : translate['scale'];\n    var transPoint = this.maps.isTileMap ? this.maps.translatePoint : translate['location'];\n    var zoomTransPoint = this.maps.zoomTranslatePoint;\n    var shapeWidth;\n    var scaleZoomValue = !isNullOrUndefined(this.maps.scale) ? Math.floor(this.maps.scale) : 1;\n    var zoomLabelsPosition = this.maps.zoomSettings.enable ? !isNullOrUndefined(this.maps.zoomShapeCollection) && this.maps.zoomShapeCollection.length > 0 : this.maps.zoomSettings.enable;\n\n    for (var j = 0; j < properties.length; j++) {\n      if (shapeProperties[properties[j]]) {\n        propertyPath = properties[j];\n        datasrcObj = this.getDataLabel(layer.dataSource, labelpath, shapeData['properties'][propertyPath], layer.shapeDataPath);\n\n        if (datasrcObj) {\n          break;\n        }\n      }\n    }\n\n    datasrcObj = this.getDataLabel(layer.dataSource, labelpath, shapeData['properties'][propertyPath], layer.shapeDataPath);\n\n    if (!isNullOrUndefined(shapes['property']) && (shapeProperties[labelpath] || datasrcObj)) {\n      shapePoint = [[]];\n\n      if (!layerData[index]['_isMultiPolygon']) {\n        shapePoint.push(this.getPoint(layerData[index], []));\n        currentLength = shapePoint[shapePoint.length - 1].length;\n\n        if (pointsLength < currentLength) {\n          pointsLength = currentLength;\n          midIndex = shapePoint.length - 1;\n        }\n      } else {\n        var layer_1 = layerData[index];\n\n        for (var j = 0; j < layer_1.length; j++) {\n          shapePoint.push(this.getPoint(layer_1[j], []));\n          currentLength = shapePoint[shapePoint.length - 1].length;\n\n          if (pointsLength < currentLength) {\n            pointsLength = currentLength;\n            midIndex = shapePoint.length - 1;\n          }\n        }\n      }\n    }\n\n    text = !isNullOrUndefined(datasrcObj) ? datasrcObj[labelpath].toString() : shapeData['properties'][labelpath];\n    var dataLabelText = text;\n    var projectionType = this.maps.projectionType;\n    location = findMidPointOfPolygon(shapePoint[midIndex], projectionType);\n    var firstLevelMapLocation = location;\n\n    if (!isNullOrUndefined(text) && !isNullOrUndefined(location)) {\n      if (zoomLabelsPosition && scaleZoomValue > 1) {\n        if (layerIndex > 0) {\n          for (var k = 0; k < this.maps.zoomLabelPositions.length; k++) {\n            if (this.maps.zoomLabelPositions[k]['dataLabelText'] === text) {\n              oldIndex = index;\n              index = k;\n              sublayerIndexLabel = true;\n              break;\n            }\n          }\n        }\n\n        locationX = location['x'];\n        locationY = location['y'];\n        location['x'] = (location['x'] + zoomTransPoint['x']) * scale;\n        location['y'] = (location['y'] + zoomTransPoint['y']) * scale;\n      }\n\n      location['y'] = this.maps.projectionType === 'Mercator' ? location['y'] : -location['y'];\n      data = location;\n\n      if (!isNullOrUndefined(this.maps.format) && !isNaN(parseFloat(text))) {\n        if (this.maps.useGroupingSeparator) {\n          text = Internalize(this.maps, parseFloat(text));\n\n          if (!isNullOrUndefined(datasrcObj)) {\n            datasrcObj[labelpath] = text;\n          }\n        }\n      }\n\n      var eventargs_1 = {\n        name: dataLabelRendering,\n        maps: this.maps,\n        cancel: false,\n        border: dataLabel.border,\n        datalabel: dataLabel,\n        fill: dataLabel.fill,\n        template: dataLabel.template,\n        text: text\n      };\n\n      if (this.maps.isBlazor) {\n        var maps = eventargs_1.maps,\n            blazorEventArgs = __rest(eventargs_1, [\"maps\"]);\n\n        eventargs_1 = blazorEventArgs;\n      }\n\n      this.maps.trigger('dataLabelRendering', eventargs_1, function (labelArgs) {\n        if (eventargs_1.cancel) {\n          return;\n        }\n\n        var border = {\n          color: 'yellow'\n        };\n        var position = [];\n        var width = zoomLabelsPosition && scaleZoomValue > 1 ? _this.maps.zoomShapeCollection[index]['width'] : location['rightMax']['x'] - location['leftMax']['x'];\n\n        if (!isNullOrUndefined(_this.maps.dataLabelShape)) {\n          shapeWidth = firstLevelMapLocation['rightMax']['x'] - firstLevelMapLocation['leftMax']['x'];\n\n          _this.maps.dataLabelShape.push(shapeWidth);\n        }\n\n        if (eventargs_1.text !== text && !eventargs_1.cancel) {\n          text = eventargs_1.text;\n        }\n\n        var textSize = measureText(text, style);\n        var trimmedLable = textTrim(width, text, style);\n        var elementSize = measureText(trimmedLable, style);\n        var startY = location['y'] - textSize['height'] / 4;\n        var endY = location['y'] + textSize['height'] / 4;\n        var start = location['y'] - textSize['height'] / 4;\n        var end = location['y'] + textSize['height'] / 4;\n        position = filter(shapePoint[midIndex], startY, endY);\n\n        if (position.length > 5 && shapeData['geometry']['type'] !== 'MultiPolygon' && shapeData['type'] !== 'MultiPolygon') {\n          var location1 = findMidPointOfPolygon(position, projectionType);\n\n          if (zoomLabelsPosition && scaleZoomValue > 1) {\n            location1['x'] = (_this.maps.zoomLabelPositions[index]['location']['x'] + zoomTransPoint['x']) * scale;\n            location1['y'] = (_this.maps.zoomLabelPositions[index]['location']['y'] + zoomTransPoint['y']) * scale;\n          }\n\n          locationX = location1['x'];\n          location['x'] = location1['x'];\n          width = zoomLabelsPosition && scaleZoomValue > 1 ? _this.maps.zoomShapeCollection[index]['width'] : location1['rightMax']['x'] - location1['leftMax']['x'];\n        }\n\n        var xpositionEnds = location['x'] + textSize['width'] / 2;\n        var xpositionStart = location['x'] - textSize['width'] / 2;\n        trimmedLable = textTrim(width, text, style);\n        elementSize = measureText(trimmedLable, style);\n        _this.value[index] = {\n          rightWidth: xpositionEnds,\n          leftWidth: xpositionStart,\n          heightTop: start,\n          heightBottom: end\n        };\n        var labelElement;\n\n        if (eventargs_1.template !== '') {\n          templateFn = getTemplateFunction(eventargs_1.template);\n          var templateElement = templateFn ? templateFn(!isNullOrUndefined(datasrcObj) ? datasrcObj : shapeData['properties'], null, null, _this.maps.element.id + '_LabelTemplate', false) : document.createElement('div');\n          templateElement.innerHTML = !templateFn ? eventargs_1.template : '';\n          labelElement = convertElementFromLabel(templateElement, labelId, !isNullOrUndefined(datasrcObj) ? datasrcObj : shapeData['properties'], index, _this.maps);\n          labelElement.style.left = Math.abs(_this.maps.baseMapRectBounds['min']['x'] - location['x']) * scale + 'px';\n          labelElement.style.top = Math.abs(_this.maps.baseMapRectBounds['min']['y'] - location['y']) * scale + 'px';\n          labelTemplateElement.appendChild(labelElement);\n        } else {\n          if (dataLabelSettings.smartLabelMode === 'Trim') {\n            options = new TextOption(labelId, textLocation.x, textLocation.y, 'middle', trimmedLable, '', '');\n          }\n\n          if (dataLabelSettings.smartLabelMode === 'None') {\n            options = new TextOption(labelId, textLocation.x, textLocation.y, 'middle', text, '', '');\n          }\n\n          if (dataLabelSettings.smartLabelMode === 'Hide') {\n            text = width >= textSize['width'] ? text : '';\n            options = new TextOption(labelId, textLocation.x, textLocation.y, 'middle', text, '', '');\n          }\n\n          text = options['text'];\n\n          if (dataLabelSettings.intersectionAction === 'Hide') {\n            for (var i = 0; i < intersect.length; i++) {\n              if (!isNullOrUndefined(intersect[i])) {\n                if (_this.value[index]['leftWidth'] > intersect[i]['rightWidth'] || _this.value[index]['rightWidth'] < intersect[i]['leftWidth'] || _this.value[index]['heightTop'] > intersect[i]['heightBottom'] || _this.value[index]['heightBottom'] < intersect[i]['heightTop']) {\n                  text = text;\n                } else {\n                  text = '';\n                  break;\n                }\n              }\n            }\n\n            intersect.push(_this.value[index]);\n            options = new TextOption(labelId, textLocation.x, textLocation.y, 'middle', text, '', '');\n          }\n\n          var difference = void 0;\n\n          if (dataLabelSettings.intersectionAction === 'Trim') {\n            for (var j = 0; j < intersect.length; j++) {\n              if (!isNullOrUndefined(intersect[j])) {\n                if (intersect[j]['rightWidth'] < _this.value[index]['leftWidth'] || intersect[j]['leftWidth'] > _this.value[index]['rightWidth'] || intersect[j]['heightBottom'] < _this.value[index]['heightTop'] || intersect[j]['heightTop'] > _this.value[index]['heightBottom']) {\n                  trimmedLable = text;\n                  difference = 0;\n                } else {\n                  if (_this.value[index]['leftWidth'] > intersect[j]['leftWidth']) {\n                    width = intersect[j]['rightWidth'] - _this.value[index]['leftWidth'];\n                    difference = width - (_this.value[index]['rightWidth'] - _this.value[index]['leftWidth']);\n                    trimmedLable = textTrim(difference, text, style);\n                    break;\n                  }\n\n                  if (_this.value[index]['leftWidth'] < intersect[j]['leftWidth']) {\n                    width = _this.value[index]['rightWidth'] - intersect[j]['leftWidth'];\n                    difference = Math.abs(width - (_this.value[index]['rightWidth'] - _this.value[index]['leftWidth']));\n                    trimmedLable = textTrim(difference, text, style);\n                    break;\n                  }\n                }\n              }\n            }\n\n            intersect.push(_this.value[index]);\n            options = new TextOption(labelId, textLocation.x, textLocation.y, 'middle', trimmedLable, '', '');\n          }\n\n          if (dataLabelSettings.intersectionAction === 'None') {\n            options = new TextOption(labelId, textLocation.x, textLocation.y, 'middle', text, '', '');\n          }\n\n          if (trimmedLable.length > 1) {\n            var border_1 = eventargs_1.border;\n\n            if (border_1['width'] > 1) {\n              var fill = eventargs_1.fill;\n              var opacity = dataLabelSettings.opacity;\n              var rx = dataLabelSettings.rx;\n              var ry = dataLabelSettings.ry;\n              var x = void 0;\n              var y = void 0;\n              var padding = 5;\n\n              if (zoomLabelsPosition && scaleZoomValue > 1) {\n                x = location['x'] - textSize['width'] / 2;\n                y = location['y'] - textSize['height'] / 2 - padding;\n              } else {\n                x = (location['x'] + transPoint['x']) * scale - textSize['width'] / 2;\n                y = (location['y'] + transPoint['y']) * scale - textSize['height'] / 2;\n              }\n\n              var rectOptions = new RectOption(_this.maps.element.id + '_LayerIndex_' + layerIndex + '_shapeIndex_' + index + '_rectIndex_' + index, fill, border_1, opacity, new Rect(x, y, textSize['width'], textSize['height']), rx, ry);\n\n              var rect = _this.maps.renderer.drawRectangle(rectOptions);\n\n              group.appendChild(rect);\n            }\n          }\n\n          element = renderTextElement(options, style, style.color || _this.maps.themeStyle.dataLabelFontColor, group);\n\n          if (zoomLabelsPosition && scaleZoomValue > 1) {\n            element.setAttribute('transform', 'translate( ' + location['x'] + ' ' + location['y'] + ' )');\n            location['x'] = locationX;\n            location['y'] = locationY;\n          } else {\n            element.setAttribute('transform', 'translate( ' + (location['x'] + transPoint.x) * scale + ' ' + ((location['y'] + transPoint.y) * scale + elementSize.height / 4) + ' )');\n            location['y'] = location['y'] + elementSize.height / 4;\n          }\n\n          group.appendChild(element);\n        }\n\n        _this.dataLabelCollections.push({\n          location: {\n            x: location['x'],\n            y: location['y']\n          },\n          element: isNullOrUndefined(labelElement) ? element : labelElement,\n          layerIndex: layerIndex,\n          shapeIndex: sublayerIndexLabel ? oldIndex : index,\n          labelIndex: sublayerIndexLabel ? oldIndex : index,\n          dataLabelText: dataLabelText\n        });\n\n        if (labelTemplateElement.childElementCount > 0 && !_this.maps.element.contains(labelTemplateElement)) {\n          document.getElementById(_this.maps.element.id + '_Secondary_Element').appendChild(labelTemplateElement);\n        }\n      });\n    }\n  };\n\n  DataLabel.prototype.getPoint = function (shapes, points) {\n    shapes.map(function (current, index) {\n      points.push(new Point(current['point']['x'], current['point']['y']));\n    });\n    return points;\n  };\n  /**\n   * Get module name.\n   */\n\n\n  DataLabel.prototype.getModuleName = function () {\n    return 'DataLabel';\n  };\n  /**\n   * To destroy the layers.\n   * @return {void}\n   * @private\n   */\n\n\n  DataLabel.prototype.destroy = function (maps) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return DataLabel;\n}();\n\nexport { DataLabel };","map":null,"metadata":{},"sourceType":"module"}