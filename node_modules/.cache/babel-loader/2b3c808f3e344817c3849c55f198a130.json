{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Maps Component file\n */\n\n\nimport { Component, NotifyPropertyChanges, Property, Ajax, resetBlazorTemplate } from '@syncfusion/ej2-base';\nimport { EventHandler, Browser, isNullOrUndefined, createElement } from '@syncfusion/ej2-base';\nimport { Event, remove, L10n, Collection, Internationalization, Complex, isBlazor } from '@syncfusion/ej2-base';\nimport { updateBlazorTemplate } from '@syncfusion/ej2-base';\nimport { SvgRenderer } from '@syncfusion/ej2-svg-base';\nimport { Size, createSvg, Point, removeElement, triggerShapeEvent, showTooltip, mergeSeparateCluster } from './utils/helper';\nimport { getElement, removeClass, getTranslate } from './utils/helper';\nimport { ZoomSettings, LegendSettings } from './model/base';\nimport { LayerSettings, TitleSettings, Border, Margin, MapsAreaSettings, Annotation, CenterPosition } from './model/base';\nimport { Marker } from './layers/marker';\nimport { load, click, loaded, resize, shapeSelected } from './model/constants';\nimport { getThemeStyle } from './model/theme';\nimport { BingMap } from './layers/bing-map';\nimport { LayerPanel } from './layers/layer-panel';\nimport { Rect, RectOption, measureText, getElementByID, MapAjax } from '../maps/utils/helper';\nimport { findPosition, textTrim, TextOption, renderTextElement, convertGeoToPoint } from '../maps/utils/helper';\nimport { Annotations } from '../maps/user-interaction/annotation';\nimport { MarkerSettings } from './index';\nimport { changeBorderWidth } from './index';\nimport { DataManager, Query } from '@syncfusion/ej2-data';\nimport { ExportUtils } from '../maps/utils/export';\n/**\n * Represents the Maps control.\n * ```html\n * <div id=\"maps\"/>\n * <script>\n *   var maps = new Maps();\n *   maps.appendTo(\"#maps\");\n * </script>\n * ```\n */\n\nvar Maps =\n/** @class */\nfunction (_super) {\n  __extends(Maps, _super);\n  /**\n   * Constructor for creating the widget\n   */\n\n\n  function Maps(options, element) {\n    var _this = _super.call(this, options, element) || this;\n    /**\n     * Check layer whether is normal or tile\n     * @private\n     */\n\n\n    _this.isTileMap = false;\n    /** @private */\n\n    _this.baseSize = new Size(0, 0);\n    /** @public */\n\n    _this.translatePoint = new Point(0, 0);\n    /** @private */\n\n    _this.baseTranslatePoint = new Point(0, 0);\n    /** @public */\n\n    _this.zoomTranslatePoint = new Point(0, 0);\n    /** @private */\n\n    _this.tileTranslatePoint = new Point(0, 0);\n    /** @private */\n\n    _this.baseTileTranslatePoint = new Point(0, 0);\n    /** @private */\n\n    _this.isDevice = false;\n    /** @public */\n\n    _this.dataLabelShape = [];\n    _this.zoomShapeCollection = [];\n    _this.zoomLabelPositions = [];\n    _this.mouseDownEvent = {\n      x: null,\n      y: null\n    };\n    _this.mouseClickEvent = {\n      x: null,\n      y: null\n    };\n    return _this;\n  }\n  /**\n   * Gets the localized label by locale keyword.\n   * @param  {string} key\n   * @return {string}\n   */\n\n\n  Maps.prototype.getLocalizedLabel = function (key) {\n    return this.localeObject.getConstant(key);\n  };\n  /**\n   * Initializing pre-required values.\n   */\n\n\n  Maps.prototype.preRender = function () {\n    var _this = this;\n\n    this.isDevice = Browser.isDevice;\n    this.isBlazor = isBlazor();\n    this.initPrivateVariable();\n    this.trigger(load, this.isBlazor ? {} : {\n      maps: this\n    }, function () {\n      _this.unWireEVents();\n\n      _this.createSVG();\n\n      _this.wireEVents();\n\n      _this.setCulture();\n    });\n  };\n  /**\n   * To Initialize the control rendering.\n   */\n\n\n  Maps.prototype.render = function () {\n    this.findBaseAndSubLayers();\n    this.createSecondaryElement();\n    this.addTabIndex();\n    this.themeStyle = getThemeStyle(this.theme);\n    this.renderBorder();\n    this.renderTitle(this.titleSettings, 'title', null, null);\n    this.renderArea();\n    this.processRequestJsonData();\n    this.renderComplete();\n  };\n  /* tslint:disable:no-string-literal */\n\n\n  Maps.prototype.processRequestJsonData = function () {\n    var _this = this;\n\n    var length = this.layersCollection.length - 1;\n    this.serverProcess = {\n      request: 0,\n      response: 0\n    };\n    var queryModule;\n    var localAjax;\n    var ajaxModule;\n    var dataModule;\n    this.layersCollection.forEach(function (layer, layerIndex) {\n      if (layer.shapeData instanceof DataManager) {\n        _this.serverProcess['request']++;\n        dataModule = layer.shapeData;\n        queryModule = layer.query instanceof Query ? layer.query : new Query();\n        var dataManager = dataModule.executeQuery(queryModule);\n        dataManager.then(function (e) {\n          _this.processResponseJsonData('DataManager', e, layer, 'ShapeData');\n        });\n      } else if (layer.shapeData instanceof MapAjax || layer.shapeData) {\n        if (!isNullOrUndefined(layer.shapeData['dataOptions'])) {\n          _this.processAjaxRequest(layer, layer.shapeData, 'ShapeData');\n        }\n      }\n\n      if (layer.dataSource instanceof MapAjax || !isNullOrUndefined(layer.dataSource['dataOptions'])) {\n        _this.processAjaxRequest(layer, layer.dataSource, 'DataSource');\n      }\n\n      if (_this.serverProcess['request'] === _this.serverProcess['response'] && length === layerIndex) {\n        _this.processResponseJsonData(null);\n      }\n    });\n  }; // tslint:disable:no-any\n\n\n  Maps.prototype.processAjaxRequest = function (layer, localAjax, type) {\n    var _this = this;\n\n    var ajaxModule;\n    this.serverProcess['request']++;\n    ajaxModule = new Ajax(localAjax.dataOptions, localAjax.type, localAjax.async, localAjax.contentType);\n\n    ajaxModule.onSuccess = function (args) {\n      _this.processResponseJsonData('Ajax', args, layer, type);\n    };\n\n    ajaxModule.send(localAjax.sendData);\n  };\n  /* tslint:disable:no-eval */\n\n\n  Maps.prototype.processResponseJsonData = function (processType, data, layer, dataType) {\n    this.serverProcess['response']++;\n\n    if (processType) {\n      if (dataType === 'ShapeData') {\n        layer.shapeData = processType === 'DataManager' ? !isNullOrUndefined(data['result']) ? data['result'] : data['actual'] : JSON.parse(data);\n      } else {\n        layer.dataSource = processType === 'DataManager' ? !isNullOrUndefined(data['result']) ? data['result'] : data['actual'] : JSON.parse('[' + data + ']')[0];\n      }\n    }\n\n    if (!isNullOrUndefined(processType) && this.serverProcess['request'] === this.serverProcess['response']) {\n      var collection = this.layersCollection;\n      this.layersCollection = [];\n\n      for (var i = 0; i < collection.length; i++) {\n        if (collection[i].isBaseLayer) {\n          this.layersCollection.push(collection[i]);\n        }\n      }\n\n      for (var j = 0; j < collection.length; j++) {\n        if (!collection[j].isBaseLayer) {\n          this.layersCollection.push(collection[j]);\n        }\n      }\n\n      this.renderMap();\n    } else if (isNullOrUndefined(processType)) {\n      this.renderMap();\n    }\n  };\n\n  Maps.prototype.renderMap = function () {\n    if (this.legendModule && this.legendSettings.visible) {\n      this.legendModule.renderLegend();\n    }\n\n    this.createTile();\n\n    if (this.zoomSettings.enable && this.zoomModule) {\n      this.zoomModule.createZoomingToolbars();\n    }\n\n    if (!isNullOrUndefined(this.dataLabelModule)) {\n      this.dataLabelModule.dataLabelCollections = [];\n      this.dataLabelShape = [];\n    }\n\n    this.mapLayerPanel.measureLayerPanel();\n    this.element.appendChild(this.svgObject);\n\n    if (!isNullOrUndefined(document.getElementById(this.element.id + '_tile_parent'))) {\n      var svg = this.svgObject.getBoundingClientRect();\n      var element = document.getElementById(this.element.id);\n      var tileElement = document.getElementById(this.element.id + '_tile_parent');\n      var tile = tileElement.getBoundingClientRect();\n      var bottom = svg.bottom - tile.bottom - element.offsetTop;\n      var left = parseFloat(tileElement.style.left) + element.offsetLeft;\n      var top_1 = parseFloat(tileElement.style.top) + element.offsetTop;\n      top_1 = bottom <= 11 ? top_1 : top_1 * 2;\n      left = bottom <= 11 ? left : left * 2;\n      tileElement.style.top = top_1 + 'px';\n      tileElement.style.left = left + 'px';\n    }\n\n    this.arrangeTemplate();\n    var blazor = this.isBlazor ? this.blazorTemplates() : null;\n\n    if (this.annotationsModule) {\n      this.annotationsModule.renderAnnotationElements();\n    }\n\n    this.zoomingChange();\n    this.trigger(loaded, this.isBlazor ? {} : {\n      maps: this\n    });\n  };\n  /**\n   * To append blazor templates\n   */\n\n\n  Maps.prototype.blazorTemplates = function () {\n    if (this.layers[this.layers.length - 1].dataLabelSettings || this.layers[this.layers.length - 1].markerSettings) {\n      updateBlazorTemplate(this.element.id + '_LabelTemplate', 'LabelTemplate', this.layers[0].dataLabelSettings);\n\n      for (var i = 0; i < this.layers.length; i++) {\n        for (var j = 0; j < this.layers[i].markerSettings.length; j++) {\n          updateBlazorTemplate(this.element.id + '_MarkerTemplate', 'MarkerTemplate', this.layers[i].markerSettings[j]);\n        }\n      }\n    }\n  };\n  /**\n   * Render the map area border\n   */\n\n\n  Maps.prototype.renderArea = function () {\n    var width = this.mapsArea.border.width;\n    var background = this.mapsArea.background;\n\n    if (width > 0 || background || this.themeStyle.areaBackgroundColor) {\n      var rect = new RectOption(this.element.id + '_MapAreaBorder', background || this.themeStyle.areaBackgroundColor, this.mapsArea.border, 1, this.mapAreaRect);\n      this.svgObject.appendChild(this.renderer.drawRectangle(rect));\n    }\n  };\n  /**\n   * To add tab index for map element\n   */\n\n\n  Maps.prototype.addTabIndex = function () {\n    this.element.setAttribute('aria-label', this.description || 'Maps Element');\n    this.element.setAttribute('tabindex', this.tabIndex.toString());\n  }; // private setSecondaryElementPosition(): void {\n  //     if (!this.isTileMap) {\n  //         let element: HTMLDivElement = getElementByID(this.element.id + '_Secondary_Element') as HTMLDivElement;\n  //         let rect: ClientRect = this.element.getBoundingClientRect();\n  //         let svgRect: ClientRect = getElementByID(this.element.id + '_svg').getBoundingClientRect();\n  //         element.style.marginLeft = Math.max(svgRect.left - rect.left, 0) + 'px';\n  //         element.style.marginTop = Math.max(svgRect.top - rect.top, 0) + 'px';\n  //     }\n  // }\n\n\n  Maps.prototype.zoomingChange = function () {\n    var left;\n    var top;\n\n    if (getElementByID(this.element.id + '_Layer_Collections') && this.zoomModule) {\n      this.zoomModule.layerCollectionEle = getElementByID(this.element.id + '_Layer_Collections');\n    }\n\n    if (this.isTileMap && getElementByID(this.element.id + '_Tile_SVG') && getElementByID(this.element.id + '_tile_parent')) {\n      var tileRect = getElementByID(this.element.id + '_tile_parent').getBoundingClientRect();\n      var tileSvgRect = getElementByID(this.element.id + '_Tile_SVG').getBoundingClientRect();\n      left = tileRect.left - tileSvgRect.left;\n      top = tileRect.top - tileSvgRect.top;\n      getElementByID(this.element.id + '_Tile_SVG').setAttribute('transform', 'translate(' + left + ' ' + top + ')');\n      var markerTemplateElements = document.getElementsByClassName('template');\n\n      if (!isNullOrUndefined(markerTemplateElements) && markerTemplateElements.length > 0) {\n        for (var i = 0; i < markerTemplateElements.length; i++) {\n          var templateGroupEle = markerTemplateElements[i];\n          templateGroupEle.style.left = left + 'px';\n          templateGroupEle.style.top = top + 'px';\n        }\n      }\n    }\n\n    if (this.zoomSettings.zoomFactor >= 1) {\n      if (this.zoomModule && this.zoomModule.toolBarGroup && this.zoomSettings.enable) {\n        this.zoomModule.alignToolBar();\n      }\n\n      var elements = document.getElementById(this.element.id + '_Layer_Collections');\n\n      if (!isNullOrUndefined(elements) && elements.childElementCount > 0) {\n        for (var i = 0; i < elements.childNodes.length; i++) {\n          var childElement = elements.childNodes[i];\n\n          if (childElement.tagName === 'g') {\n            var layerIndex = parseFloat(childElement.id.split('_LayerIndex_')[1].split('_')[0]);\n\n            for (var j = 0; j < childElement.childNodes.length; j++) {\n              var childNode = childElement.childNodes[j];\n\n              if (!(childNode.id.indexOf('_Markers_Group') > -1) && !(childNode.id.indexOf('_bubble_Group') > -1) && !(childNode.id.indexOf('_dataLableIndex_Group') > -1)) {\n                changeBorderWidth(childNode, layerIndex, this.scale, this);\n              }\n            }\n          }\n        }\n      }\n\n      if (this.zoomModule && this.previousScale !== this.scale) {\n        this.zoomModule.applyTransform(true);\n      }\n    }\n  };\n\n  Maps.prototype.createSecondaryElement = function () {\n    if (isNullOrUndefined(document.getElementById(this.element.id + '_Secondary_Element'))) {\n      var secondaryElement = createElement('div', {\n        id: this.element.id + '_Secondary_Element',\n        styles: 'position: absolute;z-index:1;'\n      });\n      this.element.appendChild(secondaryElement);\n    }\n  };\n\n  Maps.prototype.arrangeTemplate = function () {\n    var secondaryEle = getElementByID(this.element.id + '_Secondary_Element');\n\n    if (document.getElementById(this.element.id + '_Legend_Border')) {\n      document.getElementById(this.element.id + '_Legend_Border').style.pointerEvents = 'none';\n    }\n\n    var templateElements = document.getElementsByClassName('template');\n\n    if (!isNullOrUndefined(templateElements) && templateElements.length > 0 && getElementByID(this.element.id + '_Layer_Collections')) {\n      for (var i = 0; i < templateElements.length; i++) {\n        var templateGroupEle = templateElements[i];\n\n        if (!isNullOrUndefined(templateGroupEle) && templateGroupEle.childElementCount > 0) {\n          var layerOffset = getElementByID(this.element.id + '_Layer_Collections').getBoundingClientRect();\n          var elementOffset = getElementByID(templateGroupEle.id).getBoundingClientRect();\n\n          for (var j = 0; j < templateGroupEle.childElementCount; j++) {\n            var currentTemplate = templateGroupEle.childNodes[j];\n            var templateOffset = currentTemplate.getBoundingClientRect();\n            currentTemplate.style.left = (this.isTileMap ? parseFloat(currentTemplate.style.left) : layerOffset.left < elementOffset.left ? parseFloat(currentTemplate.style.left) - Math.abs(elementOffset.left - layerOffset.left) : parseFloat(currentTemplate.style.left) + Math.abs(elementOffset.left - layerOffset.left)) - templateOffset.width / 2 + 'px';\n            currentTemplate.style.top = (this.isTileMap ? parseFloat(currentTemplate.style.top) : layerOffset.top < elementOffset.top ? parseFloat(currentTemplate.style.top) - Math.abs(elementOffset.top - layerOffset.top) : parseFloat(currentTemplate.style.top) + Math.abs(elementOffset.top - layerOffset.top)) - templateOffset.height / 2 + 'px';\n          }\n        }\n      }\n    }\n  };\n\n  Maps.prototype.createTile = function () {\n    var mainLayer = this.layersCollection[0];\n    var padding = 0;\n\n    if (mainLayer.isBaseLayer && (mainLayer.layerType === 'OSM' || mainLayer.layerType === 'Bing')) {\n      removeElement(this.element.id + '_tile_parent'); // let elementRect: ClientRect = this.element.getBoundingClientRect();\n      // let parentRect: ClientRect = this.element.parentElement.getBoundingClientRect();\n      // let left: number = Math.abs(elementRect.left - parentRect.left);\n      // let top: number = Math.abs(elementRect.top - parentRect.top);\n\n      var ele = createElement('div', {\n        id: this.element.id + '_tile_parent',\n        styles: 'position: absolute; left: ' + this.mapAreaRect.x + 'px; top: ' + (this.mapAreaRect.y + padding) + 'px; height: ' + this.mapAreaRect.height + 'px; width: ' + this.mapAreaRect.width + 'px; overflow: hidden;'\n      });\n      this.element.appendChild(ele);\n    }\n  };\n  /**\n   * To initilize the private varibales of maps.\n   */\n\n\n  Maps.prototype.initPrivateVariable = function () {\n    if (this.element.id === '') {\n      var collection = document.getElementsByClassName('e-maps').length;\n      this.element.id = 'maps_control_' + collection;\n    }\n\n    this.renderer = new SvgRenderer(this.element.id);\n    this.mapLayerPanel = new LayerPanel(this);\n  };\n\n  Maps.prototype.findBaseAndSubLayers = function () {\n    var _this = this;\n\n    var baseIndex = this.baseLayerIndex;\n    var mainLayers = [];\n    var subLayers = [];\n    this.layersCollection = [];\n    this.layers.forEach(function (layer) {\n      layer.type === 'Layer' ? mainLayers.push(layer) : subLayers.push(layer);\n    });\n\n    for (var i = 0; i < mainLayers.length; i++) {\n      var baseLayer = mainLayers[i];\n\n      if (baseLayer.visible && baseIndex === i) {\n        baseLayer.isBaseLayer = true;\n        this.isTileMap = baseLayer.layerType === 'Geometry' ? false : true;\n        this.layersCollection.push(baseLayer);\n        break;\n      } else if (i === mainLayers.length - 1) {\n        this.layersCollection.push(mainLayers[0]);\n        break;\n      }\n    }\n\n    subLayers.map(function (subLayer, subLayerIndex) {\n      if (subLayer.visible) {\n        _this.layersCollection.push(subLayer);\n      }\n    });\n  };\n  /**\n   * @private\n   * Render the map border\n   */\n\n\n  Maps.prototype.renderBorder = function () {\n    var width = this.border.width;\n    var borderElement = this.svgObject.querySelector('#' + this.element.id + '_MapBorder');\n\n    if ((width > 0 || this.background || this.themeStyle.backgroundColor) && isNullOrUndefined(borderElement)) {\n      var borderRect = new RectOption(this.element.id + '_MapBorder', this.background || this.themeStyle.backgroundColor, this.border, 1, new Rect(width / 2, width / 2, this.availableSize.width - width, this.availableSize.height - width));\n      this.svgObject.appendChild(this.renderer.drawRectangle(borderRect));\n    } else {\n      borderElement.setAttribute('fill', this.background || this.themeStyle.backgroundColor);\n    }\n  };\n  /**\n   * @private\n   * Render the title and subtitle\n   */\n\n\n  Maps.prototype.renderTitle = function (title, type, bounds, groupEle) {\n    var style = title.textStyle;\n    var height;\n    var width = Math.abs(this.margin.left + this.margin.right - this.availableSize.width);\n    style.fontFamily = this.themeStyle.fontFamily || style.fontFamily;\n    style.size = this.themeStyle.titleFontSize || style.size;\n\n    if (title.text) {\n      if (isNullOrUndefined(groupEle)) {\n        groupEle = this.renderer.createGroup({\n          id: this.element.id + '_Title_Group'\n        });\n      }\n\n      var trimmedTitle = textTrim(width, title.text, style);\n      var elementSize = measureText(trimmedTitle, style);\n      var rect = isNullOrUndefined(bounds) ? new Rect(this.margin.left, this.margin.top, this.availableSize.width, this.availableSize.height) : bounds;\n      var location_1 = findPosition(rect, title.alignment, elementSize, type);\n      var options = new TextOption(this.element.id + '_Map_' + type, location_1.x, location_1.y, 'start', trimmedTitle);\n      var titleBounds = new Rect(location_1.x, location_1.y, elementSize.width, elementSize.height);\n      var element = renderTextElement(options, style, style.color || (type === 'title' ? this.themeStyle.titleFontColor : this.themeStyle.subTitleFontColor), groupEle);\n      element.setAttribute('aria-label', this.description || title.text);\n      element.setAttribute('tabindex', (this.tabIndex + (type === 'title' ? 1 : 2)).toString());\n\n      if (type === 'title' && !title.subtitleSettings.text || type === 'subtitle') {\n        height = Math.abs(titleBounds.y + this.margin.bottom - this.availableSize.height);\n        this.mapAreaRect = new Rect(this.margin.left, titleBounds.y + 10, width, height - 10);\n      }\n\n      if (type !== 'subtitle' && title.subtitleSettings.text) {\n        this.renderTitle(title.subtitleSettings, 'subtitle', titleBounds, groupEle);\n      } else {\n        this.svgObject.appendChild(groupEle);\n      }\n    } else {\n      height = Math.abs(this.margin.top + this.margin.bottom - this.availableSize.height);\n      this.mapAreaRect = new Rect(this.margin.left, this.margin.top, width, height);\n    }\n  };\n  /**\n   * To create svg element for maps\n   */\n\n\n  Maps.prototype.createSVG = function () {\n    resetBlazorTemplate(this.element.id + '_LabelTemplate', 'LabelTemplate');\n    resetBlazorTemplate(this.element.id + '_MarkerTemplate', 'MarkerTemplate');\n    this.removeSvg();\n    createSvg(this);\n  };\n  /**\n   * To Remove the SVG\n   */\n\n\n  Maps.prototype.removeSvg = function () {\n    for (var i = 0; i < this.annotations.length; i++) {\n      resetBlazorTemplate(this.element.id + '_ContentTemplate_' + i, 'ContentTemplate');\n    }\n\n    removeElement(this.element.id + '_Secondary_Element');\n    removeElement(this.element.id + '_tile_parent');\n\n    if (document.getElementsByClassName('e-tooltip-wrap')[0]) {\n      remove(document.getElementsByClassName('e-tooltip-wrap')[0]);\n    }\n\n    if (this.svgObject) {\n      while (this.svgObject.childNodes.length > 0) {\n        this.svgObject.removeChild(this.svgObject.firstChild);\n      }\n\n      if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {\n        remove(this.svgObject);\n      }\n    }\n  };\n  /**\n   * To bind event handlers for maps.\n   */\n\n\n  Maps.prototype.wireEVents = function () {\n    //let cancelEvent: string = Browser.isPointer ? 'pointerleave' : 'mouseleave';\n    EventHandler.add(this.element, 'click', this.mapsOnClick, this); // EventHandler.add(this.element, 'contextmenu', this.mapsOnRightClick, this);\n\n    EventHandler.add(this.element, 'dblclick', this.mapsOnDoubleClick, this);\n    EventHandler.add(this.element, Browser.touchStartEvent, this.mouseDownOnMap, this);\n    EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMoveOnMap, this);\n    EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEndOnMap, this);\n    EventHandler.add(this.element, 'pointerleave mouseleave', this.mouseLeaveOnMap, this); //  EventHandler.add(this.element, cancelEvent, this.mouseLeaveOnMap, this);\n\n    window.addEventListener(Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.mapsOnResize.bind(this));\n  };\n  /**\n   * To unbind event handlers from maps.\n   */\n\n\n  Maps.prototype.unWireEVents = function () {\n    //let cancelEvent: string = Browser.isPointer ? 'pointerleave' : 'mouseleave';\n    EventHandler.remove(this.element, 'click', this.mapsOnClick); // EventHandler.remove(this.element, 'contextmenu', this.mapsOnRightClick);\n\n    EventHandler.remove(this.element, 'dblclick', this.mapsOnDoubleClick);\n    EventHandler.remove(this.element, Browser.touchStartEvent, this.mouseDownOnMap);\n    EventHandler.remove(this.element, Browser.touchMoveEvent, this.mouseMoveOnMap);\n    EventHandler.remove(this.element, Browser.touchEndEvent, this.mouseEndOnMap);\n    EventHandler.remove(this.element, 'pointerleave mouseleave', this.mouseLeaveOnMap); //EventHandler.remove(this.element, cancelEvent, this.mouseLeaveOnMap);\n\n    window.removeEventListener(Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize', this.mapsOnResize);\n  };\n\n  Maps.prototype.mouseLeaveOnMap = function (e) {\n    if (document.getElementsByClassName('highlightMapStyle').length > 0 && this.legendModule) {\n      this.legendModule.removeShapeHighlightCollection();\n      removeClass(document.getElementsByClassName('highlightMapStyle')[0]);\n    }\n  };\n  /**\n   * To handle the click event for the maps.\n   * @blazorProperty 'PerformClick'\n   */\n\n  /* tslint:disable:no-string-literal */\n\n\n  Maps.prototype.mapsOnClick = function (e) {\n    var _this = this;\n\n    var targetEle = e.target;\n    var targetId = targetEle.id;\n    var layerIndex = 0;\n    var latLongValue;\n    var latitude = null;\n    var longitude = null;\n    this.mouseClickEvent = {\n      x: e.x,\n      y: e.y\n    };\n\n    if (targetEle.id.indexOf('_ToolBar') === -1) {\n      if (targetEle.id.indexOf('_LayerIndex_') !== -1 && !this.isTileMap && this.mouseDownEvent['x'] === this.mouseClickEvent['x'] && this.mouseDownEvent['y'] === this.mouseClickEvent['y']) {\n        layerIndex = parseFloat(targetEle.id.split('_LayerIndex_')[1].split('_')[0]);\n        latLongValue = this.getGeoLocation(layerIndex, e);\n        latitude = latLongValue['latitude'];\n        longitude = latLongValue['longitude'];\n      } else if (this.isTileMap && this.mouseDownEvent['x'] === this.mouseClickEvent['x'] && this.mouseDownEvent['y'] === this.mouseClickEvent['y']) {\n        latLongValue = this.getTileGeoLocation(e);\n        latitude = latLongValue['latitude'];\n        longitude = latLongValue['longitude'];\n      }\n\n      var eventArgs_1 = {\n        cancel: false,\n        name: click,\n        target: targetId,\n        x: e.clientX,\n        y: e.clientY,\n        latitude: latitude,\n        longitude: longitude\n      };\n      this.trigger('click', eventArgs_1, function (mouseArgs) {\n        if (targetEle.id.indexOf('shapeIndex') !== -1) {\n          var layerIndex_1 = parseInt(targetEle.id.split('_LayerIndex_')[1].split('_')[0], 10);\n          triggerShapeEvent(targetId, _this.layers[layerIndex_1].selectionSettings, _this, shapeSelected);\n        }\n\n        if (targetEle.id.indexOf('shapeIndex') > -1 || targetEle.id.indexOf('Tile') > -1) {\n          if (_this.markerModule && _this.markerModule.sameMarkerData.length > 0 && (_this.zoomModule ? _this.zoomModule.flag : true)) {\n            mergeSeparateCluster(_this.markerModule.sameMarkerData, _this, getElement(_this.element.id + '_Markers_Group'));\n            _this.markerModule.sameMarkerData = [];\n          }\n        }\n\n        if (_this.markerModule) {\n          _this.markerModule.markerClick(e);\n\n          _this.markerModule.markerClusterClick(e);\n        }\n\n        if (_this.bubbleModule) {\n          _this.bubbleModule.bubbleClick(e);\n        }\n\n        if (!eventArgs_1.cancel) {\n          _this.notify(click, targetEle);\n        }\n      });\n    }\n  };\n  /**\n   *\n   */\n\n\n  Maps.prototype.mouseEndOnMap = function (e) {\n    var targetEle = e.target;\n    var targetId = targetEle.id;\n    var pageX;\n    var pageY;\n    var target;\n    var touchArg;\n    var rect = this.element.getBoundingClientRect();\n    var element = e.target;\n\n    if (e.type.indexOf('touch') !== -1) {\n      this.isTouch = true;\n      touchArg = e;\n      pageX = touchArg.changedTouches[0].pageX;\n      pageY = touchArg.changedTouches[0].pageY;\n      target = touchArg.target;\n    } else {\n      this.isTouch = e.pointerType === 'touch';\n      pageX = e.pageX;\n      pageY = e.pageY;\n      target = e.target;\n    }\n\n    if (this.isTouch) {\n      this.titleTooltip(e, pageX, pageY, true);\n    }\n\n    this.notify(Browser.touchEndEvent, e);\n    e.preventDefault();\n    return false;\n  };\n  /**\n   *\n   */\n\n\n  Maps.prototype.mouseDownOnMap = function (e) {\n    var pageX;\n    var pageY;\n    var target;\n    var touchArg;\n    this.mouseDownEvent = {\n      x: e.x,\n      y: e.y\n    };\n    var rect = this.element.getBoundingClientRect();\n    var element = e.target;\n    this.notify(Browser.touchStartEvent, e);\n  };\n  /**\n   * To handle the double click event for the maps.\n   * @blazorProperty 'PerformDoubleClick'\n   */\n\n\n  Maps.prototype.mapsOnDoubleClick = function (e) {\n    this.notify('dblclick', e);\n  };\n  /**\n   *\n   */\n\n  /* tslint:disable:no-string-literal */\n\n\n  Maps.prototype.mouseMoveOnMap = function (e) {\n    var pageX;\n    var pageY;\n    var touchArg;\n    var target;\n    var touches = null;\n    target = e.type === 'touchmove' ? e.target : target = e.target; // if (target.id.indexOf('shapeIndex') !== -1 && !this.highlightSettings.enable) {\n    //     triggerShapeEvent(target.id, this.highlightSettings, this, shapeHighlight);\n    // }\n\n    if (this.markerModule) {\n      this.markerModule.markerMove(e);\n      this.markerModule.markerClusterMouseMove(e);\n    }\n\n    if (this.bubbleModule) {\n      this.bubbleModule.bubbleMove(e);\n    }\n\n    this.onMouseMove(e);\n    this.notify(Browser.touchMoveEvent, e);\n  };\n\n  Maps.prototype.onMouseMove = function (e) {\n    var element = e.target;\n    var pageX;\n    var pageY;\n    var target;\n    var touchArg;\n\n    if (!this.isTouch) {\n      this.titleTooltip(e, e.pageX, e.pageY);\n    }\n\n    return false;\n  };\n\n  Maps.prototype.titleTooltip = function (event, x, y, isTouch) {\n    var targetId = event.target.id;\n\n    if (targetId === this.element.id + '_Map_title' && event.target.textContent.indexOf('...') > -1) {\n      showTooltip(this.titleSettings.text, this.titleSettings.textStyle.size, x, y, this.element.offsetWidth, this.element.offsetHeight, this.element.id + '_EJ2_Title_Tooltip', getElement(this.element.id + '_Secondary_Element'), isTouch);\n    } else {\n      removeElement(this.element.id + '_EJ2_Title_Tooltip');\n    }\n  };\n  /*\n   /**\n   * To handle the window resize event on maps.\n   */\n\n\n  Maps.prototype.mapsOnResize = function (e) {\n    var _this = this;\n\n    var args = {\n      name: resize,\n      previousSize: this.availableSize,\n      currentSize: new Size(0, 0),\n      maps: !this.isBlazor ? this : null\n    };\n\n    if (this.resizeTo) {\n      clearTimeout(this.resizeTo);\n    }\n\n    if (this.element.classList.contains('e-maps')) {\n      this.resizeTo = setTimeout(function () {\n        _this.unWireEVents();\n\n        _this.createSVG();\n\n        _this.refreshing = true;\n\n        _this.wireEVents();\n\n        args.currentSize = _this.availableSize;\n\n        _this.trigger(resize, args);\n\n        _this.render();\n      }, 500);\n    }\n\n    return false;\n  };\n  /**\n   * To zoom the map by specifies the center position\n   * @param centerPosition\n   * @param zoomFactor\n   */\n\n\n  Maps.prototype.zoomByPosition = function (centerPosition, zoomFactor) {\n    var factor = this.mapLayerPanel.calculateFactor(this.layersCollection[0]);\n    var position;\n    var size = this.mapAreaRect;\n\n    if (!this.isTileMap && this.zoomModule) {\n      if (!isNullOrUndefined(centerPosition)) {\n        position = convertGeoToPoint(centerPosition.latitude, centerPosition.longitude, factor, this.layersCollection[0], this);\n        var mapRect = document.getElementById(this.element.id + '_Layer_Collections').getBoundingClientRect();\n        var svgRect = this.svgObject.getBoundingClientRect();\n        var xDiff = Math.abs(mapRect.left - svgRect.left) / this.scale;\n        var yDiff = Math.abs(mapRect.top - svgRect.top) / this.scale;\n        var x = this.translatePoint.x + xDiff;\n        var y = this.translatePoint.y + yDiff;\n        this.scale = zoomFactor;\n        this.translatePoint.x = ((mapRect.left < svgRect.left ? x : 0) + size.width / 2 - position.x * zoomFactor) / zoomFactor;\n        this.translatePoint.y = ((mapRect.top < svgRect.top ? y : 0) + size.height / 2 - position.y * zoomFactor) / zoomFactor;\n        this.zoomModule.applyTransform();\n      } else {\n        position = {\n          x: size.width / 2,\n          y: size.height / 2\n        };\n        this.zoomModule.performZooming(position, zoomFactor, zoomFactor > this.scale ? 'ZoomIn' : 'ZoomOut');\n      }\n    } else if (this.zoomModule) {\n      this.tileZoomLevel = zoomFactor;\n      this.tileTranslatePoint = this.mapLayerPanel['panTileMap'](this.availableSize.width, this.availableSize.height, {\n        x: centerPosition.longitude,\n        y: centerPosition.latitude\n      });\n      this.mapLayerPanel.generateTiles(zoomFactor, this.tileTranslatePoint, new BingMap(this));\n    }\n  };\n  /**\n   * To pan the map by specifies the direction\n   * @param direction\n   */\n\n\n  Maps.prototype.panByDirection = function (direction) {\n    var xDiff = 0;\n    var yDiff = 0;\n\n    switch (direction) {\n      case 'Left':\n        xDiff = -(this.mapAreaRect.width / 7);\n        break;\n\n      case 'Right':\n        xDiff = this.mapAreaRect.width / 7;\n        break;\n\n      case 'Top':\n        yDiff = -(this.mapAreaRect.height / 7);\n        break;\n\n      case 'Bottom':\n        yDiff = this.mapAreaRect.height / 7;\n        break;\n    }\n\n    if (this.zoomModule) {\n      this.zoomModule.panning(direction, xDiff, yDiff);\n    }\n  };\n  /**\n   * To add layer\n   * @param layer\n   */\n\n\n  Maps.prototype.addLayer = function (layer) {\n    this.layers.push(new LayerSettings(this.layers[0], 'layers', layer));\n    this.refresh();\n  };\n  /**\n   * To remove layer\n   * @param index\n   */\n\n\n  Maps.prototype.removeLayer = function (index) {\n    this.layers.splice(index, 1);\n    this.refresh();\n  };\n  /**\n   * To add marker\n   * @param layerIndex\n   * @param marker\n   */\n\n\n  Maps.prototype.addMarker = function (layerIndex, markerCollection) {\n    var layerEle = document.getElementById(this.element.id + '_LayerIndex_' + layerIndex);\n\n    if (markerCollection.length > 0 && layerEle) {\n      for (var _i = 0, markerCollection_1 = markerCollection; _i < markerCollection_1.length; _i++) {\n        var newMarker = markerCollection_1[_i];\n        this.layersCollection[layerIndex].markerSettings.push(new MarkerSettings(this, 'markerSettings', newMarker));\n      }\n\n      var markerModule = new Marker(this);\n      markerModule.markerRender(layerEle, layerIndex, this.mapLayerPanel['currentFactor'], 'AddMarker');\n      this.arrangeTemplate();\n    }\n  };\n  /**\n   * Method to set culture for maps\n   */\n\n\n  Maps.prototype.setCulture = function () {\n    this.intl = new Internationalization();\n    this.setLocaleConstants();\n    this.localeObject = new L10n(this.getModuleName(), this.defaultLocalConstants, this.locale);\n  };\n  /**\n   * Method to set locale constants\n   */\n\n\n  Maps.prototype.setLocaleConstants = function () {\n    // Need to modify after the api confirm\n    this.defaultLocalConstants = {\n      ZoomIn: 'Zoom In',\n      Zoom: 'Zoom',\n      ZoomOut: 'Zoom Out',\n      Pan: 'Pan',\n      Reset: 'Reset'\n    };\n  };\n  /**\n   * To destroy maps control.\n   */\n\n\n  Maps.prototype.destroy = function () {\n    this.unWireEVents();\n\n    _super.prototype.destroy.call(this);\n  };\n  /**\n   * Get component name\n   */\n\n\n  Maps.prototype.getModuleName = function () {\n    return 'maps';\n  };\n  /**\n   * Get the properties to be maintained in the persisted state.\n   * @private\n   */\n\n\n  Maps.prototype.getPersistData = function () {\n    return '';\n  };\n  /**\n   * Called internally if any of the property value changed.\n   * @private\n   */\n\n\n  Maps.prototype.onPropertyChanged = function (newProp, oldProp) {\n    var render = false;\n    var newLayerLength = Object.keys(newProp).length;\n    var layerEle = document.getElementById(this.element.id + '_LayerIndex_' + (newLayerLength - 1));\n\n    for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n      var prop = _a[_i];\n\n      switch (prop) {\n        case 'background':\n          this.renderBorder();\n          break;\n\n        case 'height':\n        case 'width':\n        case 'layers':\n        case 'projectionType':\n        case 'legendSettings':\n        case 'zoomSettings':\n          render = true;\n          break;\n      }\n    }\n\n    if (render) {\n      if (newProp.layers && newProp.layers[newLayerLength - 1].markerSettings) {\n        removeElement(this.element.id + '_Markers_Group');\n        this.markerModule.markerRender(layerEle, newLayerLength - 1, this.mapLayerPanel['currentFactor'], 'AddMarker');\n      } else {\n        this.createSVG();\n        this.render();\n      }\n    }\n  };\n  /**\n   * To provide the array of modules needed for maps rendering\n   * @return {ModuleDeclaration[]}\n   * @private\n   */\n\n\n  Maps.prototype.requiredModules = function () {\n    var modules = [];\n    var isVisible = this.findVisibleLayers(this.layers);\n    var annotationEnable = false;\n    this.annotations.map(function (annotation, index) {\n      annotationEnable = annotation.content != null;\n    });\n\n    if (this.isBubbleVisible()) {\n      modules.push({\n        member: 'Bubble',\n        args: [this]\n      });\n    }\n\n    if (isVisible.highlight) {\n      modules.push({\n        member: 'Highlight',\n        args: [this]\n      });\n    }\n\n    if (isVisible.selection) {\n      modules.push({\n        member: 'Selection',\n        args: [this]\n      });\n    }\n\n    if (this.legendSettings.visible) {\n      modules.push({\n        member: 'Legend',\n        args: [this]\n      });\n    }\n\n    if (this.zoomSettings.enable || this.zoomSettings.zoomFactor > this.zoomSettings.minZoom) {\n      modules.push({\n        member: 'Zoom',\n        args: [this]\n      });\n    }\n\n    if (this.isMarkersVisible()) {\n      modules.push({\n        member: 'Marker',\n        args: [this]\n      });\n    }\n\n    if (this.isDataLabelVisible()) {\n      modules.push({\n        member: 'DataLabel',\n        args: [this]\n      });\n    }\n\n    if (this.isNavigationVisible()) {\n      modules.push({\n        member: 'NavigationLine',\n        args: [this]\n      });\n    }\n\n    if (isVisible.tooltip) {\n      modules.push({\n        member: 'MapsTooltip',\n        args: [this]\n      });\n    }\n\n    if (annotationEnable) {\n      modules.push({\n        member: 'Annotations',\n        args: [this, Annotations]\n      });\n    }\n\n    return modules;\n  };\n  /**\n   * To find marker visibility\n   */\n\n\n  Maps.prototype.isMarkersVisible = function () {\n    var isVisible = false;\n    this.layers.forEach(function (layer, layerIndex) {\n      for (var i = 0; i < layer.markerSettings.length; i++) {\n        if (layer.markerSettings[i].visible) {\n          isVisible = true;\n          break;\n        }\n      }\n    });\n    return isVisible;\n  };\n  /**\n   * To find DataLabel visibility\n   */\n\n\n  Maps.prototype.isDataLabelVisible = function () {\n    var isVisible = false;\n\n    for (var i = 0; i < this.layers.length; i++) {\n      if (this.layers[i].dataLabelSettings.visible) {\n        isVisible = true;\n        break;\n      }\n    }\n\n    return isVisible;\n  };\n  /**\n   * To find navigation line visibility\n   */\n\n\n  Maps.prototype.isNavigationVisible = function () {\n    var isVisible = false;\n    this.layers.forEach(function (layer, layerIndex) {\n      for (var i = 0; i < layer.navigationLineSettings.length; i++) {\n        if (layer.navigationLineSettings[i].visible) {\n          isVisible = true;\n          break;\n        }\n      }\n    });\n    return isVisible;\n  };\n  /**\n   * To find marker visibility\n   */\n\n\n  Maps.prototype.isBubbleVisible = function () {\n    var isVisible = false;\n\n    for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {\n      var layer = _a[_i];\n\n      if (this.getBubbleVisible(layer)) {\n        isVisible = true;\n        break;\n      }\n    }\n\n    return isVisible;\n  };\n  /**\n   * To find the bubble visibility from layer\n   * @private\n   */\n\n\n  Maps.prototype.getBubbleVisible = function (layer) {\n    var isVisible = false;\n\n    for (var _i = 0, _a = layer.bubbleSettings; _i < _a.length; _i++) {\n      var bubble = _a[_i];\n\n      if (bubble.visible) {\n        isVisible = true;\n        break;\n      }\n    }\n\n    return isVisible;\n  };\n  /**\n   * Handles the print method for chart control.\n   */\n\n\n  Maps.prototype.print = function (id) {\n    var exportChart = new ExportUtils(this);\n    exportChart.print(id);\n  };\n  /**\n   * Handles the export method for chart control.\n   * @param type\n   * @param fileName\n   */\n\n\n  Maps.prototype.export = function (type, fileName, orientation) {\n    var exportMap = new ExportUtils(this);\n    exportMap.export(type, fileName, orientation);\n  };\n  /**\n   * To find visibility of layers and markers for required modules load.\n   */\n\n\n  Maps.prototype.findVisibleLayers = function (layers, isLayerVisible, isBubblevisible, istooltipVisible, isSelection, isHighlight) {\n    if (isLayerVisible === void 0) {\n      isLayerVisible = false;\n    }\n\n    if (isBubblevisible === void 0) {\n      isBubblevisible = false;\n    }\n\n    if (istooltipVisible === void 0) {\n      istooltipVisible = false;\n    }\n\n    if (isSelection === void 0) {\n      isSelection = false;\n    }\n\n    if (isHighlight === void 0) {\n      isHighlight = false;\n    }\n\n    var bubbles;\n    var markers;\n    var navigationLine;\n\n    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {\n      var layer = layers_1[_i];\n      isLayerVisible = layer.visible || isLayerVisible;\n\n      if (layer.visible) {\n        bubbles = layer.bubbleSettings;\n        markers = layer.markerSettings;\n        navigationLine = layer.navigationLineSettings;\n\n        for (var _a = 0, navigationLine_1 = navigationLine; _a < navigationLine_1.length; _a++) {\n          var navigation = navigationLine_1[_a];\n\n          if (navigation.visible) {\n            isSelection = navigation.highlightSettings.enable || isSelection;\n            isHighlight = navigation.selectionSettings.enable || isHighlight;\n          }\n        }\n\n        for (var _b = 0, markers_1 = markers; _b < markers_1.length; _b++) {\n          var marker = markers_1[_b];\n\n          if (marker.visible) {\n            istooltipVisible = marker.tooltipSettings.visible || istooltipVisible;\n            isSelection = marker.selectionSettings.enable || isSelection;\n            isHighlight = marker.highlightSettings.enable || isHighlight;\n          }\n\n          if (istooltipVisible) {\n            break;\n          }\n        }\n\n        for (var _c = 0, bubbles_1 = bubbles; _c < bubbles_1.length; _c++) {\n          var bubble = bubbles_1[_c];\n\n          if (bubble.visible) {\n            istooltipVisible = bubble.tooltipSettings.visible || istooltipVisible;\n            isSelection = bubble.selectionSettings.enable || isSelection;\n            isHighlight = bubble.highlightSettings.enable || isHighlight;\n          }\n\n          if (istooltipVisible) {\n            break;\n          }\n        }\n\n        istooltipVisible = layer.tooltipSettings.visible || istooltipVisible;\n        isSelection = layer.selectionSettings.enable || isSelection;\n        isHighlight = layer.highlightSettings.enable || isHighlight;\n      }\n\n      if (isLayerVisible && isBubblevisible && istooltipVisible) {\n        break;\n      }\n    }\n\n    return {\n      layer: isLayerVisible,\n      bubble: isBubblevisible,\n      tooltip: istooltipVisible,\n      selection: isSelection,\n      highlight: isHighlight\n    };\n  };\n  /**\n   * To get the geo location\n   * @param {number} layerIndex\n   * @param {PointerEvent} location\n   * @return GeoPosition\n   */\n\n\n  Maps.prototype.getGeoLocation = function (layerIndex, location) {\n    var container = document.getElementById(this.element.id);\n    var pageX = location.layerX - container.offsetLeft;\n    var pageY = location.layerY - container.offsetTop;\n    var currentLayer = this.layersCollection[layerIndex];\n    var translate = getTranslate(this, currentLayer, false);\n    var translatePoint = translate['location'];\n    var translatePointX = translatePoint.x * this.scale;\n    var translatePointY = translatePoint.y * this.scale;\n    var mapSize = Math.min(this.mapAreaRect.height, this.mapAreaRect.width) * this.mapLayerPanel['currentFactor'] * this.scale;\n    var xx = this.clip(pageX - translatePointX, 0, mapSize - 1) / mapSize - 0.5;\n    var yy = 0.5 - this.clip(pageY - translatePointY, 0, mapSize - 1) / mapSize;\n    var lat = 90 - 360 * Math.atan(Math.exp(-yy * 2 * Math.PI)) / Math.PI;\n    var long = 360 * xx;\n    return {\n      latitude: lat,\n      longitude: long\n    };\n  };\n\n  Maps.prototype.clip = function (value, minVal, maxVal) {\n    return Math.min(Math.max(value, minVal), maxVal);\n  };\n  /**\n   * To get the geo location\n   * @param {PointerEvent}\n   * @return GeoPosition\n   */\n\n\n  Maps.prototype.getTileGeoLocation = function (location) {\n    var container = document.getElementById(this.element.id);\n    var latLong;\n    var ele = document.getElementById(this.element.id + '_tile_parent');\n    var lastTile = this.mapLayerPanel.tiles[this.mapLayerPanel.tiles.length - 1];\n    var tile0 = this.mapLayerPanel.tiles[0];\n    latLong = this.pointToLatLong(location.layerX - (ele.offsetLeft - container.offsetLeft), location.layerY - (ele.offsetTop - container.offsetTop));\n    return {\n      latitude: latLong['latitude'],\n      longitude: latLong['longitude']\n    };\n  };\n\n  Maps.prototype.pointToLatLong = function (pageX, pageY) {\n    pageY = this.zoomSettings.enable ? pageY + 10 : pageY;\n    var mapSize = 256 * Math.pow(2, this.tileZoomLevel);\n    var x1 = this.clip(pageX - this.translatePoint.x * this.scale, 0, mapSize - 1) / mapSize - 0.5;\n    var y1 = 0.5 - this.clip(pageY - this.translatePoint.y * this.scale, 0, mapSize - 1) / mapSize;\n    var lat = 90 - 360 * Math.atan(Math.exp(-y1 * 2 * Math.PI)) / Math.PI;\n    var long = 360 * x1;\n    return {\n      latitude: lat,\n      longitude: long\n    };\n  };\n\n  __decorate([Property(null)], Maps.prototype, \"background\", void 0);\n\n  __decorate([Property(false)], Maps.prototype, \"useGroupingSeparator\", void 0);\n\n  __decorate([Property(null)], Maps.prototype, \"format\", void 0);\n\n  __decorate([Property(null)], Maps.prototype, \"width\", void 0);\n\n  __decorate([Property(null)], Maps.prototype, \"height\", void 0);\n\n  __decorate([Property('MouseMove')], Maps.prototype, \"tooltipDisplayMode\", void 0);\n\n  __decorate([Complex({}, TitleSettings)], Maps.prototype, \"titleSettings\", void 0);\n\n  __decorate([Complex({}, ZoomSettings)], Maps.prototype, \"zoomSettings\", void 0);\n\n  __decorate([Complex({}, LegendSettings)], Maps.prototype, \"legendSettings\", void 0);\n\n  __decorate([Collection([], LayerSettings)], Maps.prototype, \"layers\", void 0);\n\n  __decorate([Collection([], Annotation)], Maps.prototype, \"annotations\", void 0);\n\n  __decorate([Complex({}, Margin)], Maps.prototype, \"margin\", void 0);\n\n  __decorate([Complex({\n    color: '#DDDDDD',\n    width: 0\n  }, Border)], Maps.prototype, \"border\", void 0);\n\n  __decorate([Property('Material')], Maps.prototype, \"theme\", void 0);\n\n  __decorate([Property('Mercator')], Maps.prototype, \"projectionType\", void 0);\n\n  __decorate([Property(0)], Maps.prototype, \"baseLayerIndex\", void 0);\n\n  __decorate([Property(null)], Maps.prototype, \"description\", void 0);\n\n  __decorate([Property(1)], Maps.prototype, \"tabIndex\", void 0);\n\n  __decorate([Complex({\n    latitude: null,\n    longitude: null\n  }, CenterPosition)], Maps.prototype, \"centerPosition\", void 0);\n\n  __decorate([Complex({}, MapsAreaSettings)], Maps.prototype, \"mapsArea\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"load\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"beforePrint\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"loaded\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"click\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"doubleClick\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"rightClick\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"resize\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"tooltipRender\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"tooltipRenderComplete\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"shapeSelected\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"itemSelection\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"itemHighlight\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"shapeHighlight\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"layerRendering\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"shapeRendering\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"markerRendering\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"markerClusterRendering\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"markerClick\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"markerClusterClick\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"markerClusterMouseMove\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"markerMouseMove\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"dataLabelRendering\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"bubbleRendering\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"bubbleClick\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"bubbleMouseMove\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"animationComplete\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"annotationRendering\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"zoom\", void 0);\n\n  __decorate([Event()], Maps.prototype, \"pan\", void 0);\n\n  Maps = __decorate([NotifyPropertyChanges], Maps);\n  return Maps;\n}(Component);\n\nexport { Maps };","map":null,"metadata":{},"sourceType":"module"}