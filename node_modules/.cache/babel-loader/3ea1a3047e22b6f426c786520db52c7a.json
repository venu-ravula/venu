{"ast":null,"code":"import { click, legendRendering } from '../index';\nimport { Rect, measureText, PathOption, textTrim, removeClass, querySelector, getTemplateFunction } from '../utils/helper';\nimport { RectOption, Size, TextOption, Point, renderTextElement, drawSymbol, checkPropertyPath } from '../utils/helper';\nimport { isNullOrUndefined, Browser, EventHandler, remove, extend } from '@syncfusion/ej2-base';\n/**\n * Legend module is used to render legend for the maps\n */\n\nvar Legend =\n/** @class */\nfunction () {\n  function Legend(maps) {\n    this.legendBorderRect = new Rect(0, 0, 0, 0);\n    this.totalPages = [];\n    this.page = 0;\n    this.currentPage = 0;\n    this.legendItemRect = new Rect(0, 0, 0, 0);\n    this.heightIncrement = 0;\n    this.widthIncrement = 0;\n    this.textMaxWidth = 0;\n    this.shapeHighlightCollection = [];\n    this.shapeSelectionCollection = [];\n    this.legendHighlightCollection = [];\n    this.legendSelectionCollection = [];\n    this.legendElement = null;\n    this.shapeElement = null;\n    this.shapeSelection = true;\n    this.legendSelection = true;\n    this.maps = maps;\n    this.addEventListener();\n  }\n  /**\n   * To calculate legend bounds and draw the legend shape and text.\n   */\n\n\n  Legend.prototype.renderLegend = function () {\n    this.legendRenderingCollections = [];\n    this.legendCollection = [];\n    this.totalPages = [];\n    this.widthIncrement = 0;\n    this.heightIncrement = 0;\n    this.defsElement = this.maps.renderer.createDefs();\n    this.maps.svgObject.appendChild(this.defsElement);\n    this.calculateLegendBounds();\n    this.drawLegend();\n  };\n  /* tslint:disable-next-line:max-func-body-length */\n\n\n  Legend.prototype.calculateLegendBounds = function () {\n    var _this = this;\n\n    var map = this.maps;\n    var legend = map.legendSettings;\n    this.legendCollection = [];\n    var spacing = 10;\n    var leftPadding = 10;\n    var topPadding = map.mapAreaRect.y;\n    this.legendRenderingCollections = [];\n    map.layersCollection.forEach(function (layer, layerIndex) {\n      if (!isNullOrUndefined(layer.shapeData)) {\n        var layerData = layer.shapeData['features'];\n        var dataPath = layer.shapeDataPath;\n        var propertyPath = layer.shapePropertyPath;\n        var dataSource = layer.dataSource;\n        var colorValuePath = void 0;\n        var colorMapping = void 0;\n\n        if (legend.type === 'Layers' && layer.visible) {\n          colorValuePath = layer.shapeSettings.colorValuePath;\n          colorMapping = layer.shapeSettings.colorMapping;\n\n          _this.getLegends(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);\n        } else if (legend.type === 'Bubbles') {\n          for (var _i = 0, _a = layer.bubbleSettings; _i < _a.length; _i++) {\n            var bubble = _a[_i];\n\n            if (bubble.visible) {\n              colorValuePath = bubble.colorValuePath;\n              colorMapping = bubble.colorMapping;\n              dataSource = bubble.dataSource;\n\n              _this.getLegends(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);\n            }\n          }\n        } else {\n          _this.getMarkersLegendCollections(layerIndex, layer.markerSettings);\n        }\n      }\n    });\n    var defaultSize = 25;\n    var legendTitle = map.legendSettings.title.text;\n    var titleTextStyle = map.legendSettings.titleStyle;\n\n    if (this.legendCollection.length > 0) {\n      var legendMode = legend.mode;\n      var shapeX = 0;\n      var shapeY = 0;\n      var textX = 0;\n      var textY = 0;\n      var shapePadding = legend.shapePadding;\n      var textPadding = 10;\n      var shapeHeight = legend.shapeHeight;\n      var shapeWidth = legend.shapeWidth;\n      var shapeLocation = [];\n      var textLocation = [];\n      var legendRectCollection = [];\n      var location_1;\n      var position = legend.position;\n      var labelAction = legend.labelDisplayMode;\n      var arrangement = legend.orientation === 'None' ? position === 'Top' || position === 'Bottom' ? 'Horizontal' : 'Vertical' : legend.orientation;\n      var legendWidth = legend.width.length > 1 ? legend.width.indexOf('%') > -1 ? map.availableSize.width / 100 * parseInt(legend.width, 10) : parseInt(legend.width, 10) : null;\n      var legendHeight = legend.height.length > 1 ? legend.height.indexOf('%') > -1 ? map.availableSize.height / 100 * parseInt(legend.height, 10) : parseInt(legend.height, 10) : null;\n      var legendItemStartX_1;\n      var legendItemStartY_1;\n      var startX = 0;\n      var startY = 0;\n      var legendtitleSize = measureText(legendTitle, titleTextStyle);\n\n      if (legendMode === 'Interactive') {\n        var itemTextStyle = legend.textStyle;\n        var rectWidth = void 0;\n        var rectHeight = void 0;\n        var legendLength = this.legendCollection.length;\n        rectWidth = arrangement === 'Horizontal' ? isNullOrUndefined(legendWidth) ? map.mapAreaRect.width / legendLength : legendWidth / legendLength : isNullOrUndefined(legendWidth) ? defaultSize : legendWidth;\n        rectHeight = arrangement === 'Horizontal' ? isNullOrUndefined(legendHeight) ? defaultSize : legendHeight : isNullOrUndefined(legendHeight) ? map.mapAreaRect.height / legendLength : legendHeight / legendLength;\n        startX = 0;\n        startY = legendtitleSize.height + spacing;\n        var position_1 = legend.labelPosition;\n        var textX_1 = 0;\n        var textY_1 = 0;\n        var textPadding_1 = 10;\n        var itemStartX = 0;\n        var itemStartY = 0;\n        var maxTextHeight = 0;\n        var maxTextWidth = 0;\n\n        for (var i = 0; i < this.legendCollection.length; i++) {\n          startX = arrangement === 'Horizontal' ? startX + rectWidth : startX;\n          startY = arrangement === 'Horizontal' ? startY : startY + rectHeight;\n          var legendText = this.legendCollection[i]['text'];\n          var itemTextSize = new Size(0, 0);\n\n          if (labelAction === 'None') {\n            itemTextSize = measureText(legendText, itemTextStyle);\n          } else if (labelAction === 'Trim') {\n            legendText = textTrim(arrangement === 'Horizontal' ? rectWidth : rectHeight, legendText, itemTextStyle);\n            itemTextSize = measureText(legendText, itemTextStyle);\n          } else {\n            legendText = '';\n          }\n\n          maxTextHeight = Math.max(maxTextHeight, itemTextSize.height);\n          maxTextWidth = Math.max(maxTextWidth, itemTextSize.width);\n\n          if (itemTextSize.width > 0 && itemTextSize.height > 0) {\n            if (arrangement === 'Horizontal') {\n              textX_1 = startX + rectWidth / 2;\n              textY_1 = position_1 === 'After' ? startY + rectHeight + itemTextSize.height / 2 + textPadding_1 : startY - textPadding_1;\n            } else {\n              textX_1 = position_1 === 'After' ? startX - itemTextSize.width / 2 - textPadding_1 : startX + rectWidth + itemTextSize.width / 2 + textPadding_1;\n              textY_1 = startY + rectHeight / 2 + itemTextSize.height / 4;\n            }\n          }\n\n          if (i === 0) {\n            itemStartX = arrangement === 'Horizontal' ? startX : position_1 === 'After' ? textX_1 - itemTextSize.width / 2 : startX;\n            itemStartY = arrangement === 'Horizontal' ? position_1 === 'After' ? startY : textY_1 - itemTextSize.height / 2 : startY;\n          } else if (i === this.legendCollection.length - 1) {\n            legendWidth = arrangement === 'Horizontal' ? Math.abs(startX + rectWidth - itemStartX) : rectWidth + maxTextWidth + textPadding_1;\n            legendHeight = arrangement === 'Horizontal' ? rectHeight + maxTextHeight / 2 + textPadding_1 : Math.abs(startY + rectHeight - itemStartY);\n          }\n\n          this.legendRenderingCollections.push({\n            fill: this.legendCollection[i]['fill'],\n            x: startX,\n            y: startY,\n            width: rectWidth,\n            height: rectHeight,\n            text: legendText,\n            textX: textX_1,\n            textY: textY_1,\n            textWidth: itemTextSize.width,\n            textHeight: itemTextSize.height\n          });\n        }\n\n        if (this.legendCollection.length === 1) {\n          legendHeight = rectHeight;\n          legendWidth = rectWidth;\n        }\n\n        this.legendItemRect = {\n          x: itemStartX,\n          y: itemStartY,\n          width: legendWidth,\n          height: legendHeight\n        };\n      } else {\n        legendWidth = isNullOrUndefined(legendWidth) ? map.mapAreaRect.width : legendWidth;\n        legendHeight = isNullOrUndefined(legendHeight) ? map.mapAreaRect.height : legendHeight;\n        var j = 0;\n        this.page = 0;\n\n        for (var i = 0; i < this.legendCollection.length; i++) {\n          var legendItem = this.legendCollection[i];\n\n          if (isNullOrUndefined(this.totalPages[this.page])) {\n            this.totalPages[this.page] = {\n              Page: this.page + 1,\n              Collection: []\n            };\n          }\n\n          var legendTextSize = measureText(legendItem['text'], legend.textStyle);\n          this.textMaxWidth = Math.max(this.textMaxWidth, legendTextSize.width);\n\n          if (i === 0) {\n            startX = shapeX = leftPadding + shapeWidth / 2;\n            startY = shapeY = topPadding + legendtitleSize.height + (shapeHeight > legendTextSize.height ? shapeHeight / 2 : legendTextSize.height / 4);\n          } else {\n            var maxSize = legendTextSize.height > shapeHeight ? legendTextSize.height : shapeHeight;\n\n            if (arrangement === 'Horizontal') {\n              var prvePositionX = textLocation[j - 1].x + textLocation[j - 1].width + textPadding + shapeWidth;\n\n              if (prvePositionX + shapePadding + legendTextSize.width > legendWidth) {\n                var nextPositionY = (textLocation[j - 1].y > shapeLocation[j - 1].y + shapeHeight / 2 ? textLocation[j - 1].y : shapeLocation[j - 1].y + shapeHeight / 2) + topPadding;\n\n                if (nextPositionY + maxSize > legendHeight) {\n                  this.getPageChanged();\n                  j = 0;\n                  shapeLocation = [];\n                  textLocation = [];\n                  legendRectCollection = [];\n                  shapeX = startX;\n                  shapeY = startY;\n                } else {\n                  shapeX = shapeLocation[0].x;\n                  shapeY = nextPositionY + maxSize / 2;\n                }\n              } else {\n                shapeX = prvePositionX - shapeWidth / 2;\n                shapeY = shapeLocation[j - 1].y;\n              }\n            } else {\n              var prevPositionY = textLocation[j - 1].y > shapeLocation[j - 1].y + shapeHeight / 2 ? textLocation[j - 1].y : shapeLocation[j - 1].y + shapeHeight / 2;\n\n              if (prevPositionY + topPadding + maxSize > legendHeight) {\n                var nextPositionX = textLocation[j - 1].x + this.textMaxWidth + textPadding;\n\n                if (nextPositionX + shapePadding + legendTextSize.width > legendWidth) {\n                  shapeX = startX;\n                  shapeY = startY;\n                  legendRectCollection = [];\n                  textLocation = [];\n                  shapeLocation = [];\n                  this.getPageChanged();\n                  j = 0;\n                } else {\n                  shapeX = nextPositionX + shapeWidth / 2;\n                  shapeY = shapeLocation[0].y;\n                }\n              } else {\n                shapeX = shapeLocation[j - 1].x;\n                shapeY = prevPositionY + topPadding + shapeHeight / 2;\n              }\n            }\n          }\n\n          textX = shapeX + shapeWidth / 2 + shapePadding;\n          textY = shapeY + legendTextSize.height / 4;\n          shapeLocation.push({\n            x: shapeX,\n            y: shapeY\n          });\n          textLocation.push({\n            x: textX,\n            y: textY,\n            width: legendTextSize.width,\n            height: legendTextSize.height / 2\n          });\n          this.totalPages[this.page]['Collection'].push({\n            DisplayText: legendItem['text'],\n            ImageSrc: legendItem['imageSrc'],\n            Shape: {\n              x: shapeX,\n              y: shapeY\n            },\n            Text: {\n              x: textX,\n              y: textY\n            },\n            Fill: legendItem['fill'],\n            Rect: {\n              x: shapeLocation[j].x - shapeWidth / 2,\n              y: shapeLocation[j].y - shapeHeight / 2 < textY - legendTextSize.height ? shapeLocation[j].y - shapeHeight / 2 : textY - legendTextSize.height,\n              width: Math.abs(shapeLocation[j].x - shapeWidth / 2 - (textX + legendTextSize.width)),\n              height: shapeHeight > legendTextSize.height ? shapeHeight : legendTextSize.height\n            }\n          });\n          j++;\n        }\n\n        var collection = this.totalPages[0]['Collection'];\n        collection.forEach(function (legendObj, index) {\n          var legendRect = new Rect(legendObj['Rect']['x'], legendObj['Rect']['y'], legendObj['Rect']['width'], legendObj['Rect']['height']);\n\n          if (index === 0) {\n            legendItemStartX_1 = legendRect.x;\n            legendItemStartY_1 = legendRect.y;\n          }\n\n          _this.widthIncrement = Math.max(_this.widthIncrement, Math.abs(legendItemStartX_1 - (legendRect.x + legendRect.width)));\n          _this.heightIncrement = Math.max(_this.heightIncrement, Math.abs(legendItemStartY_1 - (legendRect.y + legendRect.height)));\n        });\n        legendWidth = this.widthIncrement < legendWidth ? this.widthIncrement : legendWidth;\n        legendHeight = this.heightIncrement < legendHeight ? this.heightIncrement : legendHeight;\n        this.legendItemRect = {\n          x: collection[0]['Rect']['x'],\n          y: collection[0]['Rect']['y'],\n          width: legendWidth,\n          height: legendHeight\n        };\n      }\n    }\n  };\n  /**\n   *\n   */\n\n\n  Legend.prototype.getLegends = function (layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath) {\n    this.getRangeLegendCollection(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);\n    this.getEqualLegendCollection(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);\n    this.getDataLegendCollection(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);\n  };\n\n  Legend.prototype.getPageChanged = function () {\n    this.page++;\n\n    if (isNullOrUndefined(this.totalPages[this.page])) {\n      this.totalPages[this.page] = {\n        Page: this.page + 1,\n        Collection: []\n      };\n    }\n  };\n  /**\n   * To draw the legend shape and text.\n   */\n\n\n  Legend.prototype.drawLegend = function () {\n    var _this = this;\n\n    var map = this.maps;\n    var legend = map.legendSettings;\n    var render = map.renderer;\n    var textOptions;\n    var textFont = legend.textStyle;\n    this.legendGroup = render.createGroup({\n      id: map.element.id + '_Legend_Group'\n    });\n    var eventArgs = {\n      name: legendRendering,\n      cancel: false,\n      fill: '',\n      shape: legend.shape,\n      shapeBorder: legend.shapeBorder\n    };\n\n    if (legend.mode === 'Interactive') {\n      var _loop_1 = function (i) {\n        var itemId = map.element.id + '_Legend_Index_' + i;\n        var textId = map.element.id + '_Legend_Index_' + i + '_Text';\n        var item = this_1.legendRenderingCollections[i];\n        var bounds = new Rect(item['x'], item['y'], item['width'], item['height']);\n        var textLocation = new Point(item['textX'], item['textY']);\n        eventArgs.fill = item['fill'];\n        map.trigger(legendRendering, eventArgs, function () {\n          textFont.color = textFont.color !== null ? textFont.color : _this.maps.themeStyle.legendTextColor;\n          var rectOptions = new RectOption(itemId, eventArgs.fill, eventArgs.shapeBorder, legend.opacity, bounds);\n          textOptions = new TextOption(textId, textLocation.x, textLocation.y, 'middle', item['text'], '', '');\n          textFont.fontFamily = map.themeStyle.fontFamily || textFont.fontFamily;\n          textFont.size = map.themeStyle.legendFontSize || textFont.size;\n          renderTextElement(textOptions, textFont, textFont.color, _this.legendGroup);\n\n          _this.legendGroup.appendChild(render.drawRectangle(rectOptions));\n\n          if (i === _this.legendRenderingCollections.length - 1) {\n            _this.renderLegendBorder();\n          }\n        });\n      };\n\n      var this_1 = this;\n\n      for (var i = 0; i < this.legendRenderingCollections.length; i++) {\n        _loop_1(i);\n      }\n    } else {\n      this.drawLegendItem(this.currentPage);\n    }\n  }; // tslint:disable-next-line:max-func-body-length\n\n\n  Legend.prototype.drawLegendItem = function (page) {\n    var _this = this;\n\n    var map = this.maps;\n    var legend = map.legendSettings;\n    var spacing = 10;\n    var shapeSize = new Size(legend.shapeWidth, legend.shapeHeight);\n    var textOptions;\n    var renderOptions;\n    var render = map.renderer;\n    var shapeBorder = legend.shapeBorder;\n    var eventArgs = {\n      name: legendRendering,\n      cancel: false,\n      fill: '',\n      shape: legend.shape\n    };\n\n    if (page >= 0 && page < this.totalPages.length) {\n      if (querySelector(this.legendGroup.id, this.maps.element.id)) {\n        remove(querySelector(this.legendGroup.id, this.maps.element.id));\n      }\n\n      var strokeColor = legend.shape === 'HorizontalLine' || legend.shape === 'VerticalLine' || legend.shape === 'Cross' ? isNullOrUndefined(legend.fill) ? '#000000' : legend.fill : shapeBorder.color;\n      var strokeWidth = legend.shape === 'HorizontalLine' || legend.shape === 'VerticalLine' || legend.shape === 'Cross' ? shapeBorder.width === 0 ? 1 : shapeBorder.width : shapeBorder.width;\n      eventArgs.shapeBorder = {\n        width: strokeWidth,\n        color: strokeColor\n      };\n\n      var _loop_2 = function (i) {\n        var collection = this_2.totalPages[page]['Collection'][i];\n        var legendElement = render.createGroup({\n          id: map.element.id + '_Legend_Index_' + i\n        });\n        var legendText = collection['DisplayText'];\n        eventArgs.fill = collection['Fill'];\n        eventArgs.shape = legend.type === 'Markers' ? isNullOrUndefined(collection['ImageSrc']) ? legend.shape : 'Image' : legend.shape;\n        map.trigger(legendRendering, eventArgs, function () {\n          var shapeId = map.element.id + '_Legend_Shape_Index_' + i;\n          var textId = map.element.id + '_Legend_Text_Index_' + i;\n          var shapeLocation = collection['Shape'];\n          var textLocation = collection['Text'];\n          var imageUrl = isNullOrUndefined(collection['ImageSrc']) ? legend.shape : collection['ImageSrc'];\n          var renderOptions = new PathOption(shapeId, eventArgs.fill, eventArgs.shapeBorder.width, eventArgs.shapeBorder.color, legend.opacity, '');\n          legend.textStyle.color = legend.textStyle.color !== null ? legend.textStyle.color : _this.maps.themeStyle.legendTextColor;\n          legend.textStyle.fontFamily = map.themeStyle.fontFamily || legend.textStyle.fontFamily;\n          legend.textStyle.size = map.themeStyle.legendFontSize || legend.textStyle.size;\n          legendElement.appendChild(drawSymbol(shapeLocation, eventArgs.shape, shapeSize, collection['ImageSrc'], renderOptions));\n          textOptions = new TextOption(textId, textLocation.x, textLocation.y, 'start', legendText, '', '');\n          renderTextElement(textOptions, legend.textStyle, legend.textStyle.color, legendElement);\n\n          _this.legendGroup.appendChild(legendElement);\n\n          if (i === _this.totalPages[page]['Collection'].length - 1) {\n            var pagingGroup = void 0;\n            var width = spacing;\n            var height = spacing / 2;\n\n            if (_this.page !== 0) {\n              var pagingText = page + 1 + '/' + _this.totalPages.length;\n              var pagingFont = legend.textStyle;\n              var pagingTextSize = measureText(pagingText, pagingFont);\n              var leftPageX = _this.legendItemRect.x + _this.legendItemRect.width - pagingTextSize.width - width * 2 - spacing;\n              var rightPageX = _this.legendItemRect.x + _this.legendItemRect.width;\n              var locY = _this.legendItemRect.y + _this.legendItemRect.height + height / 2 + spacing;\n              var pageTextX = rightPageX - width - pagingTextSize.width / 2 - spacing / 2;\n              pagingGroup = render.createGroup({\n                id: map.element.id + '_Legend_Paging_Group'\n              });\n              var leftPageElement = render.createGroup({\n                id: map.element.id + '_Legend_Left_Paging_Group'\n              });\n              var rightPageElement = render.createGroup({\n                id: map.element.id + '_Legend_Right_Paging_Group'\n              });\n              var rightPath = ' M ' + rightPageX + ' ' + locY + ' L ' + (rightPageX - width) + ' ' + (locY - height) + ' L ' + (rightPageX - width) + ' ' + (locY + height) + ' z ';\n              var leftPath = ' M ' + leftPageX + ' ' + locY + ' L ' + (leftPageX + width) + ' ' + (locY - height) + ' L ' + (leftPageX + width) + ' ' + (locY + height) + ' z ';\n              var leftPageOptions = new PathOption(map.element.id + '_Left_Page', '#a6a6a6', 0, '#a6a6a6', 1, '', leftPath);\n              leftPageElement.appendChild(render.drawPath(leftPageOptions));\n              var leftRectPageOptions = new RectOption(map.element.id + '_Left_Page_Rect', 'transparent', {}, 1, new Rect(leftPageX - width / 2, locY - height * 2, width * 2, spacing * 2), null, null, '', '');\n              leftPageElement.appendChild(render.drawRectangle(leftRectPageOptions));\n\n              _this.wireEvents(leftPageElement);\n\n              var rightPageOptions = new PathOption(map.element.id + '_Right_Page', '#a6a6a6', 0, '#a6a6a6', 1, '', rightPath);\n              rightPageElement.appendChild(render.drawPath(rightPageOptions));\n              var rightRectPageOptions = new RectOption(map.element.id + '_Right_Page_Rect', 'transparent', {}, 1, new Rect(rightPageX - width, locY - height, width, spacing), null, null, '', '');\n              rightPageElement.appendChild(render.drawRectangle(rightRectPageOptions));\n\n              _this.wireEvents(rightPageElement);\n\n              pagingGroup.appendChild(leftPageElement);\n              pagingGroup.appendChild(rightPageElement);\n              var pageTextOptions = {\n                'id': map.element.id + '_Paging_Text',\n                'x': pageTextX,\n                'y': locY + pagingTextSize.height / 4,\n                'fill': '#a6a6a6',\n                'font-size': '14px',\n                'font-style': pagingFont.fontStyle,\n                'font-family': pagingFont.fontFamily,\n                'font-weight': pagingFont.fontWeight,\n                'text-anchor': 'middle',\n                'transform': '',\n                'opacity': 1,\n                'dominant-baseline': ''\n              };\n              pagingGroup.appendChild(render.createText(pageTextOptions, pagingText));\n\n              _this.legendGroup.appendChild(pagingGroup);\n            }\n\n            _this.renderLegendBorder();\n          }\n        });\n      };\n\n      var this_2 = this;\n\n      for (var i = 0; i < this.totalPages[page]['Collection'].length; i++) {\n        _loop_2(i);\n      }\n    }\n  }; // tslint:disable-next-line:max-func-body-length\n\n\n  Legend.prototype.legendHighLightAndSelection = function (targetElement, value) {\n    var shapeIndex;\n    var layerIndex;\n    var dataIndex;\n    var textEle;\n    var legend = this.maps.legendSettings;\n    textEle = legend.mode === 'Default' ? document.getElementById(targetElement.id.replace('Shape', 'Text')) : document.getElementById(targetElement.id + '_Text');\n    var collection = this.maps.legendModule.legendCollection;\n    var length;\n    var selectLength = 0;\n    var interactProcess = true;\n\n    if (value === 'selection') {\n      this.shapeHighlightCollection = [];\n\n      if (this.legendSelectionCollection.length > 0) {\n        for (var k = 0; k < this.legendSelectionCollection.length; k++) {\n          if (targetElement === this.legendSelectionCollection[k]['legendElement']) {\n            interactProcess = false;\n            this.removeLegendSelectionCollection();\n            this.legendSelectionCollection.splice(k, 1);\n            break;\n          } else {\n            this.removeLegendSelectionCollection();\n            this.legendSelectionCollection.splice(k, 1);\n          }\n        }\n      }\n    } else {\n      if (this.legendSelectionCollection.length > 0) {\n        for (var k = 0; k < this.legendSelectionCollection.length; k++) {\n          if ((targetElement.id.indexOf('_Legend_Shape') > -1 || targetElement.id.indexOf('_Legend_Index')) && targetElement === this.legendSelectionCollection[k]['legendElement']) {\n            interactProcess = false;\n            break;\n          } else {\n            this.removeLegendHighlightCollection();\n          }\n        }\n      }\n\n      this.removeLegendHighlightCollection();\n    }\n\n    if (interactProcess) {\n      for (var i = 0; i < collection.length; i++) {\n        if (textEle.textContent === collection[i]['text'] && collection[i]['data'].length > 0 && parseFloat(targetElement.id.split('_Legend_Index_')[1]) === i) {\n          var layer = this.maps.layers[collection[i]['data'][0]['layerIndex']];\n          var enable = value === 'selection' ? layer.selectionSettings.enable : layer.highlightSettings.enable;\n          var module = void 0;\n          module = value === 'selection' ? layer.selectionSettings : layer.highlightSettings;\n          var data = collection[i]['data'];\n\n          if (enable) {\n            for (var j = 0; j < data.length; j++) {\n              shapeIndex = data[j]['shapeIndex'];\n              layerIndex = data[j]['layerIndex'];\n              dataIndex = data[j]['dataIndex'];\n              var shapeEle = document.getElementById(this.maps.element.id + '_LayerIndex_' + layerIndex + '_shapeIndex_' + shapeIndex + '_dataIndex_' + dataIndex);\n\n              if (shapeEle !== null) {\n                if (value === 'highlight' && this.shapeElement !== targetElement) {\n                  if (j === 0) {\n                    this.legendHighlightCollection = [];\n                    this.pushCollection(targetElement, this.legendHighlightCollection, collection[i], layer.shapeSettings);\n                  }\n\n                  length = this.legendHighlightCollection.length;\n                  var legendHighlightColor = this.legendHighlightCollection[length - 1]['legendOldFill'];\n                  this.legendHighlightCollection[length - 1]['MapShapeCollection']['Elements'].push(shapeEle);\n                  this.setColor(shapeEle, !isNullOrUndefined(module.fill) ? module.fill : legendHighlightColor, module.opacity.toString(), module.border.color, module.border.width.toString());\n                  this.setColor(targetElement, !isNullOrUndefined(module.fill) ? module.fill : legendHighlightColor, module.opacity.toString(), module.border.color, module.border.width.toString());\n                } else if (value === 'selection' && this.shapeSelection) {\n                  this.legendHighlightCollection = [];\n\n                  if (j === 0) {\n                    this.pushCollection(targetElement, this.legendSelectionCollection, collection[i], layer.shapeSettings);\n                  }\n\n                  selectLength = this.legendSelectionCollection.length;\n                  var legendSelectionColor = this.legendSelectionCollection[selectLength - 1]['legendOldFill'];\n                  this.legendSelectionCollection[selectLength - 1]['MapShapeCollection']['Elements'].push(shapeEle);\n                  this.setColor(targetElement, !isNullOrUndefined(module.fill) ? module.fill : legendSelectionColor, module.opacity.toString(), module.border.color, module.border.width.toString());\n                  this.setColor(shapeEle, !isNullOrUndefined(module.fill) ? module.fill : legendSelectionColor, module.opacity.toString(), module.border.color, module.border.width.toString());\n                  this.legendElement = targetElement;\n\n                  if (j === data.length - 1) {\n                    this.legendSelection = false;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  Legend.prototype.setColor = function (element, fill, opacity, borderColor, borderWidth) {\n    element.setAttribute('fill', fill);\n    element.setAttribute('opacity', opacity);\n    element.setAttribute('stroke', borderColor);\n    element.setAttribute('stroke-width', (Number(borderWidth) / this.maps.scale).toString());\n  };\n\n  Legend.prototype.pushCollection = function (targetElement, collection, oldElement, shapeSettings) {\n    collection.push({\n      legendElement: targetElement,\n      legendOldFill: oldElement['fill'],\n      legendOldOpacity: oldElement['opacity'],\n      legendOldBorderColor: oldElement['borderColor'],\n      legendOldBorderWidth: oldElement['borderWidth'],\n      shapeOpacity: shapeSettings.opacity,\n      shapeOldBorderColor: shapeSettings.border.color,\n      shapeOldBorderWidth: shapeSettings.border.width\n    });\n    length = collection.length;\n    collection[length - 1]['MapShapeCollection'] = {\n      Elements: []\n    };\n  };\n\n  Legend.prototype.removeLegend = function (collection) {\n    for (var i = 0; i < collection.length; i++) {\n      var item = collection[i];\n      this.setColor(item['legendElement'], item['legendOldFill'], item['legendOldOpacity'], item['legendOldBorderColor'], item['legendOldBorderWidth']);\n      var dataCount = item['MapShapeCollection']['Elements'].length;\n\n      for (var j = 0; j < dataCount; j++) {\n        this.setColor(item['MapShapeCollection']['Elements'][j], item['legendOldFill'], item['shapeOpacity'], item['shapeOldBorderColor'], item['shapeOldBorderWidth']);\n      }\n    }\n  };\n\n  Legend.prototype.removeLegendHighlightCollection = function () {\n    if (this.legendHighlightCollection.length > 0) {\n      this.removeLegend(this.legendHighlightCollection);\n    }\n  };\n\n  Legend.prototype.removeLegendSelectionCollection = function () {\n    if (this.legendSelectionCollection.length > 0) {\n      this.removeLegend(this.legendSelectionCollection);\n      this.legendElement = null;\n      this.legendSelection = true;\n    }\n  };\n\n  Legend.prototype.removeShapeHighlightCollection = function () {\n    if (this.shapeHighlightCollection.length > 0) {\n      for (var i = 0; i < this.shapeHighlightCollection.length; i++) {\n        var item = this.shapeHighlightCollection[i];\n        var removeFill = true;\n\n        for (var j = 0; j < this.shapeSelectionCollection.length; j++) {\n          if (this.shapeSelectionCollection[j]['legendElement'] === item['legendElement']) {\n            removeFill = false;\n          }\n        }\n\n        if (removeFill) {\n          this.setColor(item['legendElement'], item['legendOldFill'], item['legendOldOpacity'], item['legendOldBorderColor'], item['legendOldBorderWidth']);\n        }\n      }\n    }\n  };\n\n  Legend.prototype.shapeHighLightAndSelection = function (targetElement, data, module, getValue, layerIndex) {\n    if (data !== undefined) {\n      var collection = this.maps.legendModule.legendCollection;\n      var index = this.legendIndexOnShape(data, layerIndex);\n      var text = collection[index]['text'];\n      var content = void 0;\n      var legendShape = void 0;\n\n      if (this.maps.legendSettings.mode === 'Default') {\n        content = document.getElementById(this.maps.element.id + '_Legend_Text_Index_' + index).textContent;\n        legendShape = document.getElementById(this.maps.element.id + '_Legend_Shape_Index_' + index);\n      } else {\n        content = document.getElementById(this.maps.element.id + '_Legend_Index_' + index + '_Text').textContent;\n        legendShape = document.getElementById(this.maps.element.id + '_Legend_Index_' + index);\n      }\n\n      var shapeElement = this.shapeDataOnLegend(targetElement);\n      this.oldShapeElement = shapeElement['LegendEle'];\n      var length_1 = this.shapeSelectionCollection.length;\n\n      if (text === content) {\n        if (getValue === 'highlight' && shapeElement['LegendEle'] !== this.legendElement) {\n          var selectionEle = this.isTargetSelected(shapeElement, this.shapeHighlightCollection);\n\n          if (selectionEle === undefined || selectionEle && !selectionEle['IsSelected']) {\n            this.pushCollection(legendShape, this.shapeHighlightCollection, collection[index], this.maps.layers[layerIndex].shapeSettings);\n          }\n\n          if (length_1 > 0) {\n            for (var j = 0; j < length_1; j++) {\n              if (shapeElement['LegendEle'] === this.shapeSelectionCollection[j]['legendElement']) {\n                break;\n              } else if (j === length_1 - 1) {\n                this.removeShapeHighlightCollection();\n                this.setColor(legendShape, !isNullOrUndefined(module.fill) ? module.fill : legendShape.getAttribute('fill'), module.opacity.toString(), module.border.color, module.border.width.toString());\n              }\n            }\n          } else {\n            this.removeShapeHighlightCollection();\n            this.setColor(legendShape, !isNullOrUndefined(module.fill) ? module.fill : legendShape.getAttribute('fill'), module.opacity.toString(), module.border.color, module.border.width.toString());\n          }\n        } else if (getValue === 'selection') {\n          var selectionEle = this.isTargetSelected(shapeElement, this.shapeSelectionCollection);\n\n          if (length_1 > 0) {\n            for (var j = 0; j < length_1; j++) {\n              if (shapeElement['LegendEle'] !== this.shapeSelectionCollection[j]['legendElement']) {\n                var element = this.shapeSelectionCollection[j];\n                this.setColor(element['legendElement'], element['legendOldFill'], element['legendOldOpacity'], element['legendOldBorderColor'], element['legendOldBorderWidth']);\n                this.shapeSelection = true;\n                this.shapeElement = null;\n              }\n            }\n          }\n\n          if (selectionEle && selectionEle['IsSelected'] && targetElement.getAttribute('class') === 'ShapeselectionMapStyle') {\n            var element = this.shapeSelectionCollection[selectionEle['SelectionIndex']];\n            this.setColor(shapeElement['LegendEle'], element['legendOldFill'], element['legendOldOpacity'], element['legendOldBorderColor'], element['legendOldBorderWidth']);\n            this.shapeSelectionCollection.splice(selectionEle['SelectionIndex'], 1);\n            this.shapeSelection = true;\n            this.shapeElement = null;\n          }\n\n          if (targetElement.getAttribute('class') !== 'ShapeselectionMapStyle' && this.legendSelection) {\n            if (selectionEle === undefined || selectionEle && !selectionEle['IsSelected']) {\n              this.pushCollection(legendShape, this.shapeSelectionCollection, collection[index], this.maps.layers[layerIndex].shapeSettings);\n            }\n\n            this.setColor(legendShape, !isNullOrUndefined(module.fill) ? module.fill : legendShape.getAttribute('fill'), module.opacity.toString(), module.border.color, module.border.width.toString());\n            this.shapeElement = shapeElement['LegendEle'];\n            this.shapeSelection = false;\n          }\n        } else if (document.getElementsByClassName('highlightMapStyle').length > 0) {\n          this.removeShapeHighlightCollection();\n          removeClass(document.getElementsByClassName('highlightMapStyle')[0]);\n        }\n      }\n    } else {\n      this.removeShapeHighlightCollection();\n    }\n  };\n\n  Legend.prototype.isTargetSelected = function (target, collection) {\n    var selectEle;\n\n    for (var i = 0; i < collection.length; i++) {\n      if (target['LegendEle'] === collection[i]['legendElement']) {\n        selectEle = {\n          IsSelected: true,\n          SelectionIndex: i\n        };\n      }\n    }\n\n    return selectEle;\n  };\n\n  Legend.prototype.legendIndexOnShape = function (data, index) {\n    var legendIndex;\n    var path = this.maps.layers[index].shapeDataPath;\n    var value = data[path];\n    var collection = this.maps.legendModule.legendCollection;\n\n    for (var i = 0; i < collection.length; i++) {\n      var dataValue = collection[i]['data'];\n\n      for (var j = 0; j < dataValue.length; j++) {\n        if (value === dataValue[j]['name']) {\n          legendIndex = i;\n        }\n      }\n    }\n\n    return legendIndex;\n  };\n\n  Legend.prototype.shapeDataOnLegend = function (targetElement) {\n    var shapeIndex;\n    var layerIndex;\n    var dataIndex;\n    var collection = this.maps.legendModule.legendCollection;\n    var legend = this.maps.legendSettings;\n\n    for (var i = 0; i < collection.length; i++) {\n      var data = collection[i]['data'];\n      var process = false;\n      var elements = [];\n      var currentElement = {\n        Elements: []\n      };\n\n      for (var j = 0; j < data.length; j++) {\n        shapeIndex = data[j]['shapeIndex'];\n        layerIndex = data[j]['layerIndex'];\n        dataIndex = data[j]['dataIndex'];\n        var shapeEle = document.getElementById(this.maps.element.id + '_LayerIndex_' + layerIndex + '_shapeIndex_' + shapeIndex + '_dataIndex_' + dataIndex);\n\n        if (targetElement === shapeEle) {\n          process = true;\n        }\n\n        elements.push(shapeEle);\n      }\n\n      if (process) {\n        if (isNullOrUndefined(currentElement['LegendEle'])) {\n          currentElement['LegendEle'] = legend.mode === 'Default' ? document.getElementById(this.maps.element.id + '_Legend_Shape_Index_' + i) : document.getElementById(this.maps.element.id + '_Legend_Index_' + i);\n        }\n\n        currentElement['Elements'] = elements;\n        return currentElement;\n      }\n    }\n\n    return null;\n  }; //tslint:disable\n\n\n  Legend.prototype.renderLegendBorder = function () {\n    var map = this.maps;\n    var legend = map.legendSettings;\n    var legendTitle = legend.title.text;\n    var textStyle = legend.titleStyle;\n    var textOptions;\n    var spacing = 10;\n    var trimTitle = textTrim(this.legendItemRect.width + spacing * 2, legendTitle, textStyle);\n    var textSize = measureText(trimTitle, textStyle);\n    this.legendBorderRect = new Rect(this.legendItemRect.x - spacing, this.legendItemRect.y - spacing - textSize.height, this.legendItemRect.width + spacing * 2, this.legendItemRect.height + spacing * 2 + textSize.height + (legend.mode === 'Interactive' ? 0 : this.page !== 0 ? spacing : 0));\n\n    if (legendTitle) {\n      textStyle.color = textStyle.color !== null ? textStyle.color : this.maps.themeStyle.legendTextColor;\n      textOptions = new TextOption(map.element.id + '_LegendTitle', this.legendItemRect.x + this.legendItemRect.width / 2, this.legendItemRect.y - textSize.height / 2 - spacing / 2, 'middle', trimTitle, '');\n      renderTextElement(textOptions, textStyle, textStyle.color, this.legendGroup);\n    }\n\n    var renderOptions = new RectOption(map.element.id + '_Legend_Border', legend.background, legend.border, 1, this.legendBorderRect, null, null, '', '');\n    this.legendGroup.appendChild(map.renderer.drawRectangle(renderOptions));\n    this.getLegendAlignment(map, this.legendBorderRect.width, this.legendBorderRect.height, legend);\n    this.legendGroup.setAttribute('transform', 'translate( ' + (this.translate.x + -this.legendBorderRect.x) + ' ' + (this.translate.y + -this.legendBorderRect.y) + ' )');\n    map.svgObject.appendChild(this.legendGroup);\n  };\n\n  Legend.prototype.changeNextPage = function (e) {\n    this.currentPage = e.target.id.indexOf('_Left_Page_') > -1 ? this.currentPage - 1 : this.currentPage + 1;\n    this.legendGroup = this.maps.renderer.createGroup({\n      id: this.maps.element.id + '_Legend_Group'\n    });\n    this.drawLegendItem(this.currentPage);\n\n    if (querySelector(this.maps.element.id + '_Legend_Border', this.maps.element.id)) {\n      querySelector(this.maps.element.id + '_Legend_Border', this.maps.element.id).style.pointerEvents = 'none';\n    }\n  };\n\n  Legend.prototype.getLegendAlignment = function (map, width, height, legend) {\n    var x;\n    var y;\n    var spacing = 10;\n    var totalRect;\n    totalRect = extend({}, map.mapAreaRect, totalRect, true);\n    var areaX = totalRect.x;\n    var areaY = totalRect.y;\n    var areaHeight = totalRect.height;\n    var areaWidth = totalRect.width;\n    var totalWidth = map.availableSize.width;\n    var totalHeight = map.availableSize.height;\n\n    if (legend.position === 'Float') {\n      this.translate = legend.location;\n    } else {\n      switch (legend.position) {\n        case 'Top':\n        case 'Bottom':\n          totalRect.height = areaHeight - height;\n          x = totalWidth / 2 - width / 2;\n          y = legend.position === 'Top' ? areaY : areaY + totalRect.height;\n          totalRect.y = legend.position === 'Top' ? areaY + height + spacing : areaY;\n          break;\n\n        case 'Left':\n        case 'Right':\n          totalRect.width = areaWidth - width;\n          x = legend.position === 'Left' ? areaX : areaX + totalRect.width - spacing;\n          y = totalHeight / 2 - height / 2;\n          totalRect.x = legend.position === 'Left' ? areaX + width : areaX;\n          break;\n      }\n\n      switch (legend.alignment) {\n        case 'Near':\n          if (legend.position === 'Top' || legend.position === 'Bottom') {\n            x = totalRect.x;\n          } else {\n            y = totalRect.y;\n          }\n\n          break;\n\n        case 'Far':\n          if (legend.position === 'Top' || legend.position === 'Bottom') {\n            x = totalWidth - width - spacing;\n          } else {\n            y = totalHeight - height;\n          }\n\n          break;\n      }\n\n      if (legend.height && legend.width && legend.mode !== 'Interactive') {\n        map.totalRect = totalRect;\n      } else {\n        map.mapAreaRect = totalRect;\n      }\n\n      this.translate = new Point(x, y);\n    }\n  };\n\n  Legend.prototype.getMarkersLegendCollections = function (layerIndex, markers) {\n    var _this = this;\n\n    markers.forEach(function (marker, markerIndex) {\n      var dataSource = marker.dataSource;\n      var field = marker.legendText;\n      var templateFn;\n      var isDuplicate;\n      dataSource.forEach(function (data, dataIndex) {\n        var imageSrc = null;\n        var showLegend = isNullOrUndefined(data[_this.maps.legendSettings.showLegendPath]) ? true : data[_this.maps.legendSettings.showLegendPath];\n\n        if (marker.visible && showLegend && !isNullOrUndefined(data['latitude']) && !isNullOrUndefined(data['longitude'])) {\n          if (marker.template) {\n            templateFn = getTemplateFunction(marker.template);\n            var templateElement = templateFn(_this.maps);\n            var markerEle = isNullOrUndefined(templateElement.childElementCount) ? templateElement[0] : templateElement;\n            imageSrc = markerEle.querySelector('img').src;\n          }\n\n          var text = isNullOrUndefined(data[field]) ? '' : data[field];\n          isDuplicate = _this.maps.legendSettings.removeDuplicateLegend ? _this.removeDuplicates(_this.legendCollection, text) : false;\n\n          if (!isDuplicate) {\n            _this.legendCollection.push({\n              layerIndex: layerIndex,\n              markerIndex: markerIndex,\n              dataIndex: dataIndex,\n              fill: marker.fill,\n              text: text,\n              imageSrc: imageSrc\n            });\n          }\n        }\n      });\n    });\n  };\n\n  Legend.prototype.getRangeLegendCollection = function (layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath) {\n    var _this = this;\n\n    var legendText;\n    var legendIndex = 0;\n    var fill = this.maps.legendSettings.fill;\n    var rangeData = [];\n\n    var _loop_3 = function (colorMap) {\n      if (!isNullOrUndefined(colorMap.from) && !isNullOrUndefined(colorMap.to)) {\n        legendText = !isNullOrUndefined(colorMap.label) ? colorMap.label : colorMap.from + ' - ' + colorMap.to;\n        rangeData = [];\n        var colorMapProcess_1 = false;\n        dataSource.forEach(function (data, dataIndex) {\n          var colorValue = parseFloat(data[colorValuePath]);\n\n          if (colorValue >= colorMap.from && colorValue <= colorMap.to) {\n            colorMapProcess_1 = true;\n            rangeData.push(_this.getLegendData(layerIndex, dataIndex, data, dataPath, layerData, propertyPath, colorValue));\n          }\n        });\n\n        if (!colorMapProcess_1) {\n          rangeData.push({\n            layerIndex: layerIndex,\n            shapeIndex: null,\n            dataIndex: null,\n            name: null,\n            value: null\n          });\n        }\n\n        var legendFill = isNullOrUndefined(fill) ? Object.prototype.toString.call(colorMap.color) === '[object Array]' ? !isNullOrUndefined(colorMap.value) ? colorMap.color[0] : this_3.legendGradientColor(colorMap, legendIndex) : colorMap.color : fill;\n        legendIndex++;\n        this_3.getOverallLegendItemsCollection(legendText, legendFill, rangeData, colorMap.showLegend);\n      }\n    };\n\n    var this_3 = this;\n\n    for (var _i = 0, colorMapping_1 = colorMapping; _i < colorMapping_1.length; _i++) {\n      var colorMap = colorMapping_1[_i];\n\n      _loop_3(colorMap);\n    }\n  };\n\n  Legend.prototype.getOverallLegendItemsCollection = function (legendText, legendFill, legendData, showLegend) {\n    var newColllection = [];\n    var legend = this.maps.legendSettings;\n\n    if (legendData.length > 0 && showLegend) {\n      for (var i = 0; i < legendData.length; i++) {\n        var collection = legendData[i];\n\n        if (collection.length > 0) {\n          for (var j = 0; j < collection.length; j++) {\n            newColllection.push(collection[j]);\n          }\n        } else {\n          newColllection.push(legendData[i]);\n        }\n\n        newColllection['_isVisible'] = true;\n      }\n\n      var isDuplicate = this.maps.legendSettings.removeDuplicateLegend ? this.removeDuplicates(this.legendCollection, legendText) : false;\n\n      if (!isDuplicate) {\n        this.legendCollection.push({\n          text: legendText,\n          fill: legendFill,\n          data: newColllection,\n          opacity: legend.opacity,\n          borderColor: legend.shapeBorder.color,\n          borderWidth: legend.shapeBorder.width\n        });\n      }\n    }\n  };\n\n  Legend.prototype.removeDuplicates = function (legendCollection, text) {\n    var isDuplicate = false;\n\n    for (var i = 0; i < legendCollection.length; i++) {\n      if (legendCollection[i]['text'] === text) {\n        isDuplicate = true;\n        break;\n      } else {\n        continue;\n      }\n    }\n\n    return isDuplicate;\n  };\n\n  Legend.prototype.getEqualLegendCollection = function (layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath) {\n    var _this = this;\n\n    var fill = this.maps.legendSettings.fill;\n    var equalValues = [];\n    var legendText;\n    var legendIndex = 0;\n    var equalData = [];\n    var outOfRangeValues = [];\n    var outOfRange = [];\n\n    var _loop_4 = function (colorMap) {\n      if (!isNullOrUndefined(colorMap.value)) {\n        legendText = !isNullOrUndefined(colorMap.label) ? colorMap.label : colorMap.value;\n        equalData = [];\n        var eqaulColorProcess_1 = false;\n        dataSource.forEach(function (data, dataIndex) {\n          var equalValue = data[colorValuePath];\n\n          if (equalValue === colorMap.value) {\n            eqaulColorProcess_1 = true;\n\n            if (equalValues.indexOf(equalValue) === -1) {\n              equalValues.push(equalValue);\n            }\n\n            equalData.push(_this.getLegendData(layerIndex, dataIndex, data, dataPath, layerData, propertyPath, equalValue));\n          } else {\n            if (outOfRangeValues.indexOf(equalValue) === -1) {\n              outOfRangeValues.push(equalValue);\n            }\n          }\n        });\n\n        for (var x = 0; x < equalValues.length; x++) {\n          for (var y = 0; y < outOfRangeValues.length; y++) {\n            if (equalValues[x] === outOfRangeValues[y]) {\n              var equalIndex = outOfRangeValues.indexOf(equalValues[x]);\n              outOfRangeValues.splice(equalIndex, 1);\n            }\n          }\n        }\n\n        if (!eqaulColorProcess_1) {\n          equalData.push({\n            layerIndex: layerIndex,\n            shapeIndex: null,\n            dataIndex: null,\n            name: null,\n            value: null\n          });\n        }\n\n        var legendFill = isNullOrUndefined(fill) ? Object.prototype.toString.call(colorMap.color) === '[object Array]' ? colorMap.color[0] : colorMap.color : fill;\n        legendIndex++;\n        this_4.getOverallLegendItemsCollection(legendText, legendFill, equalData, colorMap.showLegend);\n      } else if (isNullOrUndefined(colorMap.minOpacity) && isNullOrUndefined(colorMap.maxOpacity) && isNullOrUndefined(colorMap.value) && isNullOrUndefined(colorMap.from) && isNullOrUndefined(colorMap.to) && !isNullOrUndefined(colorMap.color)) {\n        dataSource.forEach(function (data, dataIndex) {\n          var equalValue = data[colorValuePath];\n\n          for (var k = 0; k < outOfRangeValues.length; k++) {\n            if (equalValue === outOfRangeValues[k]) {\n              outOfRange.push(_this.getLegendData(layerIndex, dataIndex, data, dataPath, layerData, propertyPath, equalValue));\n            }\n          }\n        });\n\n        if (outOfRangeValues.length === 0) {\n          var range_1 = false;\n          var outRange = [];\n          dataSource.forEach(function (data, dataIndex) {\n            range_1 = false;\n            var rangeValue = data[colorValuePath];\n\n            for (var z = 0; z < colorMapping.length; z++) {\n              if (!isNullOrUndefined(rangeValue) && rangeValue !== 0) {\n                if (rangeValue >= colorMapping[z].from && rangeValue <= colorMapping[z].to) {\n                  range_1 = true;\n                }\n              } else if (!range_1) {\n                range_1 = false;\n              }\n            }\n\n            if (!range_1) {\n              outOfRange.push(_this.getLegendData(layerIndex, dataIndex, data, dataPath, layerData, propertyPath, rangeValue));\n            }\n          });\n        }\n\n        legendText = !isNullOrUndefined(colorMap.label) ? colorMap.label : 'Others';\n        var outfill = Object.prototype.toString.call(colorMap.color) === '[object Array]' ? colorMap.color[0] : colorMap.color;\n        var legendOutFill = outfill;\n        legendIndex++;\n        this_4.getOverallLegendItemsCollection(legendText, legendOutFill, outOfRange, colorMap.showLegend);\n      }\n    };\n\n    var this_4 = this;\n\n    for (var _i = 0, colorMapping_2 = colorMapping; _i < colorMapping_2.length; _i++) {\n      var colorMap = colorMapping_2[_i];\n\n      _loop_4(colorMap);\n    }\n  };\n\n  Legend.prototype.getDataLegendCollection = function (layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath) {\n    var _this = this;\n\n    var legendText;\n    var fill = this.maps.legendSettings.fill;\n    var valuePath = this.maps.legendSettings.valuePath;\n\n    if (!isNullOrUndefined(colorValuePath) && !isNullOrUndefined(dataSource)) {\n      dataSource.forEach(function (data, dataIndex) {\n        var showLegend = isNullOrUndefined(_this.maps.legendSettings.showLegendPath) ? true : isNullOrUndefined(data[_this.maps.legendSettings.showLegendPath]) ? false : data[_this.maps.legendSettings.showLegendPath];\n        var dataValue = data[colorValuePath];\n        var newData = [];\n        var legendFill = isNullOrUndefined(fill) ? dataValue : fill;\n\n        if (!isNullOrUndefined(dataValue) && colorMapping.length === 0) {\n          legendText = !isNullOrUndefined(data[valuePath]) ? data[valuePath] : data[dataPath];\n          newData.push(_this.getLegendData(layerIndex, dataIndex, data, dataPath, layerData, propertyPath, dataValue));\n        }\n\n        _this.getOverallLegendItemsCollection(legendText, legendFill, newData, showLegend);\n      });\n    }\n  };\n\n  Legend.prototype.interactiveHandler = function (e) {\n    var target = e.target;\n    var legend = this.maps.legendSettings;\n    var id = this.maps.element.id + '_Interactive_Legend';\n    var hoverId = legend.type === 'Layers' ? '_shapeIndex_' : legend.type === 'Markers' ? '_MarkerIndex_' : '_BubbleIndex_';\n\n    if (target.id.indexOf(hoverId) > 1) {\n      var layerIndex = parseFloat(target.id.split('_LayerIndex_')[1].split('_')[0]);\n      var dataIndex = parseFloat(target.id.split(/_dataIndex_/i)[1].split('_')[0]);\n      var fill = void 0;\n      var stroke = void 0;\n      var strokeWidth = void 0;\n\n      if (!isNullOrUndefined(querySelector(id, this.maps.element.id))) {\n        remove(querySelector(id, this.maps.element.id));\n      }\n\n      var layer = this.maps.layersCollection[layerIndex];\n      var markerVisible = legend.type === 'Layers' ? layer.visible : legend.type === 'Markers' ? layer.markerSettings[parseFloat(target.id.split('_MarkerIndex_')[1].split('_')[0])].visible : this.maps.getBubbleVisible(this.maps.layersCollection[layerIndex]);\n\n      if (legend.visible && this.legendRenderingCollections.length > 0 && legend.mode === 'Interactive' && markerVisible) {\n        var svgRect = this.maps.svgObject.getBoundingClientRect();\n\n        for (var i = 0; i < this.legendCollection.length; i++) {\n          var currentData = this.legendCollection[i];\n          var legendElement = querySelector(this.maps.element.id + '_Legend_Index_' + i, this.maps.element.id);\n          var legendRect = legendElement.getBoundingClientRect();\n          var rect = new Rect(Math.abs(legendRect.left - svgRect.left), Math.abs(legendRect.top - svgRect.top), legendRect.width, legendRect.height);\n          fill = legendElement.getAttribute('fill');\n          stroke = legend.shapeBorder.color;\n          strokeWidth = legend.shapeBorder.width;\n\n          if (!isNullOrUndefined(currentData['data'])) {\n            var data = currentData['data'];\n\n            for (var j = 0; j < data.length; j++) {\n              if (dataIndex === data[j]['dataIndex'] && layerIndex === data[j]['layerIndex']) {\n                this.renderInteractivePointer(legend, fill, stroke, id, strokeWidth, rect);\n                break;\n              }\n            }\n          }\n        }\n      }\n    } else {\n      if (!isNullOrUndefined(querySelector(id, this.maps.element.id))) {\n        remove(querySelector(id, this.maps.element.id));\n      }\n    }\n  };\n\n  Legend.prototype.renderInteractivePointer = function (legend, fill, stroke, id, strokeWidth, rect) {\n    var path;\n    var pathOptions;\n    var locX;\n    var locY;\n    var height = 10;\n    var width = 10;\n    var direction = legend.orientation === 'None' ? legend.position === 'Top' || legend.position === 'Bottom' ? 'Horizontal' : 'Vertical' : legend.orientation;\n\n    if (direction === 'Horizontal') {\n      if (!legend.invertedPointer) {\n        locX = rect.x + rect.width / 2;\n        locY = rect.y;\n        path = ' M ' + locX + ' ' + locY + ' L ' + (locX - width) + ' ' + (locY - height) + ' L ' + (locX + width) + ' ' + (locY - height) + ' Z ';\n      } else {\n        locX = rect.x + rect.width / 2;\n        locY = rect.y + rect.height;\n        path = ' M ' + locX + ' ' + locY + ' L ' + (locX - width) + ' ' + (locY + height) + ' L ' + (locX + width) + ' ' + (locY + height) + ' Z ';\n      }\n    } else {\n      if (!legend.invertedPointer) {\n        locX = rect.x + rect.width;\n        locY = rect.y + rect.height / 2;\n        path = ' M ' + locX + ' ' + locY + ' L ' + (locX + width) + ' ' + (locY - height) + ' L ' + (locX + width) + ' ' + (locY + height) + ' z ';\n      } else {\n        locX = rect.x;\n        locY = rect.y + rect.height / 2;\n        path = ' M ' + locX + ' ' + locY + ' L ' + (locX - width) + ' ' + (locY - height) + ' L ' + (locX - width) + ' ' + (locY + height) + ' z ';\n      }\n    }\n\n    pathOptions = new PathOption(id, fill, strokeWidth, stroke, 1, '', path);\n    this.maps.svgObject.appendChild(this.maps.renderer.drawPath(pathOptions));\n  };\n\n  Legend.prototype.wireEvents = function (element) {\n    EventHandler.add(element, Browser.touchStartEvent, this.changeNextPage, this);\n  };\n\n  Legend.prototype.addEventListener = function () {\n    if (this.maps.isDestroyed) {\n      return;\n    }\n\n    this.maps.on(Browser.touchMoveEvent, this.interactiveHandler, this);\n    this.maps.on(Browser.touchEndEvent, this.interactiveHandler, this);\n    this.maps.on(click, this.legendClick, this);\n  };\n\n  Legend.prototype.legendClick = function (targetEle) {\n    var legendShapeId;\n    var legendTextId;\n    var legendTextColor;\n    var legendToggleFill = this.maps.legendSettings.toggleLegendSettings.fill;\n    var legendToggleOpacity = this.maps.legendSettings.toggleLegendSettings.opacity;\n    var legendToggleBorderColor = this.maps.legendSettings.toggleLegendSettings.border.color;\n    var legendToggleBorderWidth = this.maps.legendSettings.toggleLegendSettings.border.width;\n\n    if (targetEle.parentNode['id'].indexOf(this.maps.element.id + '_Legend_Index_') > -1) {\n      var mapElement = void 0;\n      var legendIndex = parseFloat(targetEle.parentElement.id.substr((this.maps.element.id + '_Legend_Index_').length));\n      var selectedItem = this.legendCollection[legendIndex]['data'];\n      var isVisible = selectedItem['_isVisible'];\n      var shape = void 0;\n\n      if (this.maps.legendSettings.toggleLegendSettings.enable && this.maps.legendSettings.type === \"Bubbles\") {\n        for (var k = 0; k < this.maps.layers.length; k++) {\n          for (var j = 0; j < this.maps.layers[k].bubbleSettings.length; j++) {\n            for (var i = 0; i < selectedItem.length; i++) {\n              shape = this.legendCollection[legendIndex]['data'][i];\n              mapElement = querySelector(this.maps.element.id + '_LayerIndex_' + shape['layerIndex'] + '_BubbleIndex_' + j + '_dataIndex_' + shape['dataIndex'], this.maps.element.id);\n\n              if (isVisible && mapElement !== null) {\n                if (this.maps.legendSettings.toggleLegendSettings.applyShapeSettings) {\n                  mapElement.setAttribute('fill', this.maps.layers[k].shapeSettings.fill);\n                  mapElement.setAttribute('stroke', this.maps.layers[k].shapeSettings.border.color);\n                  mapElement.setAttribute('opacity', this.maps.layers[k].shapeSettings.opacity.toString());\n                  mapElement.setAttribute('stroke-width', this.maps.layers[k].shapeSettings.border.width.toString());\n                } else {\n                  mapElement.setAttribute(\"fill\", legendToggleFill);\n                  mapElement.setAttribute(\"opacity\", legendToggleOpacity.toString());\n                  mapElement.setAttribute('stroke', legendToggleBorderColor);\n                  mapElement.setAttribute('stroke-width', legendToggleBorderWidth.toString());\n                }\n\n                if (targetEle !== null) {\n                  legendShapeId = querySelector(this.maps.element.id + '_Legend_Shape_Index_' + legendIndex, this.maps.element.id);\n                  legendShapeId.setAttribute(\"fill\", \"#E5E5E5\");\n                  legendTextId = querySelector(this.maps.element.id + '_Legend_Text_Index_' + legendIndex, this.maps.element.id);\n                  legendTextId.setAttribute(\"fill\", \"#E5E5E5\");\n                }\n              } else {\n                mapElement.setAttribute('fill', this.legendCollection[legendIndex]['fill']);\n                mapElement.setAttribute('stroke', this.maps.layers[k].bubbleSettings[j].border.color);\n                mapElement.setAttribute('opacity', this.maps.layers[k].bubbleSettings[j].opacity.toString());\n                mapElement.setAttribute('stroke-width', this.maps.layers[k].bubbleSettings[j].border.width.toString());\n\n                if (targetEle !== null) {\n                  legendShapeId = querySelector(this.maps.element.id + '_Legend_Shape_Index_' + legendIndex, this.maps.element.id);\n                  legendShapeId.setAttribute(\"fill\", this.legendCollection[legendIndex]['fill']);\n                  legendTextId = querySelector(this.maps.element.id + '_Legend_Text_Index_' + legendIndex, this.maps.element.id);\n                  legendTextId.setAttribute(\"fill\", \"#757575\");\n                }\n              }\n            }\n\n            selectedItem['_isVisible'] = isVisible ? false : true;\n          }\n        }\n      }\n\n      if (this.maps.legendSettings.type === \"Layers\" && this.maps.legendSettings.toggleLegendSettings.enable) {\n        var layerElement = void 0;\n\n        for (var k = 0; k < this.maps.layers.length; k++) {\n          for (var i = 0; i < selectedItem.length; i++) {\n            shape = this.legendCollection[legendIndex]['data'][i];\n            layerElement = querySelector(this.maps.element.id + '_LayerIndex_' + shape['layerIndex'] + '_shapeIndex_' + shape['shapeIndex'] + '_dataIndex_' + shape['dataIndex'], this.maps.element.id);\n\n            if (layerElement !== null) {\n              if (isVisible) {\n                if (this.maps.legendSettings.toggleLegendSettings.applyShapeSettings) {\n                  layerElement.setAttribute('fill', this.maps.layers[k].shapeSettings.fill);\n                  layerElement.setAttribute('opacity', this.maps.layers[k].shapeSettings.opacity.toString());\n                  layerElement.setAttribute('stroke', this.maps.layers[k].shapeSettings.border.color);\n                  layerElement.setAttribute('stroke-width', this.maps.layers[k].shapeSettings.border.width.toString());\n                } else {\n                  layerElement.setAttribute(\"fill\", legendToggleFill);\n                  layerElement.setAttribute(\"opacity\", legendToggleOpacity.toString());\n                  layerElement.setAttribute('stroke', legendToggleBorderColor);\n                  layerElement.setAttribute('stroke-width', legendToggleBorderWidth.toString());\n                }\n\n                if (targetEle !== null) {\n                  legendTextId = querySelector(this.maps.element.id + '_Legend_Text_Index_' + legendIndex, this.maps.element.id);\n                  legendTextId.setAttribute(\"fill\", \"#E5E5E5\");\n                  legendShapeId = querySelector(this.maps.element.id + '_Legend_Shape_Index_' + legendIndex, this.maps.element.id);\n                  legendShapeId.setAttribute(\"fill\", \"#E5E5E5\");\n                }\n              } else {\n                layerElement.setAttribute('fill', this.legendCollection[legendIndex]['fill']);\n                layerElement.setAttribute('opacity', this.maps.layers[k].shapeSettings.opacity.toString());\n                layerElement.setAttribute('stroke', this.maps.layers[k].shapeSettings.border.color);\n                layerElement.setAttribute('stroke-width', this.maps.layers[k].shapeSettings.border.width.toString());\n\n                if (targetEle !== null) {\n                  legendTextId = querySelector(this.maps.element.id + '_Legend_Text_Index_' + legendIndex, this.maps.element.id);\n                  legendTextId.setAttribute(\"fill\", \"#757575\");\n                  legendShapeId = querySelector(this.maps.element.id + '_Legend_Shape_Index_' + legendIndex, this.maps.element.id);\n                  legendShapeId.setAttribute(\"fill\", this.legendCollection[legendIndex]['fill']);\n                }\n              }\n            }\n          }\n        }\n\n        selectedItem['_isVisible'] = isVisible ? false : true;\n      }\n    } else if (!isNullOrUndefined(targetEle.id) && (targetEle.id.indexOf(this.maps.element.id + '_Legend_Shape_Index') > -1 || targetEle.id.indexOf(this.maps.element.id + '_Legend_Index') !== -1) && this.maps.legendSettings.visible && targetEle.id.indexOf('_Text') === -1) {\n      var LegendInteractive = void 0;\n      var legendIndex = parseFloat(targetEle.id.substr((this.maps.element.id + '_Legend_Index_').length));\n      var mapdata = void 0;\n      var selectedItem = this.legendCollection[legendIndex]['data'];\n      var isVisible = selectedItem['_isVisible'];\n\n      if (this.maps.legendSettings.type === \"Bubbles\" && this.maps.legendSettings.toggleLegendSettings.enable) {\n        for (var k = 0; k < this.maps.layers.length; k++) {\n          for (var j = 0; j < this.maps.layers[k].bubbleSettings.length; j++) {\n            for (var i = 0; i < selectedItem.length; i++) {\n              mapdata = this.legendCollection[legendIndex]['data'][i];\n              LegendInteractive = querySelector(this.maps.element.id + '_LayerIndex_' + mapdata['layerIndex'] + '_BubbleIndex_' + j + '_dataIndex_' + mapdata['dataIndex'], this.maps.element.id);\n\n              if (isVisible && LegendInteractive !== null) {\n                if (this.maps.legendSettings.toggleLegendSettings.applyShapeSettings) {\n                  LegendInteractive.setAttribute('fill', this.maps.layers[k].shapeSettings.fill);\n                  LegendInteractive.setAttribute('stroke', this.maps.layers[k].shapeSettings.border.color);\n                  LegendInteractive.setAttribute('stroke-width', this.maps.layers[k].shapeSettings.border.width.toString());\n                  LegendInteractive.setAttribute('opacity', this.maps.layers[k].shapeSettings.opacity.toString());\n                } else {\n                  LegendInteractive.setAttribute(\"fill\", legendToggleFill);\n                  LegendInteractive.setAttribute(\"opacity\", legendToggleOpacity.toString());\n                  LegendInteractive.setAttribute('stroke', legendToggleBorderColor);\n                  LegendInteractive.setAttribute('stroke-width', legendToggleBorderWidth.toString());\n                }\n\n                if (targetEle !== null) {\n                  legendTextId = querySelector(this.maps.element.id + '_Legend_Index_' + legendIndex + '_Text', this.maps.element.id);\n                  legendTextId.setAttribute(\"fill\", \"#E5E5E5\");\n                  legendShapeId = querySelector(this.maps.element.id + '_Legend_Index_' + legendIndex, this.maps.element.id);\n                  legendShapeId.setAttribute(\"fill\", \"#E5E5E5\");\n                }\n              } else {\n                LegendInteractive.setAttribute('fill', this.legendCollection[legendIndex]['fill']);\n                LegendInteractive.setAttribute('stroke', this.maps.layers[k].bubbleSettings[j].border.color);\n                LegendInteractive.setAttribute('stroke-width', this.maps.layers[k].bubbleSettings[j].border.width.toString());\n                LegendInteractive.setAttribute('opacity', this.maps.layers[k].bubbleSettings[j].opacity.toString());\n\n                if (targetEle !== null) {\n                  legendShapeId = querySelector(this.maps.element.id + '_Legend_Index_' + legendIndex, this.maps.element.id);\n                  legendShapeId.setAttribute(\"fill\", this.legendCollection[legendIndex]['fill']);\n                  legendTextId = querySelector(this.maps.element.id + '_Legend_Index_' + legendIndex + '_Text', this.maps.element.id);\n                  legendTextId.setAttribute(\"fill\", \"#757575\");\n                }\n              }\n            }\n\n            selectedItem['_isVisible'] = isVisible ? false : true;\n          }\n        }\n      }\n\n      if (this.maps.legendSettings.type === \"Layers\" && this.maps.legendSettings.toggleLegendSettings.enable) {\n        var mapLegendElement = void 0;\n\n        for (var k = 0; k < this.maps.layers.length; k++) {\n          for (var i = 0; i < selectedItem.length; i++) {\n            mapdata = this.legendCollection[legendIndex]['data'][i];\n            mapLegendElement = querySelector(this.maps.element.id + '_LayerIndex_' + mapdata['layerIndex'] + '_shapeIndex_' + mapdata['shapeIndex'] + '_dataIndex_' + mapdata['dataIndex'], this.maps.element.id);\n\n            if (mapLegendElement !== null) {\n              if (isVisible) {\n                if (this.maps.legendSettings.toggleLegendSettings.applyShapeSettings) {\n                  mapLegendElement.setAttribute('fill', this.maps.layers[0].shapeSettings.fill);\n                  mapLegendElement.setAttribute('stroke', this.maps.layers[0].shapeSettings.border.color);\n                  mapLegendElement.setAttribute('opacity', this.maps.layers[k].shapeSettings.opacity.toString());\n                  mapLegendElement.setAttribute('stroke-width', this.maps.layers[k].shapeSettings.border.width.toString());\n                } else {\n                  mapLegendElement.setAttribute(\"fill\", legendToggleFill);\n                  mapLegendElement.setAttribute(\"opacity\", legendToggleOpacity.toString());\n                  mapLegendElement.setAttribute('stroke', legendToggleBorderColor);\n                  mapLegendElement.setAttribute('stroke-width', legendToggleBorderWidth.toString());\n                }\n\n                if (targetEle !== null) {\n                  legendShapeId = querySelector(this.maps.element.id + '_Legend_Index_' + legendIndex, this.maps.element.id);\n                  legendShapeId.setAttribute(\"fill\", \"#E5E5E5\");\n                  legendTextId = querySelector(this.maps.element.id + '_Legend_Index_' + legendIndex + '_Text', this.maps.element.id);\n                  legendTextId.setAttribute(\"fill\", \"#E5E5E5\");\n                }\n              } else {\n                mapLegendElement.setAttribute('fill', this.legendCollection[legendIndex]['fill']);\n                mapLegendElement.setAttribute('stroke', this.maps.layers[0].shapeSettings.border.color);\n                mapLegendElement.setAttribute('opacity', this.maps.layers[k].shapeSettings.opacity.toString());\n                mapLegendElement.setAttribute('stroke-width', this.maps.layers[k].shapeSettings.border.width.toString());\n\n                if (targetEle !== null) {\n                  legendTextId = querySelector(this.maps.element.id + '_Legend_Index_' + legendIndex + '_Text', this.maps.element.id);\n                  legendTextId.setAttribute(\"fill\", \"#757575\");\n                  legendShapeId = querySelector(this.maps.element.id + '_Legend_Index_' + legendIndex, this.maps.element.id);\n                  legendShapeId.setAttribute(\"fill\", this.legendCollection[legendIndex]['fill']);\n                }\n              }\n            }\n          }\n        }\n\n        selectedItem['_isVisible'] = isVisible ? false : true;\n      }\n    }\n  };\n\n  Legend.prototype.removeEventListener = function () {\n    if (this.maps.isDestroyed) {\n      return;\n    }\n\n    this.maps.off(Browser.touchMoveEvent, this.interactiveHandler);\n    this.maps.off(Browser.touchEndEvent, this.interactiveHandler);\n    this.maps.off(click, this.legendClick);\n  };\n\n  Legend.prototype.getLegendData = function (layerIndex, dataIndex, data, dataPath, layerData, shapePropertyPath, value) {\n    var legendData = [];\n\n    if (Object.prototype.toString.call(layerData) === '[object Array]') {\n      for (var i = 0; i < layerData.length; i++) {\n        var shapeData = layerData[i];\n        var shapePath = checkPropertyPath(data[dataPath], shapePropertyPath, shapeData['properties']);\n\n        if (shapeData['properties'][shapePath] === data[dataPath]) {\n          legendData.push({\n            layerIndex: layerIndex,\n            shapeIndex: i,\n            dataIndex: dataIndex,\n            name: data[dataPath],\n            value: value\n          });\n        }\n      }\n    }\n\n    return legendData;\n  };\n\n  Legend.prototype.legendGradientColor = function (colorMap, legendIndex) {\n    var legendFillColor;\n    var xmlns = 'http://www.w3.org/2000/svg';\n\n    if (!isNullOrUndefined(colorMap.color) && typeof colorMap.color === 'object') {\n      var linerGradientEle = document.createElementNS(xmlns, 'linearGradient');\n      var opacity = 1;\n      var position = this.maps.legendSettings.position;\n      var x2 = void 0;\n      var y2 = void 0;\n      x2 = position === 'Top' || position === 'Bottom' ? '100' : '0';\n      y2 = position === 'Top' || position === 'Bottom' ? '0' : '100';\n      linerGradientEle.setAttribute('id', 'linear_' + legendIndex);\n      linerGradientEle.setAttribute('x1', 0 + '%');\n      linerGradientEle.setAttribute('y1', 0 + '%');\n      linerGradientEle.setAttribute('x2', x2 + '%');\n      linerGradientEle.setAttribute('y2', y2 + '%');\n\n      for (var b = 0; b < colorMap.color.length; b++) {\n        var offsetColor = 100 / (colorMap.color.length - 1);\n        var stopEle = document.createElementNS(xmlns, 'stop');\n        stopEle.setAttribute('offset', b * offsetColor + '%');\n        stopEle.setAttribute('stop-color', colorMap.color[b]);\n        stopEle.setAttribute('stop-opacity', opacity.toString());\n        linerGradientEle.appendChild(stopEle);\n      }\n\n      this.legendLinearGradient = linerGradientEle;\n      var color = 'url(' + '#linear_' + legendIndex + ')';\n      this.defsElement.appendChild(linerGradientEle);\n      legendFillColor = color;\n    }\n\n    return legendFillColor;\n  };\n  /**\n   * Get module name.\n   */\n\n\n  Legend.prototype.getModuleName = function () {\n    return 'Legend';\n  };\n  /**\n   * To destroy the legend.\n   * @return {void}\n   * @private\n   */\n\n\n  Legend.prototype.destroy = function (maps) {\n    /**\n     * Destroy method performed here\n     */\n    this.removeEventListener();\n  };\n\n  return Legend;\n}();\n\nexport { Legend };","map":null,"metadata":{},"sourceType":"module"}