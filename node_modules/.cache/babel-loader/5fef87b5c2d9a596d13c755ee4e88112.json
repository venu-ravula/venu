{"ast":null,"code":"import { convertTileLatLongToPoint } from '../index';\nimport { convertGeoToPoint, Point, PathOption } from '../utils/helper';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * navigation-selected-line\n */\n\nvar NavigationLine =\n/** @class */\nfunction () {\n  function NavigationLine(maps) {\n    this.maps = maps;\n  }\n  /* tslint:disable:no-string-literal */\n  //tslint:disable:max-func-body-length\n\n  /**\n   * To render navigation line for maps\n   */\n\n\n  NavigationLine.prototype.renderNavigation = function (layer, factor, layerIndex) {\n    var navigationEle;\n    var navigation;\n    navigation = layer.navigationLineSettings;\n    var longitude;\n    var point = [];\n    var latitude;\n    var visible;\n    var angle;\n    var width;\n    var color;\n    var dashArray;\n    var pathOption;\n    var direction;\n    var markerWidth;\n    var arcId;\n    var radius;\n    var showArrow;\n    var arrowColor;\n    var arrowSize;\n    var arrowSettings;\n    var arrowPosition;\n    var startArrow;\n    var endArrow;\n    var offSet;\n    var offSetValue;\n    var navigationGroup;\n    var d;\n    var group = this.maps.renderer.createGroup({\n      id: this.maps.element.id + '_LayerIndex_' + layerIndex + '_line_Group'\n    });\n\n    for (var i = 0; i < navigation.length; i++) {\n      latitude = navigation[i]['properties']['latitude'];\n      longitude = navigation[i]['properties']['longitude'];\n      visible = navigation[i]['properties']['visible'];\n      angle = navigation[i]['angle'];\n      width = navigation[i]['width'] || 1;\n      color = navigation[i]['color'];\n      dashArray = navigation[i]['properties']['dashArray'];\n      arrowSettings = navigation[i]['properties']['arrowSettings'];\n      showArrow = isNullOrUndefined(arrowSettings) ? false : arrowSettings['properties']['showArrow'];\n\n      if (longitude['length'] === latitude['length'] && visible) {\n        for (var i_1 = 0; i_1 < longitude['length']; i_1++) {\n          var location_1 = this.maps.isTileMap ? convertTileLatLongToPoint(new Point(longitude[i_1], latitude[i_1]), factor, this.maps.tileTranslatePoint, true) : convertGeoToPoint(latitude[i_1], longitude[i_1], factor, layer, this.maps);\n          point.push(location_1);\n        }\n      }\n\n      navigationGroup = this.maps.renderer.createGroup({\n        id: this.maps.element.id + '_LayerIndex_' + layerIndex + '_NavigationGroup' + i + ''\n      });\n\n      for (var j = 0; j < point['length'] - 1; j++) {\n        angle = -1 > angle ? -1 : angle;\n        angle = 1 < angle ? 1 : angle;\n        var arcId_1 = this.maps.element.id + '_LayerIndex_' + layerIndex + '_NavigationIndex_' + i + '_Line' + j + '';\n        var radius_1 = this.convertRadius(point[j], point[j + 1]);\n\n        if (angle <= 1 && angle > 0) {\n          direction = 0;\n\n          if (point[j]['x'] > point[j + 1]['x']) {\n            direction = 1;\n          }\n        }\n\n        if (angle >= -1 && angle < 0) {\n          direction = 1;\n\n          if (point[j]['x'] > point[j + 1]['x']) {\n            direction = 0;\n          }\n        }\n\n        if (point[j]['x'] !== point[j + 1]['x']) {\n          if (showArrow) {\n            arrowColor = arrowSettings['properties']['color'];\n            arrowSize = arrowSettings['properties']['size'];\n            offSetValue = arrowSettings['properties']['offSet'] === undefined ? 0 : arrowSettings['properties']['offSet'];\n            var divide = Math.round(arrowSize / 2);\n            arrowPosition = arrowSettings['properties']['position'];\n            startArrow = arrowPosition === 'Start' ? 'url(#triangle' + i + ')' : null;\n            endArrow = arrowPosition === 'End' ? 'url(#triangle' + i + ')' : null;\n\n            if (offSet !== 0 && angle === 0) {\n              offSet = arrowPosition === 'Start' ? offSetValue : -offSetValue;\n            }\n\n            offSet = isNullOrUndefined(offSet) ? 0 : offSet;\n            var triId = this.maps.element.id + '_triangle';\n            var defElement = this.maps.renderer.createDefs();\n            defElement.innerHTML += '<marker id=\"' + 'triangle' + i + '\"></marker>';\n            var markerEle = defElement.querySelector('#' + 'triangle' + i);\n            markerEle.setAttribute('markerWidth', arrowSize.toString());\n            markerEle.setAttribute('markerHeight', arrowSize.toString());\n            markerEle.setAttribute('refX', (divide - offSet).toString());\n            markerEle.setAttribute('refY', divide.toString());\n            markerEle.setAttribute('orient', 'auto');\n            var d2 = 'M 0,0  L 0,' + arrowSize + ' L ' + divide + ', ' + divide + ' Z';\n            pathOption = new PathOption(triId, arrowColor, width, color, 1, dashArray, d2);\n            navigationEle = this.maps.renderer.drawPath(pathOption);\n            markerEle.appendChild(navigationEle);\n            defElement.appendChild(markerEle);\n            navigationGroup.appendChild(defElement);\n          }\n\n          angle = Math.abs(angle);\n          d = angle === 0 ? 'M ' + point[j]['x'] + ',' + point[j]['y'] + 'L ' + point[j + 1]['x'] + ',' + point[j + 1]['y'] + ' ' : 'M ' + point[j]['x'] + ',' + point[j]['y'] + ' A ' + (radius_1 / 2 + (1 - angle) * radius_1 / (angle * 10)) + ' ' + (radius_1 / 2 + (1 - angle) * radius_1 / (angle * 10)) + ' ' + 0 + ',' + 0 + ',' + direction + ' , ' + point[j + 1]['x'] + ',' + point[j + 1]['y'] + ' ';\n          pathOption = new PathOption(arcId_1, 'none', width, color, 1, dashArray, d);\n          navigationEle = this.maps.renderer.drawPath(pathOption);\n\n          if (!isNullOrUndefined(arrowPosition)) {\n            arrowPosition === 'Start' ? navigationEle.setAttribute('marker-start', startArrow) : navigationEle.setAttribute('marker-end', endArrow);\n          }\n\n          navigationGroup.appendChild(navigationEle);\n          group.appendChild(navigationGroup);\n        }\n      }\n\n      point = [];\n    }\n\n    return group;\n  };\n\n  NavigationLine.prototype.convertRadius = function (point1, point2) {\n    var value1 = point2['x'] - point1['x'];\n    var value2 = point2['y'] - point1['y'];\n    var value = Math.sqrt(Math.pow(value1, 2) + Math.pow(value2, 2));\n    return value;\n  };\n  /**\n   * Get module name.\n   */\n\n\n  NavigationLine.prototype.getModuleName = function () {\n    return 'NavigationLine';\n  };\n  /**\n   * To destroy the layers.\n   * @return {void}\n   * @private\n   */\n\n\n  NavigationLine.prototype.destroy = function (maps) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return NavigationLine;\n}();\n\nexport { NavigationLine };","map":null,"metadata":{},"sourceType":"module"}