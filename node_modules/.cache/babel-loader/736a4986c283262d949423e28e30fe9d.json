{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n/**\n * Helper functions for maps control\n */\n\n\nimport { createElement, isNullOrUndefined, remove, compile as templateComplier, merge } from '@syncfusion/ej2-base';\nimport { Animation } from '@syncfusion/ej2-base';\nimport { SvgRenderer } from '@syncfusion/ej2-svg-base';\nimport { animationComplete } from '../index';\nimport { markerClusterRendering } from '../index';\n/**\n * Maps internal use of `Size` type\n */\n\nvar Size =\n/** @class */\nfunction () {\n  function Size(width, height) {\n    this.width = width;\n    this.height = height;\n  }\n\n  return Size;\n}();\n\nexport { Size };\n/**\n * To find number from string\n * @private\n */\n\nexport function stringToNumber(value, containerSize) {\n  if (value !== null && value !== undefined) {\n    return value.indexOf('%') !== -1 ? containerSize / 100 * parseInt(value, 10) : parseInt(value, 10);\n  }\n\n  return null;\n}\n/**\n * Method to calculate the width and height of the maps\n */\n\nexport function calculateSize(maps) {\n  var containerWidth = maps.element.clientWidth;\n  var containerHeight = maps.element.clientHeight;\n  maps.availableSize = new Size(stringToNumber(maps.width, containerWidth) || containerWidth || 600, stringToNumber(maps.height, containerHeight) || containerHeight || (maps.isDevice ? Math.min(window.innerWidth, window.innerHeight) : 450));\n}\n/**\n * Method to create svg for maps.\n */\n\nexport function createSvg(maps) {\n  maps.renderer = new SvgRenderer(maps.element.id);\n  calculateSize(maps);\n  maps.svgObject = maps.renderer.createSvg({\n    id: maps.element.id + '_svg',\n    width: maps.availableSize.width,\n    height: maps.availableSize.height\n  });\n}\nexport function getMousePosition(pageX, pageY, element) {\n  var elementRect = element.getBoundingClientRect();\n  var pageXOffset = element.ownerDocument.defaultView.pageXOffset;\n  var pageYOffset = element.ownerDocument.defaultView.pageYOffset;\n  var clientTop = element.ownerDocument.documentElement.clientTop;\n  var clientLeft = element.ownerDocument.documentElement.clientLeft;\n  var positionX = elementRect.left + pageXOffset - clientLeft;\n  var positionY = elementRect.top + pageYOffset - clientTop;\n  return new MapLocation(pageX - positionX, pageY - positionY);\n}\n/**\n * Method to convert degrees to radians\n */\n\nexport function degreesToRadians(deg) {\n  return deg * (Math.PI / 180);\n}\n/**\n * Convert radians to degrees method\n */\n\nexport function radiansToDegrees(radian) {\n  return radian * (180 / Math.PI);\n}\n/**\n * Method for converting from latitude and longitude values to points\n */\n\nexport function convertGeoToPoint(latitude, longitude, factor, layer, mapModel) {\n  var mapSize = new Size(mapModel.mapAreaRect.width, mapModel.mapAreaRect.height);\n  var x;\n  var y;\n  var value;\n  var lat;\n  var lng;\n  var temp;\n  var longitudeMinMax = mapModel.baseMapBounds.longitude;\n  var latitudeMinMax = mapModel.baseMapBounds.latitude;\n  var latRadian = degreesToRadians(latitude);\n  var lngRadian = degreesToRadians(longitude);\n  var type = mapModel.projectionType;\n  var size = mapModel.isTileMap ? Math.pow(2, 1) * 256 : isNullOrUndefined(factor) ? Math.min(mapSize.width, mapSize.height) : Math.min(mapSize.width, mapSize.height) * factor;\n\n  if (layer.geometryType === 'Normal') {\n    x = isNullOrUndefined(factor) ? longitude : Math.abs((longitude - longitudeMinMax.min) * factor);\n    y = isNullOrUndefined(factor) ? latitude : Math.abs((latitudeMinMax.max - latitude) * factor);\n  } else if (layer.geometryType === 'Geographic') {\n    switch (type) {\n      case 'Mercator':\n        var pixelOrigin = new Point(size / 2, size / 2);\n        x = pixelOrigin.x + longitude * (size / 360);\n        var sinY = calculateBound(Math.sin(degreesToRadians(latitude)), -0.9999, 0.9999);\n        y = pixelOrigin.y + 0.5 * Math.log((1 + sinY) / (1 - sinY)) * -(size / (2 * Math.PI));\n        break;\n\n      case 'Winkel3':\n        value = aitoff(lngRadian, latRadian);\n        lng = (value.x + lngRadian / (Math.PI / 2)) / 2;\n        lat = (value.y + latRadian) / 2;\n        break;\n\n      case 'Miller':\n        lng = lngRadian;\n        lat = 1.25 * Math.log(Math.tan(Math.PI / 4 + .4 * latRadian));\n        break;\n\n      case 'Eckert3':\n        temp = Math.sqrt(Math.PI * (4 + Math.PI));\n        lng = 2 / temp * lngRadian * (1 + Math.sqrt(1 - 4 * latRadian * latRadian / (Math.PI * Math.PI)));\n        lat = 4 / temp * latRadian;\n        break;\n\n      case 'AitOff':\n        value = aitoff(lngRadian, latRadian);\n        lng = value.x;\n        lat = value.y;\n        break;\n\n      case 'Eckert5':\n        lng = lngRadian * (1 + Math.cos(latRadian)) / Math.sqrt(2 + Math.PI);\n        lat = 2 * latRadian / Math.sqrt(2 + Math.PI);\n        break;\n\n      case 'Equirectangular':\n        lng = lngRadian;\n        lat = latRadian;\n        break;\n\n      case 'Eckert6':\n        var epsilon = 1e-6;\n        temp = (1 + Math.PI / 2) * Math.sin(latRadian);\n        var delta = Infinity;\n\n        for (var i = 0; i < 10 && Math.abs(delta) > epsilon; i++) {\n          delta = (latRadian + Math.sin(latRadian) - temp) / (1 + Math.cos(latRadian));\n          latRadian = latRadian - delta;\n        }\n\n        temp = Math.sqrt(2 + Math.PI);\n        lng = lngRadian * (1 + Math.cos(latRadian)) / temp;\n        lat = 2 * latRadian / temp;\n        break;\n    }\n\n    x = type === 'Mercator' ? x : roundTo(xToCoordinate(mapModel, radiansToDegrees(lng)), 3);\n    y = type === 'Mercator' ? y : -roundTo(yToCoordinate(mapModel, radiansToDegrees(lat)), 3);\n  }\n\n  return new Point(x, y);\n}\n/**\n * Converting tile latitude and longitude to point\n */\n\nexport function convertTileLatLongToPoint(center, zoomLevel, tileTranslatePoint, isMapCoordinates) {\n  var size = Math.pow(2, zoomLevel) * 256;\n  var x = (center.x + 180) / 360;\n  var sinLatitude = Math.sin(center.y * Math.PI / 180);\n  var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);\n  var pixelX = center.x;\n  var pixelY = center.y;\n\n  if (isMapCoordinates) {\n    pixelX = x * size + 0.5 + tileTranslatePoint.x;\n    pixelY = y * size + 0.5 + tileTranslatePoint.y;\n  }\n\n  return {\n    x: pixelX,\n    y: pixelY\n  };\n}\n/**\n * Method for calculate x point\n */\n\nexport function xToCoordinate(mapObject, val) {\n  var longitudeMinMax = mapObject.baseMapBounds.longitude;\n  var totalSize = isNullOrUndefined(mapObject.baseSize) ? mapObject.mapAreaRect.width : mapObject.mapAreaRect.width + Math.abs(mapObject.baseSize.width - mapObject.mapAreaRect.width) / 2;\n  return Math.round(totalSize * (val - longitudeMinMax.min) / (longitudeMinMax.max - longitudeMinMax.min) * 100) / 100;\n}\n/**\n * Method for calculate y point\n */\n\nexport function yToCoordinate(mapObject, val) {\n  var latitudeMinMax = mapObject.baseMapBounds.latitude;\n  return Math.round(mapObject.mapAreaRect.height * (val - latitudeMinMax.min) / (latitudeMinMax.max - latitudeMinMax.min) * 100) / 100;\n}\n/**\n * Method for calculate aitoff projection\n */\n\nexport function aitoff(x, y) {\n  var cosy = Math.cos(y);\n  var sincia = sinci(acos(cosy * Math.cos(x /= 2)));\n  return new Point(2 * cosy * Math.sin(x) * sincia, Math.sin(y) * sincia);\n}\n/**\n * Method to round the number\n */\n\nexport function roundTo(a, b) {\n  var c = Math.pow(10, b);\n  return Math.round(a * c) / c;\n}\nexport function sinci(x) {\n  return x / Math.sin(x);\n}\nexport function acos(a) {\n  return Math.acos(a);\n}\n/**\n * Method to calculate bound\n */\n\nexport function calculateBound(value, min, max) {\n  if (!isNullOrUndefined(min)) {\n    value = Math.max(value, min);\n  }\n\n  if (!isNullOrUndefined(max)) {\n    value = Math.min(value, max);\n  }\n\n  return value;\n}\n/**\n * Map internal class for point\n */\n\nvar Point =\n/** @class */\nfunction () {\n  function Point(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  return Point;\n}();\n\nexport { Point };\n/**\n * Map internal class for min and max\n *\n */\n\nvar MinMax =\n/** @class */\nfunction () {\n  function MinMax(min, max) {\n    this.min = min;\n    this.max = max;\n  }\n\n  return MinMax;\n}();\n\nexport { MinMax };\n/**\n * Map internal class locations\n */\n\nvar GeoLocation =\n/** @class */\nfunction () {\n  function GeoLocation(latitude, longitude) {\n    this.latitude = new MinMax(latitude.min, latitude.max);\n    this.longitude = new MinMax(longitude.min, longitude.max);\n  }\n\n  return GeoLocation;\n}();\n\nexport { GeoLocation };\n/**\n * Function to measure the height and width of the text.\n * @param  {string} text\n * @param  {FontModel} font\n * @param  {string} id\n * @returns no\n * @private\n */\n\nexport function measureText(text, font) {\n  var measureObject = document.getElementById('mapsmeasuretext');\n\n  if (measureObject === null) {\n    measureObject = createElement('text', {\n      id: 'mapsmeasuretext'\n    });\n    document.body.appendChild(measureObject);\n  }\n\n  measureObject.innerHTML = text;\n  measureObject.style.position = 'absolute';\n  measureObject.style.fontSize = font.size;\n  measureObject.style.fontWeight = font.fontWeight;\n  measureObject.style.fontStyle = font.fontStyle;\n  measureObject.style.fontFamily = font.fontFamily;\n  measureObject.style.visibility = 'hidden';\n  measureObject.style.top = '-100';\n  measureObject.style.left = '0';\n  measureObject.style.whiteSpace = 'nowrap'; // For bootstrap line height issue\n\n  measureObject.style.lineHeight = 'normal';\n  return new Size(measureObject.clientWidth, measureObject.clientHeight);\n}\n/**\n * Internal use of text options\n * @private\n */\n\nvar TextOption =\n/** @class */\nfunction () {\n  function TextOption(id, x, y, anchor, text, transform, baseLine) {\n    if (transform === void 0) {\n      transform = '';\n    }\n\n    this.transform = '';\n    this.baseLine = 'auto';\n    this.id = id;\n    this.text = text;\n    this.transform = transform;\n    this.anchor = anchor;\n    this.x = x;\n    this.y = y;\n    this.baseLine = baseLine;\n  }\n\n  return TextOption;\n}();\n\nexport { TextOption };\n/**\n * Internal use of path options\n * @private\n */\n\nvar PathOption =\n/** @class */\nfunction () {\n  function PathOption(id, fill, width, color, opacity, dashArray, d) {\n    this.id = id;\n    this.opacity = opacity;\n    this.fill = fill;\n    this.stroke = color;\n    this['stroke-width'] = width;\n    this['stroke-dasharray'] = dashArray;\n    this.d = d;\n  }\n\n  return PathOption;\n}();\n\nexport { PathOption };\n/** @private */\n\nvar ColorValue =\n/** @class */\nfunction () {\n  function ColorValue(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n\n  return ColorValue;\n}();\n\nexport { ColorValue };\n/**\n * Internal use of rectangle options\n * @private\n */\n\nvar RectOption =\n/** @class */\nfunction (_super) {\n  __extends(RectOption, _super);\n\n  function RectOption(id, fill, border, opacity, rect, rx, ry, transform, dashArray) {\n    var _this = _super.call(this, id, fill, border.width, border.color, opacity, dashArray) || this;\n\n    _this.y = rect.y;\n    _this.x = rect.x;\n    _this.height = rect.height;\n    _this.width = rect.width;\n    _this.rx = rx ? rx : 0;\n    _this.ry = ry ? ry : 0;\n    _this.transform = transform ? transform : '';\n    _this['stroke-dasharray'] = dashArray;\n    return _this;\n  }\n\n  return RectOption;\n}(PathOption);\n\nexport { RectOption };\n/**\n * Internal use of circle options\n * @private\n */\n\nvar CircleOption =\n/** @class */\nfunction (_super) {\n  __extends(CircleOption, _super);\n\n  function CircleOption(id, fill, border, opacity, cx, cy, r, dashArray) {\n    var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;\n\n    _this.cy = cy;\n    _this.cx = cx;\n    _this.r = r;\n    _this['stroke-dasharray'] = dashArray;\n    return _this;\n  }\n\n  return CircleOption;\n}(PathOption);\n\nexport { CircleOption };\n/**\n * Internal use of polygon options\n * @private\n */\n\nvar PolygonOption =\n/** @class */\nfunction (_super) {\n  __extends(PolygonOption, _super);\n\n  function PolygonOption(id, points, fill, width, color, opacity, dashArray) {\n    if (opacity === void 0) {\n      opacity = 1;\n    }\n\n    if (dashArray === void 0) {\n      dashArray = '';\n    }\n\n    var _this = _super.call(this, id, fill, width, color, opacity, dashArray) || this;\n\n    _this.points = points;\n    return _this;\n  }\n\n  return PolygonOption;\n}(PathOption);\n\nexport { PolygonOption };\n/**\n * Internal use of polyline options\n * @private\n */\n\nvar PolylineOption =\n/** @class */\nfunction (_super) {\n  __extends(PolylineOption, _super);\n\n  function PolylineOption(id, points, fill, width, color, opacity, dashArray) {\n    if (opacity === void 0) {\n      opacity = 1;\n    }\n\n    if (dashArray === void 0) {\n      dashArray = '';\n    }\n\n    return _super.call(this, id, points, fill, width, color, opacity, dashArray) || this;\n  }\n\n  return PolylineOption;\n}(PolygonOption);\n\nexport { PolylineOption };\n/**\n * Internal use of line options\n * @private\n */\n\nvar LineOption =\n/** @class */\nfunction (_super) {\n  __extends(LineOption, _super);\n\n  function LineOption(id, line, fill, width, color, opacity, dashArray) {\n    if (opacity === void 0) {\n      opacity = 1;\n    }\n\n    if (dashArray === void 0) {\n      dashArray = '';\n    }\n\n    var _this = _super.call(this, id, fill, width, color, opacity, dashArray) || this;\n\n    _this.x1 = line.x1;\n    _this.y1 = line.y1;\n    _this.x2 = line.x2;\n    _this.y2 = line.y2;\n    return _this;\n  }\n\n  return LineOption;\n}(PathOption);\n\nexport { LineOption };\n/**\n * Internal use of line\n * @property\n */\n\nvar Line =\n/** @class */\nfunction () {\n  function Line(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  return Line;\n}();\n\nexport { Line };\n/**\n * Internal use of map location type\n */\n\nvar MapLocation =\n/** @class */\nfunction () {\n  function MapLocation(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  return MapLocation;\n}();\n\nexport { MapLocation };\n/**\n * Internal use of type rect\n * @private\n */\n\nvar Rect =\n/** @class */\nfunction () {\n  function Rect(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  return Rect;\n}();\n\nexport { Rect };\n/**\n * Internal use for pattern creation.\n * @property\n */\n\nvar PatternOptions =\n/** @class */\nfunction () {\n  function PatternOptions(id, x, y, width, height, patternUnits, patternContentUnits, patternTransform, href) {\n    if (patternUnits === void 0) {\n      patternUnits = 'userSpaceOnUse';\n    }\n\n    if (patternContentUnits === void 0) {\n      patternContentUnits = 'userSpaceOnUse';\n    }\n\n    if (patternTransform === void 0) {\n      patternTransform = '';\n    }\n\n    if (href === void 0) {\n      href = '';\n    }\n\n    this.id = id;\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.patternUnits = patternUnits;\n    this.patternContentUnits = patternContentUnits;\n    this.patternTransform = patternTransform;\n    this.href = href;\n  }\n\n  return PatternOptions;\n}();\n\nexport { PatternOptions };\n/**\n * Internal rendering of text\n * @private\n */\n\nexport function renderTextElement(option, style, color, parent, isMinus) {\n  if (isMinus === void 0) {\n    isMinus = false;\n  }\n\n  var renderOptions = {\n    'id': option.id,\n    'x': option.x,\n    'y': option.y,\n    'fill': color,\n    'font-size': style.size,\n    'font-style': style.fontStyle,\n    'font-family': style.fontFamily,\n    'font-weight': style.fontWeight,\n    'text-anchor': option.anchor,\n    'transform': option.transform,\n    'opacity': style.opacity,\n    'dominant-baseline': option.baseLine\n  };\n  var text = typeof option.text === 'string' ? option.text : isMinus ? option.text[option.text.length - 1] : option.text[0];\n  var tspanElement;\n  var renderer = new SvgRenderer('');\n  var height;\n  var htmlObject = renderer.createText(renderOptions, text);\n  htmlObject.style['user-select'] = 'none';\n  htmlObject.style['-moz-user-select'] = 'none';\n  htmlObject.style['-webkit-touch-callout'] = 'none';\n  htmlObject.style['-webkit-user-select'] = 'none';\n  htmlObject.style['-khtml-user-select'] = 'none';\n  htmlObject.style['-ms-user-select'] = 'none';\n  htmlObject.style['-o-user-select'] = 'none';\n\n  if (typeof option.text !== 'string' && option.text.length > 1) {\n    for (var i = 1, len = option.text.length; i < len; i++) {\n      height = measureText(option.text[i], style).height;\n      tspanElement = renderer.createTSpan({\n        'x': option.x,\n        'id': option.id,\n        'y': option.y + (isMinus ? -(i * height) : i * height)\n      }, isMinus ? option.text[option.text.length - (i + 1)] : option.text[i]);\n      htmlObject.appendChild(tspanElement);\n    }\n  }\n\n  parent.appendChild(htmlObject);\n  return htmlObject;\n}\n/**\n * @private\n */\n\nexport function convertElement(element, markerId, data, index, mapObj) {\n  var childElement = createElement('div', {\n    id: markerId,\n    styles: 'position: absolute;pointer-events: auto;'\n  });\n  var elementLength = element.length;\n\n  while (elementLength > 0) {\n    childElement.appendChild(element[0]);\n    elementLength--;\n  }\n\n  var templateHtml = childElement.innerHTML;\n  var properties = Object.keys(data);\n\n  for (var i = 0; i < properties.length; i++) {\n    if (properties[i].toLowerCase() !== 'latitude' && properties[i].toLowerCase() !== 'longitude') {\n      templateHtml = templateHtml.replace(new RegExp('{{:' + properties[i] + '}}', 'g'), data[properties[i].toString()]);\n    }\n  }\n\n  childElement.innerHTML = templateHtml;\n  return childElement;\n}\nexport function convertElementFromLabel(element, labelId, data, index, mapObj) {\n  var labelEle = isNullOrUndefined(element.childElementCount) ? element[0] : element;\n  var templateHtml = labelEle.outerHTML;\n  var properties = Object.keys(data);\n\n  for (var i = 0; i < properties.length; i++) {\n    templateHtml = templateHtml.replace(new RegExp('{{:' + properties[i] + '}}', 'g'), data[properties[i].toString()]);\n  }\n\n  return createElement('div', {\n    id: labelId,\n    innerHTML: templateHtml,\n    styles: 'position: absolute'\n  });\n}\n/* tslint:disable:no-string-literal */\n//tslint:disable\n\nexport function drawSymbols(shape, imageUrl, location, markerID, shapeCustom, markerCollection, maps) {\n  var markerEle;\n  var x;\n  var y;\n  var size = shapeCustom['size'];\n  var borderColor = shapeCustom['borderColor'];\n  var borderWidth = parseFloat(shapeCustom['borderWidth']);\n  var fill = shapeCustom['fill'];\n  var dashArray = shapeCustom['dashArray'];\n  var border = {\n    color: borderColor,\n    width: borderWidth\n  };\n  var opacity = shapeCustom['opacity'];\n  var circleOptions;\n  var pathOptions;\n  var rectOptions;\n  pathOptions = new PathOption(markerID, fill, borderWidth, borderColor, opacity, dashArray, '');\n\n  if (shape === 'Circle') {\n    var radius = (size.width + size.height) / 4;\n    circleOptions = new CircleOption(markerID, fill, border, opacity, location.x, location.y, radius, dashArray);\n    markerEle = maps.renderer.drawCircle(circleOptions);\n  } else if (shape === 'Rectangle') {\n    x = location.x - size.width / 2;\n    y = location.y - size.height / 2;\n    rectOptions = new RectOption(markerID, fill, border, opacity, new Rect(x, y, size.width, size.height), null, null, '', dashArray);\n    markerEle = maps.renderer.drawRectangle(rectOptions);\n  } else if (shape === 'Image') {\n    x = location.x - size.width / 2;\n    y = location.y - size.height;\n    merge(pathOptions, {\n      'href': imageUrl,\n      'height': size.height,\n      'width': size.width,\n      x: x,\n      y: y\n    });\n    markerEle = maps.renderer.drawImage(pathOptions);\n  } else {\n    markerEle = calculateShapes(maps, shape, pathOptions, size, location, markerCollection);\n  }\n\n  return markerEle;\n} //tslint:disable\n\nexport function clusterTemplate(currentLayer, markerTemplate, maps, layerIndex, markerCollection) {\n  var bounds = [];\n  var colloideBounds = [];\n  var tempX = 0;\n  var tempY = 0;\n  var data;\n  var style = currentLayer.markerClusterSettings.labelStyle;\n  var options;\n  var textElement;\n  var postionY = 15 / 4;\n  var m = 0;\n  var g = maps.renderer.createGroup({\n    id: maps.element.id + '_LayerIndex_' + layerIndex + '_markerCluster'\n  });\n\n  for (var n = 0; n < markerTemplate.childElementCount; n++) {\n    var tempElement = markerTemplate.childNodes[n];\n    bounds.push(tempElement.getBoundingClientRect());\n  }\n\n  var _loop_1 = function (o) {\n    if (!isNullOrUndefined(bounds[o])) {\n      for (var p = o + 1; p < bounds.length; p++) {\n        if (!isNullOrUndefined(bounds[p])) {\n          if (bounds[o].left > bounds[p].right || bounds[o].right < bounds[p].left || bounds[o].top > bounds[p].bottom || bounds[o].bottom < bounds[p].top) {} else {\n            colloideBounds.push(bounds[p]);\n          }\n        }\n      }\n\n      tempX = bounds[o].left;\n      tempY = bounds[o].top;\n\n      for (var q = 0; q < colloideBounds.length; q++) {\n        for (var k = 0; k < bounds.length; k++) {\n          if (!isNullOrUndefined(bounds[k])) {\n            if (colloideBounds[q]['left'] === bounds[k]['left']) {\n              delete bounds[k];\n\n              for (var r = 0; r < markerTemplate.childElementCount; r++) {\n                var tempElement = markerTemplate.childNodes[r];\n\n                if (colloideBounds[q]['left'] === tempElement.getBoundingClientRect()['left']) {\n                  markerTemplate.childNodes[r]['style']['visibility'] = \"hidden\";\n                  markerTemplate.childNodes[o]['style']['visibility'] = \"hidden\";\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (colloideBounds.length > 0) {\n        var padding = 10;\n        var container = maps.element.getBoundingClientRect();\n        tempX = Math.abs(container['left'] - tempX) + padding;\n        tempY = Math.abs(container['top'] - tempY) + padding;\n        var translate = maps.isTileMap ? new Object() : getTranslate(maps, currentLayer, false);\n        var transPoint_1 = maps.isTileMap ? {\n          x: 0,\n          y: 0\n        } : maps.translatePoint.x !== 0 ? maps.translatePoint : translate['location'];\n        var dataIndex_1 = parseInt(markerTemplate.childNodes[o]['id'].split('_dataIndex_')[1].split('_')[0], 10);\n        var markerIndex_1 = parseInt(markerTemplate.childNodes[o]['id'].split('_MarkerIndex_')[1].split('_')[0], 10);\n        var clusters = currentLayer.markerClusterSettings;\n        var shapeCustom_1 = {\n          size: new Size(clusters.width, clusters.height),\n          fill: clusters.fill,\n          borderColor: clusters.border.color,\n          borderWidth: clusters.border.width,\n          opacity: clusters.opacity,\n          dashArray: clusters.dashArray\n        };\n        var eventArg_1 = {\n          cancel: false,\n          name: markerClusterRendering,\n          fill: clusters.fill,\n          height: clusters.height,\n          width: clusters.width,\n          imageUrl: clusters.imageUrl,\n          shape: clusters.shape,\n          data: data,\n          maps: maps,\n          cluster: clusters,\n          border: clusters.border\n        };\n\n        if (maps.isBlazor) {\n          var data_1 = eventArg_1.data,\n              maps_1 = eventArg_1.maps,\n              cluster = eventArg_1.cluster,\n              blazorEventArgs = __rest(eventArg_1, [\"data\", \"maps\", \"cluster\"]);\n\n          eventArg_1 = blazorEventArgs;\n        }\n\n        shapeCustom_1['fill'] = eventArg_1.fill;\n        shapeCustom_1['size']['width'] = eventArg_1.width;\n        shapeCustom_1['size']['height'] = eventArg_1.height;\n        shapeCustom_1['imageUrl'] = eventArg_1.imageUrl;\n        shapeCustom_1['shape'] = eventArg_1.shape;\n        shapeCustom_1['borderColor'] = eventArg_1.border.color;\n        shapeCustom_1['borderWidth'] = eventArg_1.border.width;\n        maps.trigger('markerClusterRendering', eventArg_1, function (clusterargs) {\n          tempX = maps.isTileMap ? tempX : markerTemplate.id.indexOf('_Markers_Group') > -1 ? tempX : (tempX + transPoint_1.x) * maps.mapScaleValue;\n          tempY = maps.isTileMap ? tempY : markerTemplate.id.indexOf('_Markers_Group') > -1 ? tempY : (tempY + transPoint_1.y) * maps.mapScaleValue;\n          var clusterID = maps.element.id + '_LayerIndex_' + layerIndex + '_MarkerIndex_' + markerIndex_1 + '_dataIndex_' + dataIndex_1 + '_cluster_' + m;\n          var labelID = maps.element.id + '_LayerIndex_' + layerIndex + '_MarkerIndex_' + markerIndex_1 + '_dataIndex_' + dataIndex_1 + '_cluster_' + m + '_datalabel_' + m;\n          m++;\n          var ele = drawSymbols(eventArg_1.shape, eventArg_1.imageUrl, {\n            x: 0,\n            y: 0\n          }, clusterID, shapeCustom_1, markerCollection, maps);\n          ele.setAttribute('transform', 'translate( ' + tempX + ' ' + tempY + ' )');\n          options = new TextOption(labelID, 0, postionY, 'middle', (colloideBounds.length + 1).toString(), '', '');\n          textElement = renderTextElement(options, style, style.color, markerCollection);\n          textElement.setAttribute('transform', 'translate( ' + tempX + ' ' + tempY + ' )');\n          g.appendChild(textElement);\n          g.appendChild(ele);\n        });\n      }\n    }\n\n    colloideBounds = [];\n  };\n\n  for (var o = 0; o < bounds.length; o++) {\n    _loop_1(o);\n  }\n\n  while (0 < g.childNodes.length) {\n    markerCollection.insertBefore(g.childNodes[0], markerCollection.firstChild);\n  }\n\n  return markerTemplate;\n}\nexport function mergeSeparateCluster(sameMarkerData, maps, markerElement) {\n  var markerId = maps.element.id + '_LayerIndex_' + sameMarkerData[0].layerIndex + '_MarkerIndex_' + sameMarkerData[0].markerIndex;\n  var clusterId = markerId + '_dataIndex_' + sameMarkerData[0].data[0]['index'] + '_cluster_' + sameMarkerData[0].targetClusterIndex;\n  var clusterEle = getElement(clusterId);\n  var clusterEleLabel = getElement(clusterId + '_datalabel_' + sameMarkerData[0].targetClusterIndex);\n  clusterEle.setAttribute('visibility', 'visible');\n  clusterEleLabel.setAttribute('visibility', 'visible');\n  var markerEle;\n\n  for (var i = 0; i < sameMarkerData[0].data.length; i++) {\n    markerEle = getElement(markerId + '_dataIndex_' + sameMarkerData[0].data[i]['index']);\n    markerEle['style']['visibility'] = \"hidden\";\n  }\n\n  removeElement(maps.element.id + '_LayerIndex_' + sameMarkerData[0].layerIndex + '_MarkerIndex_' + sameMarkerData[0].markerIndex + '_markerClusterConnectorLine');\n}\nexport function clusterSeparate(sameMarkerData, maps, markerElement, isDom) {\n  var getElementFunction = isDom ? getElement : markerElement.querySelector.bind(markerElement);\n  var getQueryConnect = isDom ? '' : '#';\n  var markerId = maps.element.id + '_LayerIndex_' + sameMarkerData[0].layerIndex + '_MarkerIndex_' + sameMarkerData[0].markerIndex;\n  var clusterId = markerId + '_dataIndex_' + sameMarkerData[0].data[0]['index'] + '_cluster_' + sameMarkerData[0].targetClusterIndex;\n  var clusterEle = getElementFunction(getQueryConnect + '' + clusterId);\n  var clusterEleLabel = getElementFunction(getQueryConnect + '' + clusterId + '_datalabel_' + sameMarkerData[0].targetClusterIndex);\n  clusterEle.setAttribute('visibility', 'hidden');\n  clusterEleLabel.setAttribute('visibility', 'hidden');\n  var markerEle = getElementFunction(getQueryConnect + '' + markerId + '_dataIndex_' + sameMarkerData[0].data[0]['index']);\n  var height = maps.layers[sameMarkerData[0].layerIndex].markerSettings[sameMarkerData[0].markerIndex].height;\n  var width = maps.layers[sameMarkerData[0].layerIndex].markerSettings[sameMarkerData[0].markerIndex].width;\n  var centerX = +clusterEle.getAttribute('transform').split('translate(')[1].trim().split(' ')[0];\n  var centerY = +clusterEle.getAttribute('transform').split('translate(')[1].trim().split(' ')[1].split(')')[0].trim() + height / 2;\n  var radius = width + 5;\n  var area = 2 * 3.14 * radius;\n  var totalMarker = 0;\n  var numberOfMarker = Math.round(area / width);\n  totalMarker += numberOfMarker;\n  var percent = Math.round(height / area * 100);\n  percent = sameMarkerData[0].data.length < numberOfMarker ? 100 / sameMarkerData[0].data.length : percent;\n  var angle = percent / 100 * 360;\n  var newAngle = sameMarkerData[0].data.length < numberOfMarker ? 45 : 0;\n  var count = 1;\n  var start = 'M ' + centerX + ' ' + centerY + ' ';\n  var path = '';\n\n  for (var i = 0; i < sameMarkerData[0].data.length; i++) {\n    if (totalMarker === i || Math.round(newAngle) >= 360) {\n      count++;\n      radius = (width + 5) * count;\n      newAngle = 0;\n      area = 2 * 3.14 * radius;\n      numberOfMarker = Math.round(area / height);\n      percent = Math.round(height / area * 100);\n\n      while (percent * numberOfMarker < 100) {\n        numberOfMarker++;\n      }\n\n      angle = percent / 100 * 360;\n      totalMarker += numberOfMarker;\n    }\n\n    var x1 = centerX + radius * Math.sin(Math.PI * 2 * newAngle / 360);\n    var y1 = centerY + radius * Math.cos(Math.PI * 2 * newAngle / 360);\n    path += start + 'L ' + (x1 + 2) + ' ' + y1 + ' ';\n    markerEle = getElementFunction(getQueryConnect + '' + markerId + '_dataIndex_' + sameMarkerData[0].data[i]['index']);\n    markerEle.setAttribute('transform', 'translate( ' + x1 + ' ' + y1 + ')');\n    markerEle['style']['visibility'] = \"visible\";\n    newAngle += angle;\n  }\n\n  var options;\n  options = {\n    d: path,\n    id: maps.element.id + '_markerClusterConnectorLine',\n    stroke: maps.layers[sameMarkerData[0].layerIndex].markerClusterSettings.connectorLineSettings.color,\n    opacity: maps.layers[sameMarkerData[0].layerIndex].markerClusterSettings.connectorLineSettings.opacity,\n    'stroke-width': maps.layers[sameMarkerData[0].layerIndex].markerClusterSettings.connectorLineSettings.width\n  };\n  markerElement = isDom ? getElementFunction(maps.element.id + '_Markers_Group') : markerElement;\n  var groupEle = maps.renderer.createGroup({\n    id: maps.element.id + '_LayerIndex_' + sameMarkerData[0].layerIndex + '_MarkerIndex_' + sameMarkerData[0].markerIndex + '_markerClusterConnectorLine'\n  });\n  groupEle.appendChild(maps.renderer.drawPath(options));\n  markerElement.insertBefore(groupEle, markerElement.querySelector('#' + markerId + '_dataIndex_0'));\n}\nexport function marker(eventArgs, markerSettings, markerData, dataIndex, location, transPoint, markerID, offset, scale, maps, markerCollection) {\n  var shapeCustom = {\n    size: new Size(eventArgs.width, eventArgs.height),\n    fill: eventArgs.fill,\n    borderColor: eventArgs.border.color,\n    borderWidth: eventArgs.border.width,\n    opacity: markerSettings.opacity,\n    dashArray: markerSettings.dashArray\n  };\n  var ele = drawSymbols(eventArgs.shape, eventArgs.imageUrl, {\n    x: 0,\n    y: 0\n  }, markerID, shapeCustom, markerCollection, maps);\n  var x = (maps.isTileMap ? location.x : (location.x + transPoint.x) * scale) + offset.x;\n  var y = (maps.isTileMap ? location.y : (location.y + transPoint.y) * scale) + offset.y;\n  ele.setAttribute('transform', 'translate( ' + x + ' ' + y + ' )');\n  markerCollection.appendChild(ele);\n  var element = markerData.length - 1 === dataIndex ? 'marker' : null;\n  var markerPoint = new Point(x, y);\n\n  if (markerSettings.animationDuration > 0) {\n    elementAnimate(ele, markerSettings.animationDelay, markerSettings.animationDuration, markerPoint, maps, element);\n  }\n\n  return markerCollection;\n}\nexport function markerTemplate(eventArgs, templateFn, markerID, data, markerIndex, markerTemplate, location, scale, offset, maps) {\n  templateFn = getTemplateFunction(eventArgs.template);\n\n  if (templateFn && (!maps.isBlazor ? templateFn(data, null, null, maps.element.id + '_MarkerTemplate', false).length : {})) {\n    var templateElement = templateFn(data, null, null, maps.element.id + '_MarkerTemplate', false);\n    var markerElement = convertElement(templateElement, markerID, data, markerIndex, maps);\n\n    for (var i = 0; i < markerElement.children.length; i++) {\n      markerElement.children[i].style.pointerEvents = 'none';\n    }\n\n    markerElement.style.left = (maps.isTileMap ? location.x : Math.abs(maps.baseMapRectBounds['min']['x'] - location.x) * scale) + offset.x + 'px';\n    markerElement.style.top = (maps.isTileMap ? location.y : Math.abs(maps.baseMapRectBounds['min']['y'] - location.y) * scale) + offset.y + 'px';\n    markerTemplate.appendChild(markerElement);\n  }\n\n  return markerTemplate;\n}\n/**\n * Internal use of append shape element\n * @private\n */\n\nexport function appendShape(shape, element) {\n  if (element) {\n    element.appendChild(shape);\n  }\n\n  return shape;\n}\n/**\n * Internal rendering of Circle\n * @private\n */\n\nexport function drawCircle(maps, options, element) {\n  return appendShape(maps.renderer.drawCircle(options), element);\n}\n/**\n * Internal rendering of Rectangle\n * @private\n */\n\nexport function drawRectangle(maps, options, element) {\n  return appendShape(maps.renderer.drawRectangle(options), element);\n}\n/**\n * Internal rendering of Path\n * @private\n */\n\nexport function drawPath(maps, options, element) {\n  return appendShape(maps.renderer.drawPath(options), element);\n}\n/**\n * Internal rendering of Polygon\n * @private\n */\n\nexport function drawPolygon(maps, options, element) {\n  return appendShape(maps.renderer.drawPolygon(options), element);\n}\n/**\n * Internal rendering of Polyline\n * @private\n */\n\nexport function drawPolyline(maps, options, element) {\n  return appendShape(maps.renderer.drawPolyline(options), element);\n}\n/**\n * Internal rendering of Line\n * @private\n */\n\nexport function drawLine(maps, options, element) {\n  return appendShape(maps.renderer.drawLine(options), element);\n}\n/**\n * @private\n * Calculate marker shapes\n */\n\nexport function calculateShapes(maps, shape, options, size, location, markerEle) {\n  var tempGroup;\n\n  switch (shape) {\n    case 'Balloon':\n      tempGroup = drawBalloon(maps, options, size, location, markerEle);\n      break;\n\n    case 'Cross':\n      options.d = 'M ' + location.x + ' ' + (location.y - size.height / 2) + ' L ' + location.x + ' ' + (location.y + size.height / 2) + ' M ' + (location.x - size.width / 2) + ' ' + location.y + ' L ' + (location.x + size.width / 2) + ' ' + location.y;\n      break;\n\n    case 'Diamond':\n      options.d = 'M ' + location.x + ' ' + (location.y - size.height / 2) + ' L ' + (location.x + size.width / 2) + ' ' + location.y + ' L ' + location.x + ' ' + (location.y + size.height / 2) + ' L ' + (location.x - size.width / 2) + ' ' + location.y + ' Z';\n      break;\n\n    case 'Star':\n      options.d = 'M ' + (location.x + size.width / 3) + ' ' + (location.y - size.height / 2) + ' L ' + (location.x - size.width / 2) + ' ' + (location.y + size.height / 6) + ' L ' + (location.x + size.width / 2) + ' ' + (location.y + size.height / 6) + ' L ' + (location.x - size.width / 3) + ' ' + (location.y - size.height / 2) + ' L ' + location.x + ' ' + (location.y + size.height / 2) + ' L ' + (location.x + size.width / 3) + ' ' + (location.y - size.height / 2) + ' Z';\n      break;\n\n    case 'Triangle':\n      options.d = 'M ' + location.x + ' ' + (location.y - size.height / 2) + ' L ' + (location.x + size.width / 2) + ' ' + (location.y + size.height / 2) + ' L ' + (location.x - size.width / 2) + ' ' + (location.y + size.height / 2) + ' Z';\n      break;\n\n    case 'HorizontalLine':\n      options.d = ' M ' + (location.x - size.width / 2) + ' ' + location.y + ' L ' + (location.x + size.width / 2) + ' ' + location.y;\n      break;\n\n    case 'VerticalLine':\n      options.d = 'M ' + location.x + ' ' + (location.y - size.height / 2) + ' L ' + location.x + ' ' + (location.y + size.height / 2);\n      break;\n  }\n\n  return shape === 'Balloon' ? tempGroup : maps.renderer.drawPath(options);\n}\n/**\n * Internal rendering of Diamond\n * @private\n */\n\nexport function drawDiamond(maps, options, size, location, element) {\n  options.d = 'M ' + location.x + ' ' + (location.y - size.height / 2) + ' L ' + (location.x + size.width / 2) + ' ' + location.y + ' L ' + location.x + ' ' + (location.y + size.height / 2) + ' L ' + (location.x - size.width / 2) + ' ' + location.y + ' Z';\n  return appendShape(maps.renderer.drawPath(options), element);\n}\n/**\n * Internal rendering of Triangle\n * @private\n */\n\nexport function drawTriangle(maps, options, size, location, element) {\n  options.d = 'M ' + location.x + ' ' + (location.y - size.height / 2) + ' L ' + (location.x + size.width / 2) + ' ' + (location.y + size.height / 2) + ' L ' + (location.x - size.width / 2) + ' ' + (location.y + size.height / 2) + ' Z';\n  return appendShape(maps.renderer.drawPath(options), element);\n}\n/**\n * Internal rendering of Cross\n * @private\n */\n\nexport function drawCross(maps, options, size, location, element) {\n  options.d = 'M ' + location.x + ' ' + (location.y - size.height / 2) + ' L ' + location.x + ' ' + (location.y + size.height / 2) + ' M ' + (location.x - size.width / 2) + ' ' + location.y + ' L ' + (location.x + size.width / 2) + ' ' + location.y;\n  return appendShape(maps.renderer.drawPath(options), element);\n}\n/**\n * Internal rendering of HorizontalLine\n * @private\n */\n\nexport function drawHorizontalLine(maps, options, size, location, element) {\n  options.d = ' M ' + (location.x - size.width / 2) + ' ' + location.y + ' L ' + (location.x + size.width / 2) + ' ' + location.y;\n  return appendShape(maps.renderer.drawPath(options), element);\n}\n/**\n * Internal rendering of VerticalLine\n * @private\n */\n\nexport function drawVerticalLine(maps, options, size, location, element) {\n  options.d = 'M ' + location.x + ' ' + (location.y - size.height / 2) + ' L ' + location.x + ' ' + (location.y + size.height / 2);\n  return appendShape(maps.renderer.drawPath(options), element);\n}\n/**\n * Internal rendering of Star\n * @private\n */\n\nexport function drawStar(maps, options, size, location, element) {\n  options.d = 'M ' + (location.x + size.width / 3) + ' ' + (location.y - size.height / 2) + ' L ' + (location.x - size.width / 2) + ' ' + (location.y + size.height / 6) + ' L ' + (location.x + size.width / 2) + ' ' + (location.y + size.height / 6) + ' L ' + (location.x - size.width / 3) + ' ' + (location.y - size.height / 2) + ' L ' + location.x + ' ' + (location.y + size.height / 2) + ' L ' + (location.x + size.width / 3) + ' ' + (location.y - size.height / 2) + ' Z';\n  return appendShape(maps.renderer.drawPath(options), element);\n}\n/**\n * Internal rendering of Balloon\n * @private\n */\n\nexport function drawBalloon(maps, options, size, location, element) {\n  var width = size.width;\n  var height = size.height;\n  var padding = 5;\n  location.x -= width / 2;\n  location.y -= height;\n  options.d = 'M15,0C8.8,0,3.8,5,3.8,11.2C3.8,17.5,9.4,24.4,15,30c5.6-5.6,11.2-12.5,11.2-18.8C26.2,5,21.2,0,15,0z M15,16' + 'c-2.8,0-5-2.2-5-5s2.2-5,5-5s5,2.2,5,5S17.8,16,15,16z';\n  var balloon = maps.renderer.drawPath(options);\n  var x = size.width / 22.5;\n  var y = size.height / 30;\n  balloon.setAttribute('transform', 'translate(' + location.x + ', ' + location.y + ') scale(' + x + ', ' + y + ')');\n  var g = maps.renderer.createGroup({\n    id: options.id\n  });\n  appendShape(balloon, g);\n  return appendShape(g, element);\n}\n/**\n * Internal rendering of Pattern\n * @private\n */\n\nexport function drawPattern(maps, options, elements, element) {\n  var pattern = maps.renderer.createPattern(options, 'pattern');\n\n  for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n    var ele = elements_1[_i];\n    appendShape(ele, pattern);\n  }\n\n  return appendShape(pattern, element);\n}\n/**\n * Method to get specific field and vaues from data.\n * @private\n */\n// tslint:disable:no-any\n\nexport function getFieldData(dataSource, fields) {\n  var newData = [];\n  var data;\n\n  for (var _i = 0, dataSource_1 = dataSource; _i < dataSource_1.length; _i++) {\n    var temp = dataSource_1[_i];\n    data = {};\n\n    for (var _a = 0, fields_1 = fields; _a < fields_1.length; _a++) {\n      var field = fields_1[_a];\n\n      if (temp[field]) {\n        data[field] = temp[field];\n      }\n    }\n\n    newData.push(data);\n  }\n\n  return newData;\n}\n/**\n * To find the index of dataSource from shape properties\n */\n// tslint:disable:no-string-literal\n\nexport function checkShapeDataFields(dataSource, properties, dataPath, propertyPath) {\n  if (!isNullOrUndefined(properties)) {\n    for (var i = 0; i < dataSource.length; i++) {\n      var shapePath = checkPropertyPath(dataSource[i][dataPath], propertyPath, properties);\n\n      if (dataSource[i][dataPath] === properties[shapePath]) {\n        return i;\n      }\n    }\n  }\n\n  return null;\n}\nexport function checkPropertyPath(shapeData, shapePropertyPath, shape) {\n  if (!isNullOrUndefined(shapeData) && !isNullOrUndefined(shape)) {\n    if (!isNullOrUndefined(shapePropertyPath)) {\n      var length_1;\n      var properties = Object.prototype.toString.call(shapePropertyPath) === '[object Array]' ? shapePropertyPath : [shapePropertyPath];\n\n      for (var i = 0; i < properties.length; i++) {\n        if (shapeData === shape[properties[i]]) {\n          return properties[i];\n        }\n      }\n    }\n  }\n\n  return null;\n}\nexport function filter(points, start, end) {\n  var pointObject = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n\n    if (start <= point.y && end >= point.y) {\n      pointObject.push(point);\n    }\n  }\n\n  return pointObject;\n}\nexport function getRatioOfBubble(min, max, value, minValue, maxValue) {\n  var percent = 100 / (maxValue - minValue) * (value - minValue);\n  var bubbleRadius = (max - min) / 100 * percent + min;\n\n  if (maxValue === minValue) {\n    bubbleRadius = (max - min) / 100 + min;\n  }\n\n  return bubbleRadius;\n}\n/**\n * To find the midpoint of the polygon from points\n */\n\nexport function findMidPointOfPolygon(points, type) {\n  if (!points.length) {\n    return null;\n  }\n\n  var min = 0;\n  var max = points.length;\n  var startX;\n  var startY;\n  var startX1;\n  var startY1;\n  var sum = 0;\n  var xSum = 0;\n  var ySum = 0;\n\n  for (var i = min; i <= max - 1; i++) {\n    startX = points[i].x;\n    startY = type === 'Mercator' ? points[i].y : -points[i].y;\n\n    if (i === max - 1) {\n      startX1 = points[0].x;\n      startY1 = type === 'Mercator' ? points[0].y : -points[0].y;\n    } else {\n      startX1 = points[i + 1].x;\n      startY1 = type === 'Mercator' ? points[i + 1].y : -points[i + 1].y;\n    }\n\n    sum = sum + Math.abs(startX * startY1 - startX1 * startY);\n    xSum = xSum + Math.abs((startX + startX1) * (startX * startY1 - startX1 * startY));\n    ySum = ySum + Math.abs((startY + startY1) * (startX * startY1 - startX1 * startY));\n  }\n\n  sum = 0.5 * sum;\n  xSum = 1 / (4 * sum) * xSum;\n  ySum = 1 / (4 * sum) * ySum;\n  /* Code for finding nearest points in polygon related to midPoint*/\n\n  var rightMinPoint = {\n    x: 0,\n    y: 0\n  };\n  var rightMaxPoint = {\n    x: 0,\n    y: 0\n  };\n  var leftMinPoint = {\n    x: 0,\n    y: 0\n  };\n  var leftMaxPoint = {\n    x: 0,\n    y: 0\n  };\n  var bottomMinPoint = {\n    x: 0,\n    y: 0\n  };\n  var bottomMaxPoint = {\n    x: 0,\n    y: 0\n  };\n  var topMinPoint = {\n    x: 0,\n    y: 0\n  };\n  var topMaxPoint = {\n    x: 0,\n    y: 0\n  };\n  var height = 0;\n\n  for (var i = min; i <= max - 1; i++) {\n    var point = points[i];\n    point.y = type === 'Mercator' ? point.y : -point.y;\n\n    if (point.y > ySum) {\n      if (point.x < xSum && xSum - point.x < xSum - bottomMinPoint.x) {\n        bottomMinPoint = {\n          x: point.x,\n          y: point.y\n        };\n      } else if (point.x > xSum && (bottomMaxPoint.x === 0 || point.x - xSum < bottomMaxPoint.x - xSum)) {\n        bottomMaxPoint = {\n          x: point.x,\n          y: point.y\n        };\n      }\n    } else {\n      if (point.x < xSum && xSum - point.x < xSum - topMinPoint.x) {\n        topMinPoint = {\n          x: point.x,\n          y: point.y\n        };\n      } else if (point.x > xSum && (topMaxPoint.x === 0 || point.x - xSum < topMaxPoint.x - xSum)) {\n        topMaxPoint = {\n          x: point.x,\n          y: point.y\n        };\n      }\n    }\n\n    height = bottomMaxPoint.y - topMaxPoint.y + (bottomMaxPoint.y - topMaxPoint.y) / 4;\n\n    if (point.x > xSum) {\n      if (point.y < ySum && ySum - point.y < ySum - rightMinPoint.y) {\n        rightMinPoint = {\n          x: point.x,\n          y: point.y\n        };\n      } else if (point.y > ySum && (rightMaxPoint.y === 0 || point.y - ySum < rightMaxPoint.y - ySum)) {\n        rightMaxPoint = {\n          x: point.x,\n          y: point.y\n        };\n      }\n    } else {\n      if (point.y < ySum && ySum - point.y < ySum - leftMinPoint.y) {\n        leftMinPoint = {\n          x: point.x,\n          y: point.y\n        };\n      } else if (point.y > ySum && (leftMaxPoint.y === 0 || point.y - ySum < leftMaxPoint.y - ySum)) {\n        leftMaxPoint = {\n          x: point.x,\n          y: point.y\n        };\n      }\n    }\n  }\n\n  return {\n    x: xSum,\n    y: ySum,\n    rightMin: rightMinPoint,\n    rightMax: rightMaxPoint,\n    leftMin: leftMinPoint,\n    leftMax: leftMaxPoint,\n    points: points,\n    topMax: topMaxPoint,\n    topMin: topMinPoint,\n    bottomMax: bottomMaxPoint,\n    bottomMin: bottomMinPoint,\n    height: height\n  };\n}\n/**\n * @private\n * Check custom path\n */\n\n/* tslint:disable:no-string-literal */\n\nexport function isCustomPath(layerData) {\n  var customPath = false;\n\n  if (Object.prototype.toString.call(layerData) === '[object Array]') {\n    layerData.forEach(function (layer, index) {\n      if (!isNullOrUndefined(layer['geometry']) && layer['geometry']['type'] === 'Path') {\n        customPath = true;\n      }\n    });\n  }\n\n  return customPath;\n}\n/**\n * @private\n * Trim the title text\n */\n\nexport function textTrim(maxWidth, text, font) {\n  var label = text;\n  var size = measureText(text, font).width;\n\n  if (size > maxWidth) {\n    var textLength = text.length;\n\n    for (var i = textLength - 1; i >= 0; --i) {\n      label = text.substring(0, i) + '...';\n      size = measureText(label, font).width;\n\n      if (size <= maxWidth || label.length < 4) {\n        if (label.length < 4) {\n          label = ' ';\n        }\n\n        return label;\n      }\n    }\n  }\n\n  return label;\n}\n/**\n * Method to calculate x position of title\n */\n\nexport function findPosition(location, alignment, textSize, type) {\n  var x;\n  var y;\n\n  switch (alignment) {\n    case 'Near':\n      x = location.x;\n      break;\n\n    case 'Center':\n      x = type === 'title' ? location.width / 2 - textSize.width / 2 : location.x + location.width / 2 - textSize.width / 2;\n      break;\n\n    case 'Far':\n      x = type === 'title' ? location.width - location.y - textSize.width : location.x + location.width - textSize.width;\n      break;\n  }\n\n  y = type === 'title' ? location.y + textSize.height / 2 : location.y + location.height / 2 + textSize.height / 2;\n  return new Point(x, y);\n}\n/**\n * To remove element by id\n */\n\nexport function removeElement(id) {\n  var element = document.getElementById(id);\n  return element ? remove(element) : null;\n}\n/**\n * @private\n */\n\nexport function getTranslate(mapObject, layer, animate) {\n  if (isNullOrUndefined(mapObject.mapScaleValue)) {\n    mapObject.mapScaleValue = mapObject.zoomSettings.zoomFactor;\n  }\n\n  var zoomFactor = animate ? 1 : mapObject.mapScaleValue;\n  var min = mapObject.baseMapRectBounds['min'];\n  var max = mapObject.baseMapRectBounds['max'];\n  var size = mapObject.totalRect ? mapObject.totalRect : mapObject.mapAreaRect;\n  var availSize = mapObject.availableSize;\n  var x;\n  var y;\n  var mapWidth = Math.abs(max['x'] - min['x']);\n  var mapHeight = Math.abs(min['y'] - max['y']);\n  var factor = animate ? 1 : mapObject.zoomSettings.zoomFactor;\n  var scaleFactor;\n  var center = mapObject.centerPosition;\n\n  if (!isNullOrUndefined(center.longitude) && !isNullOrUndefined(center.latitude)) {\n    var leftPosition = (mapWidth + Math.abs(mapObject.mapAreaRect.width - mapWidth)) / 2 / factor;\n    var topPosition = (mapHeight + Math.abs(mapObject.mapAreaRect.height - mapHeight)) / 2 / factor;\n    var point = convertGeoToPoint(center.latitude, center.longitude, mapObject.mapLayerPanel.calculateFactor(layer), layer, mapObject);\n\n    if (isNullOrUndefined(mapObject.previousProjection) || mapObject.previousProjection !== mapObject.projectionType) {\n      x = -point.x + leftPosition;\n      y = -point.y + topPosition;\n      scaleFactor = zoomFactor;\n    } else {\n      scaleFactor = mapObject.scale;\n      x = mapObject.zoomTranslatePoint.x;\n      y = mapObject.zoomTranslatePoint.y;\n    }\n  } else {\n    if (isNullOrUndefined(mapObject.previousProjection) || mapObject.previousProjection !== mapObject.projectionType) {\n      scaleFactor = parseFloat(Math.min(size.width / mapWidth, size.height / mapHeight).toFixed(2));\n      mapWidth *= scaleFactor;\n      mapHeight *= scaleFactor;\n      x = size.x + (-min['x'] + (size.width / 2 - mapWidth / 2));\n      y = size.y + (-min['y'] + (size.height / 2 - mapHeight / 2));\n    } else {\n      scaleFactor = mapObject.scale;\n      x = mapObject.zoomTranslatePoint.x;\n      y = mapObject.zoomTranslatePoint.y;\n    }\n  }\n\n  return {\n    scale: scaleFactor,\n    location: new Point(x, y)\n  };\n}\n/**\n * @private\n */\n\nexport function getZoomTranslate(mapObject, layer, animate) {\n  if (isNullOrUndefined(mapObject.mapScaleValue)) {\n    mapObject.mapScaleValue = mapObject.zoomSettings.zoomFactor;\n  }\n\n  var zoomFactor = animate ? 1 : mapObject.mapScaleValue;\n  var size = mapObject.mapAreaRect;\n  var x;\n  var y;\n  var min = mapObject.baseMapRectBounds['min'];\n  var max = mapObject.baseMapRectBounds['max'];\n  var factor = animate ? 1 : mapObject.mapScaleValue;\n  var scaleFactor;\n  var mapWidth = Math.abs(max['x'] - min['x']);\n  var mapHeight = Math.abs(min['y'] - max['y']);\n  var center = mapObject.centerPosition;\n\n  if (!isNullOrUndefined(center.longitude) && !isNullOrUndefined(center.latitude)) {\n    var topPosition = (mapHeight + Math.abs(mapObject.mapAreaRect.height - mapHeight)) / 2 / factor;\n    var leftPosition = (mapWidth + Math.abs(mapObject.mapAreaRect.width - mapWidth)) / 2 / factor;\n    var point = convertGeoToPoint(center.latitude, center.longitude, mapObject.mapLayerPanel.calculateFactor(layer), layer, mapObject);\n\n    if (!isNullOrUndefined(mapObject.zoomTranslatePoint) || !isNullOrUndefined(mapObject.previousProjection)) {\n      if (mapObject.previousProjection !== mapObject.projectionType) {\n        x = -point.x + leftPosition;\n        y = -point.y + topPosition;\n      } else {\n        x = mapObject.zoomTranslatePoint.x;\n        y = mapObject.zoomTranslatePoint.y;\n      }\n    } else {\n      x = -point.x + leftPosition;\n      y = -point.y + topPosition;\n    }\n\n    scaleFactor = zoomFactor !== 0 ? zoomFactor : 1;\n  } else {\n    var zoomFact = mapObject.zoomSettings.zoomFactor === 0 ? 1 : mapObject.zoomSettings.zoomFactor;\n    var maxZoomFact = 10;\n    zoomFact = zoomFact > maxZoomFact ? maxZoomFact : zoomFact;\n    scaleFactor = zoomFact;\n    var mapScale = mapObject.mapScaleValue === 0 ? 1 : mapObject.mapScaleValue > maxZoomFact ? maxZoomFact : mapObject.mapScaleValue;\n    var leftPosition = size.x + (-min['x'] + (size.width / 2 - mapWidth / 2));\n    var topPosition = size.y + (-min['y'] + (size.height / 2 - mapHeight / 2));\n\n    if (!isNullOrUndefined(mapObject.zoomTranslatePoint) || !isNullOrUndefined(mapObject.previousProjection)) {\n      if (mapObject.previousProjection !== mapObject.projectionType) {\n        var previousPositions = [];\n        var previousPoints = {\n          x: leftPosition,\n          y: topPosition\n        };\n        previousPositions.push(previousPoints);\n\n        for (var i = 1; i < maxZoomFact; i++) {\n          var translatePointX = previousPositions[i - 1]['x'] - (size.width / i - size.width / (i + 1)) / 2;\n          var translatePointY = previousPositions[i - 1]['y'] - (size.height / i - size.height / (i + 1)) / 2;\n          previousPoints = {\n            x: translatePointX,\n            y: translatePointY\n          };\n          previousPositions.push(previousPoints);\n        }\n\n        leftPosition = previousPositions[zoomFact - 1]['x'];\n        topPosition = previousPositions[zoomFact - 1]['y'];\n      } else {\n        leftPosition = mapObject.zoomTranslatePoint.x;\n        topPosition = mapObject.zoomTranslatePoint.y;\n\n        if (zoomFact !== mapScale) {\n          scaleFactor = mapScale;\n        }\n      }\n    }\n\n    x = leftPosition;\n    y = topPosition;\n  }\n\n  return {\n    scale: scaleFactor,\n    location: new Point(x, y)\n  };\n}\n/**\n * To get the html element by specified id\n */\n\nexport function getElementByID(id) {\n  return document.getElementById(id);\n}\n/**\n * To apply internalization\n */\n\nexport function Internalize(maps, value) {\n  maps.formatFunction = maps.intl.getNumberFormat({\n    format: maps.format,\n    useGrouping: maps.useGroupingSeparator\n  });\n  return maps.formatFunction(value);\n}\n/**\n * Function     to compile the template function for maps.\n * @returns Function\n * @private\n */\n\nexport function getTemplateFunction(template) {\n  var templateFn = null;\n  var e;\n\n  try {\n    if (document.querySelectorAll(template).length) {\n      templateFn = templateComplier(document.querySelector(template).innerHTML.trim());\n    }\n  } catch (e) {\n    templateFn = templateComplier(template);\n  }\n\n  return templateFn;\n}\n/**\n * Function to get element from id.\n * @returns Element\n * @private\n */\n\nexport function getElement(id) {\n  return document.getElementById(id);\n}\n/**\n * Function to get shape data using target id\n */\n\nexport function getShapeData(targetId, map) {\n  var layerIndex = parseInt(targetId.split('_LayerIndex_')[1].split('_')[0], 10);\n  var shapeIndex = parseInt(targetId.split('_shapeIndex_')[1].split('_')[0], 10);\n  var layer = map.layers[layerIndex];\n  var shapeData = layer.layerData[shapeIndex]['property'];\n  var data;\n\n  if (layer.dataSource) {\n    data = layer.dataSource[checkShapeDataFields(layer.dataSource, shapeData, layer.shapeDataPath, layer.shapePropertyPath)];\n  }\n\n  return {\n    shapeData: shapeData,\n    data: data\n  };\n}\n/**\n * Function to trigger shapeSelected event\n * @private\n */\n\nexport function triggerShapeEvent(targetId, selection, maps, eventName) {\n  var shape = getShapeData(targetId, maps);\n  var eventArgs = {\n    cancel: false,\n    name: eventName,\n    fill: selection.fill,\n    opacity: selection.opacity,\n    border: selection.border,\n    shapeData: shape.shapeData,\n    data: shape.data,\n    target: targetId,\n    maps: maps\n  };\n\n  if (maps.isBlazor) {\n    var data = eventArgs.data,\n        maps_2 = eventArgs.maps,\n        shapeData = eventArgs.shapeData,\n        blazorEventArgs = __rest(eventArgs, [\"data\", \"maps\", \"shapeData\"]);\n\n    eventArgs = blazorEventArgs;\n  }\n\n  maps.trigger(eventName, eventArgs);\n  return eventArgs;\n}\n/**\n * Function to get elements using class name\n */\n\nexport function getElementsByClassName(className) {\n  return document.getElementsByClassName(className);\n}\n/**\n * Function to get elements using querySelectorAll\n */\n// export function querySelectorAll(args: string, element: Element): NodeListOf<Element> {\n//     return element.querySelectorAll('.' + args);\n// }\n\n/**\n * Function to get elements using querySelector\n */\n\nexport function querySelector(args, elementSelector) {\n  var targetEle = null;\n\n  if (document.getElementById(elementSelector)) {\n    targetEle = document.getElementById(elementSelector).querySelector('#' + args);\n  }\n\n  return targetEle;\n}\n/**\n * Function to get the element for selection and highlight using public method\n */\n\nexport function getTargetElement(layerIndex, name, enable, map) {\n  var shapeIndex;\n  var targetId;\n  var targetEle;\n  var shapeData = map.layers[layerIndex].shapeData['features'];\n\n  for (var i = 0; i < shapeData.length; i++) {\n    if (shapeData[i]['properties'].name === name) {\n      targetId = map.element.id + '_' + 'LayerIndex_' + layerIndex + '_shapeIndex_' + i + '_dataIndex_undefined';\n      break;\n    }\n  }\n\n  targetEle = getElement(targetId);\n  return targetEle;\n}\n/**\n * Function to create style element for highlight and selection\n */\n\nexport function createStyle(id, className, eventArgs) {\n  return createElement('style', {\n    id: id,\n    innerHTML: '.' + className + '{fill:' + eventArgs.fill + ';' + 'opacity:' + eventArgs.opacity.toString() + ';' + 'stroke-width:' + eventArgs.border.width.toString() + ';' + 'stroke:' + eventArgs.border.color + ';' + '}'\n  });\n}\n/**\n * Function to customize the style for highlight and selection\n */\n\nexport function customizeStyle(id, className, eventArgs) {\n  var styleEle = getElement(id);\n  styleEle.innerHTML = '.' + className + '{fill:' + eventArgs.fill + ';' + 'opacity:' + eventArgs.opacity.toString() + ';' + 'stroke-width:' + eventArgs.border.width.toString() + ';' + 'stroke:' + eventArgs.border.color + '}';\n}\n/**\n * Function to remove class from element\n */\n\nexport function removeClass(element) {\n  element.removeAttribute('class');\n}\n/**\n * Animation Effect Calculation End\n * @private\n */\n\nexport function elementAnimate(element, delay, duration, point, maps, ele, radius) {\n  if (radius === void 0) {\n    radius = 0;\n  }\n\n  var centerX = point.x;\n  var centerY = point.y;\n  var height = 0;\n  var transform = element.getAttribute('transform') || '';\n  new Animation({}).animate(element, {\n    duration: duration,\n    delay: delay,\n    progress: function (args) {\n      if (args.timeStamp > args.delay) {\n        height = (args.timeStamp - args.delay) / args.duration;\n        element.setAttribute('transform', 'translate( ' + (centerX - radius * height) + ' ' + (centerY - radius * height) + ' ) scale(' + height + ')');\n      }\n    },\n    end: function (model) {\n      element.setAttribute('transform', transform);\n\n      if (!ele) {\n        return;\n      }\n\n      var event = {\n        cancel: false,\n        name: animationComplete,\n        element: ele,\n        maps: !maps.isBlazor ? maps : null\n      };\n      maps.trigger(animationComplete, event);\n    }\n  });\n}\nexport function timeout(id) {\n  removeElement(id);\n}\nexport function showTooltip(text, size, x, y, areaWidth, areaHeight, id, element, isTouch) {\n  var tooltip = document.getElementById(id);\n  var width = measureText(text, {\n    fontFamily: 'Segoe UI',\n    size: '8px',\n    fontStyle: 'Normal',\n    fontWeight: 'Regular'\n  }).width;\n  var str = text.split(' ');\n  var demo = str[0].length;\n\n  for (var i = 1; i < str.length; i++) {\n    if (demo < str[i].length) {\n      demo = str[i].length;\n    }\n  }\n\n  if (!tooltip) {\n    tooltip = createElement('div', {\n      id: id,\n      styles: 'background-color: rgb(255, 255, 255) !important; color:black !important; ' + 'position:absolute;border:1px solid rgb(0, 0, 0); padding-left:5px;' + 'font-size:12px; font-family: \"Segoe UI\"; text-align:center'\n    });\n  }\n\n  if (x < areaWidth - width) {\n    x = x;\n  } else if (x > areaWidth - width && x < areaWidth - demo * 8) {\n    width = areaWidth - x;\n  } else if (x >= areaWidth - demo * 8) {\n    if (x > width) {\n      x = x - width;\n    } else {\n      width = x;\n      x = 0;\n    }\n  }\n\n  var size1 = size.split('px');\n  wordWrap(tooltip, text, x, y, size1, width, areaWidth, element);\n  var height = tooltip.clientHeight;\n\n  if (height + parseInt(size1[0], 10) * 2 > areaHeight) {\n    width = x;\n    x = 0;\n  }\n\n  wordWrap(tooltip, text, x, y, size1, width, areaWidth, element);\n\n  if (isTouch) {\n    setTimeout(timeout, 5000, id);\n  }\n}\nexport function wordWrap(tooltip, text, x, y, size1, width, areaWidth, element) {\n  tooltip.innerHTML = text;\n  tooltip.style.top = (parseInt(size1[0], 10) * 2).toString() + 'px';\n  tooltip.style.left = x.toString() + 'px';\n  tooltip.style.width = width.toString() + 'px';\n  tooltip.style.maxWidth = areaWidth.toString() + 'px';\n  tooltip.style.wordWrap = 'break-word';\n  element.appendChild(tooltip);\n} // /**\n//  *\n//  * @param touchList\n//  * @param e\n//  * @param touches\n//  */\n// export function addTouchPointer(touchList: ITouches[], e: PointerEvent, touches: TouchList): ITouches[] {\n//     if (touches) {\n//         touchList = [];\n//         for (let i: number = 0, length: number = touches.length; i < length; i++) {\n//             touchList.push({ pageX: touches[i].clientX, pageY: touches[i].clientY, pointerId: null });\n//         }\n//     } else {\n//         touchList = touchList ? touchList : [];\n//         if (touchList.length === 0) {\n//             touchList.push({ pageX: e.clientX, pageY: e.clientY, pointerId: e.pointerId });\n//         } else {\n//             for (let i: number = 0, length: number = touchList.length; i < length; i++) {\n//                 if (touchList[i].pointerId === e.pointerId) {\n//                     touchList[i] = { pageX: e.clientX, pageY: e.clientY, pointerId: e.pointerId };\n//                 } else {\n//                     touchList.push({ pageX: e.clientX, pageY: e.clientY, pointerId: e.pointerId });\n//                 }\n//             }\n//         }\n//     }\n//     return touchList;\n// }\n\n/** @private */\n\nexport function createTooltip(id, text, top, left, fontSize) {\n  var tooltip = getElement(id);\n  var style = 'top:' + top.toString() + 'px;' + 'left:' + left.toString() + 'px;' + 'color: #000000; ' + 'background:' + '#FFFFFF' + ';' + 'position:absolute;border:1px solid #707070;font-size:' + fontSize + ';border-radius:2px;';\n\n  if (!tooltip) {\n    tooltip = createElement('div', {\n      id: id,\n      innerHTML: '&nbsp;' + text + '&nbsp;',\n      styles: style\n    });\n    document.body.appendChild(tooltip);\n  } else {\n    tooltip.setAttribute('innerHTML', '&nbsp;' + text + '&nbsp;');\n    tooltip.setAttribute('styles', style);\n  }\n}\n/** @private */\n\nexport function drawSymbol(location, shape, size, url, options) {\n  var functionName = 'Path';\n  var renderer = new SvgRenderer('');\n  var temp = renderLegendShape(location, size, shape, options, url);\n  var htmlObject = renderer['draw' + temp.functionName](temp.renderOption);\n  return htmlObject;\n}\n/** @private */\n\nexport function renderLegendShape(location, size, shape, options, url) {\n  var renderPath;\n  var functionName = 'Path';\n  var shapeWidth = size.width;\n  var shapeHeight = size.height;\n  var shapeX = location.x;\n  var shapeY = location.y;\n  var x = location.x + -shapeWidth / 2;\n  var y = location.y + -shapeHeight / 2;\n\n  switch (shape) {\n    case 'Circle':\n    case 'Bubble':\n      functionName = 'Ellipse';\n      merge(options, {\n        'rx': shapeWidth / 2,\n        'ry': shapeHeight / 2,\n        'cx': shapeX,\n        'cy': shapeY\n      });\n      break;\n\n    case 'VerticalLine':\n      renderPath = 'M' + ' ' + shapeX + ' ' + (shapeY + shapeHeight / 2) + ' ' + 'L' + ' ' + shapeX + ' ' + (shapeY + -shapeHeight / 2);\n      merge(options, {\n        'd': renderPath\n      });\n      break;\n\n    case 'Diamond':\n      renderPath = 'M' + ' ' + x + ' ' + shapeY + ' ' + 'L' + ' ' + shapeX + ' ' + (shapeY + -shapeHeight / 2) + ' ' + 'L' + ' ' + (shapeX + shapeWidth / 2) + ' ' + shapeY + ' ' + 'L' + ' ' + shapeX + ' ' + (shapeY + shapeHeight / 2) + ' ' + 'L' + ' ' + x + ' ' + shapeY + ' z';\n      merge(options, {\n        'd': renderPath\n      });\n      break;\n\n    case 'Rectangle':\n      renderPath = 'M' + ' ' + x + ' ' + (shapeY + -shapeHeight / 2) + ' ' + 'L' + ' ' + (shapeX + shapeWidth / 2) + ' ' + (shapeY + -shapeHeight / 2) + ' ' + 'L' + ' ' + (shapeX + shapeWidth / 2) + ' ' + (shapeY + shapeHeight / 2) + ' ' + 'L' + ' ' + x + ' ' + (shapeY + shapeHeight / 2) + ' ' + 'L' + ' ' + x + ' ' + (shapeY + -shapeHeight / 2) + ' z';\n      merge(options, {\n        'd': renderPath\n      });\n      break;\n\n    case 'Triangle':\n      renderPath = 'M' + ' ' + x + ' ' + (shapeY + shapeHeight / 2) + ' ' + 'L' + ' ' + shapeX + ' ' + (shapeY + -shapeHeight / 2) + ' ' + 'L' + ' ' + (shapeX + shapeWidth / 2) + ' ' + (shapeY + shapeHeight / 2) + ' ' + 'L' + ' ' + x + ' ' + (shapeY + shapeHeight / 2) + ' z';\n      merge(options, {\n        'd': renderPath\n      });\n      break;\n\n    case 'InvertedTriangle':\n      renderPath = 'M' + ' ' + (shapeX + shapeWidth / 2) + ' ' + (shapeY - shapeHeight / 2) + ' ' + 'L' + ' ' + shapeX + ' ' + (shapeY + shapeHeight / 2) + ' ' + 'L' + ' ' + (shapeX - shapeWidth / 2) + ' ' + (shapeY - shapeHeight / 2) + ' ' + 'L' + ' ' + (shapeX + shapeWidth / 2) + ' ' + (shapeY - shapeHeight / 2) + ' z';\n      merge(options, {\n        'd': renderPath\n      });\n      break;\n\n    case 'Pentagon':\n      var eq = 72;\n      var xValue = void 0;\n      var yValue = void 0;\n\n      for (var i = 0; i <= 5; i++) {\n        xValue = shapeWidth / 2 * Math.cos(Math.PI / 180 * (i * eq));\n        yValue = shapeWidth / 2 * Math.sin(Math.PI / 180 * (i * eq));\n\n        if (i === 0) {\n          renderPath = 'M' + ' ' + (shapeX + xValue) + ' ' + (shapeY + yValue) + ' ';\n        } else {\n          renderPath = renderPath.concat('L' + ' ' + (shapeX + xValue) + ' ' + (shapeY + yValue) + ' ');\n        }\n      }\n\n      renderPath = renderPath.concat('Z');\n      merge(options, {\n        'd': renderPath\n      });\n      break;\n\n    case 'Star':\n      renderPath = 'M ' + (location.x + size.width / 3) + ' ' + (location.y - size.height / 2) + ' L ' + (location.x - size.width / 2) + ' ' + (location.y + size.height / 6) + ' L ' + (location.x + size.width / 2) + ' ' + (location.y + size.height / 6) + ' L ' + (location.x - size.width / 3) + ' ' + (location.y - size.height / 2) + ' L ' + location.x + ' ' + (location.y + size.height / 2) + ' L ' + (location.x + size.width / 3) + ' ' + (location.y - size.height / 2) + ' Z';\n      merge(options, {\n        'd': renderPath\n      });\n      break;\n\n    case 'Cross':\n      renderPath = 'M' + ' ' + x + ' ' + shapeY + ' ' + 'L' + ' ' + (shapeX + shapeWidth / 2) + ' ' + shapeY + ' ' + 'M' + ' ' + shapeX + ' ' + (shapeY + shapeHeight / 2) + ' ' + 'L' + ' ' + shapeX + ' ' + (shapeY + -shapeHeight / 2);\n      merge(options, {\n        'd': renderPath\n      });\n      break;\n\n    case 'Image':\n      functionName = 'Image';\n      merge(options, {\n        'href': url,\n        'height': shapeHeight,\n        'width': shapeWidth,\n        x: x,\n        y: y\n      });\n      break;\n  }\n\n  return {\n    renderOption: options,\n    functionName: functionName\n  };\n}\n/**\n * Animation Effect Calculation End\n * @private\n */\n// export function markerTemplateAnimate(element: Element, delay: number, duration: number, point: MapLocation): void {\n//     let delta: number = 0;\n//     let top: string = (element as HTMLElement).style.top;\n//     let y: number = parseInt(top, 10);\n//     new Animation({}).animate(<HTMLElement>element, {\n//         duration: duration,\n//         delay: delay,\n//         progress: (args: AnimationOptions): void => {\n//             if (args.timeStamp > args.delay) {\n//                 delta = ((args.timeStamp - args.delay) / args.duration);\n//                 (element as HTMLElement).style.top = y - 100 + (delta * 100) + 'px';\n//             }\n//         },\n//         end: (model: AnimationOptions) => {\n//             (element as HTMLElement).style.top = top;\n//         }\n//     });\n// }\n\n/** @private */\n\nexport function getElementOffset(childElement, parentElement) {\n  var width;\n  var height;\n  parentElement.appendChild(childElement);\n  width = childElement.offsetWidth;\n  height = childElement.offsetHeight;\n  parentElement.removeChild(childElement);\n  return new Size(width, height);\n}\n/** @private */\n\nexport function changeBorderWidth(element, index, scale, maps) {\n  var childNode;\n\n  for (var l = 0; l < element.childElementCount; l++) {\n    childNode = element.childNodes[l];\n\n    if (childNode.id.indexOf('_NavigationGroup') > -1) {\n      changeNavaigationLineWidth(childNode, index, scale, maps);\n    } else {\n      var currentStroke = maps.layersCollection[index].shapeSettings.border.width;\n      childNode.setAttribute('stroke-width', (currentStroke / scale).toString());\n    }\n  }\n}\n/** @private */\n\nexport function changeNavaigationLineWidth(element, index, scale, maps) {\n  var node;\n\n  for (var m = 0; m < element.childElementCount; m++) {\n    node = element.childNodes[m];\n\n    if (node.tagName === 'path') {\n      var currentStroke = maps.layersCollection[index].navigationLineSettings[parseFloat(node.id.split('_NavigationIndex_')[1].split('_')[0])].width;\n      node.setAttribute('stroke-width', (currentStroke / scale).toString());\n    }\n  }\n} // /** Pinch zoom helper methods */\n\n/** @private */\n\nexport function targetTouches(event) {\n  var targetTouches = [];\n  var touches = event.touches;\n\n  for (var i = 0; i < touches.length; i++) {\n    targetTouches.push({\n      pageX: touches[i].pageX,\n      pageY: touches[i].pageY\n    });\n  }\n\n  return targetTouches;\n}\n/** @private */\n\nexport function calculateScale(startTouches, endTouches) {\n  var startDistance = getDistance(startTouches[0], startTouches[1]);\n  var endDistance = getDistance(endTouches[0], endTouches[1]);\n  return endDistance / startDistance;\n}\n/** @private */\n\nexport function getDistance(a, b) {\n  var x = a.pageX - b.pageX;\n  var y = a.pageY - b.pageY;\n  return Math.sqrt(x * x + y * y);\n}\n/** @private */\n\nexport function getTouches(touches, maps) {\n  var rect = maps.element.getBoundingClientRect();\n  var posTop = rect.top + document.defaultView.pageXOffset;\n  var posLeft = rect.left + document.defaultView.pageYOffset;\n  return Array.prototype.slice.call(touches).map(function (touch) {\n    return {\n      x: touch.pageX - posLeft,\n      y: touch.pageY - posTop\n    };\n  });\n}\n/** @private */\n\nexport function getTouchCenter(touches) {\n  return {\n    x: touches.map(function (e) {\n      return e['x'];\n    }).reduce(sum) / touches.length,\n    y: touches.map(function (e) {\n      return e['y'];\n    }).reduce(sum) / touches.length\n  };\n}\n/** @private */\n\nexport function sum(a, b) {\n  return a + b;\n}\n/**\n * Animation Effect Calculation End\n * @private\n */\n\nexport function zoomAnimate(element, delay, duration, point, scale, size, maps) {\n  var delta = 0;\n  var previousLocation = maps.previousPoint;\n  var preScale = maps.previousScale;\n  var diffScale = scale - preScale;\n  var currentLocation = new MapLocation(0, 0);\n  var currentScale = 1;\n\n  if (scale === preScale) {\n    element.setAttribute('transform', 'scale( ' + scale + ' ) translate( ' + point.x + ' ' + point.y + ' )');\n    return;\n  }\n\n  var slope = function (previousLocation, point) {\n    if (previousLocation.x === point.x) {\n      return null;\n    }\n\n    return (point.y - previousLocation.y) / (point.x - previousLocation.x);\n  };\n\n  var intercept = function (point, slopeValue) {\n    if (slopeValue === null) {\n      return point.x;\n    }\n\n    return point.y - slopeValue * point.x;\n  };\n\n  var slopeFactor = slope(previousLocation, point);\n  var slopeIntersection = intercept(previousLocation, slopeFactor);\n  var horizontalDifference = point.x - previousLocation.x;\n  var verticalDifference = point.y - previousLocation.y;\n  animate(element, delay, duration, function (args) {\n    if (args.timeStamp > args.delay) {\n      delta = (args.timeStamp - args.delay) / args.duration;\n      currentScale = preScale + delta * diffScale;\n      currentLocation.x = previousLocation.x + delta * horizontalDifference / (currentScale / scale);\n\n      if (slopeFactor == null) {\n        currentLocation.y = previousLocation.y + delta * verticalDifference;\n      } else {\n        currentLocation.y = slopeFactor * currentLocation.x + slopeIntersection;\n      }\n\n      args.element.setAttribute('transform', 'scale( ' + currentScale + ' ) ' + 'translate( ' + currentLocation.x + ' ' + currentLocation.y + ' )');\n      maps.translatePoint = currentLocation;\n      maps.scale = currentScale;\n      maps.zoomModule.processTemplate(point.x, point.y, currentScale, maps);\n    }\n  }, function () {\n    maps.translatePoint = point;\n    maps.scale = scale;\n    element.setAttribute('transform', 'scale( ' + scale + ' ) translate( ' + point.x + ' ' + point.y + ' )');\n    maps.zoomModule.processTemplate(point.x, point.y, scale, maps);\n  });\n}\n/**\n * To process custom animation\n */\n\nexport function animate(element, delay, duration, process, end) {\n  var _this = this;\n\n  var start = null;\n  var clearAnimation;\n\n  var startAnimation = function (timestamp) {\n    if (!start) {\n      start = timestamp;\n    }\n\n    var progress = timestamp - start;\n\n    if (progress < duration) {\n      process.call(_this, {\n        element: element,\n        delay: 0,\n        timeStamp: progress,\n        duration: duration\n      });\n      window.requestAnimationFrame(startAnimation);\n    } else {\n      window.cancelAnimationFrame(clearAnimation);\n      end.call(_this, {\n        element: element\n      });\n    }\n  };\n\n  clearAnimation = window.requestAnimationFrame(startAnimation);\n}\n/**\n * To get shape data file using Ajax.\n */\n\nvar MapAjax =\n/** @class */\nfunction () {\n  function MapAjax(options, type, async, contentType, sendData) {\n    this.dataOptions = options;\n    this.type = type || 'GET';\n    this.async = async || true;\n    this.contentType = contentType;\n    this.sendData = sendData;\n  }\n\n  return MapAjax;\n}();\n\nexport { MapAjax };\n/**\n * Animation Translate\n * @private\n */\n\nexport function smoothTranslate(element, delay, duration, point) {\n  var delta = 0;\n  var transform = element.getAttribute('transform').split(' ');\n\n  if (transform.length === 2) {\n    transform[2] = transform[1].split(')')[0];\n    transform[1] = transform[0].split('(')[1];\n  }\n\n  var previousLocation = new MapLocation(parseInt(transform[1], 10), parseInt(transform[2], 10));\n  var diffx = point.x - previousLocation.x;\n  var diffy = point.y - previousLocation.y;\n  var currentLocation = new MapLocation(0, 0);\n  animate(element, delay, duration, function (args) {\n    if (args.timeStamp > args.delay) {\n      delta = (args.timeStamp - args.delay) / args.duration;\n      currentLocation.x = previousLocation.x + delta * diffx;\n      currentLocation.y = previousLocation.y + delta * diffy;\n      args.element.setAttribute('transform', 'translate( ' + currentLocation.x + ' ' + currentLocation.y + ' )');\n    }\n  }, function () {\n    element.setAttribute('transform', 'translate( ' + point.x + ' ' + point.y + ' )');\n  });\n}","map":null,"metadata":{},"sourceType":"module"}