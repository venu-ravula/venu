{"ast":null,"code":"import { annotationRendering } from '../index';\nimport { createElement, isNullOrUndefined, updateBlazorTemplate } from '@syncfusion/ej2-base';\nimport { getTemplateFunction, getElementOffset, getElementByID } from '../utils/helper';\n/**\n * Represent the annotation rendering for map\n */\n\nvar Annotations =\n/** @class */\nfunction () {\n  function Annotations(map) {\n    this.map = map;\n  }\n\n  Annotations.prototype.renderAnnotationElements = function () {\n    var _this = this;\n\n    var secondaryID = this.map.element.id + '_Secondary_Element';\n    var annotationGroup = createElement('div', {\n      id: this.map.element.id + '_Annotations_Group'\n    });\n    annotationGroup.style.position = 'absolute';\n    annotationGroup.style.top = '0px';\n    annotationGroup.style.left = '0px';\n    this.map.annotations.map(function (annotation, index) {\n      if (annotation.content !== null) {\n        _this.createAnnotationTemplate(annotationGroup, annotation, index);\n      }\n    });\n\n    if (annotationGroup.childElementCount > 0 && !isNullOrUndefined(getElementByID(secondaryID))) {\n      getElementByID(secondaryID).appendChild(annotationGroup);\n\n      for (var i = 0; i < this.map.annotations.length; i++) {\n        updateBlazorTemplate(this.map.element.id + '_ContentTemplate_' + i, 'ContentTemplate', this.map.annotations[i]);\n      }\n    }\n  };\n  /**\n   * To create annotation elements\n   */\n\n\n  Annotations.prototype.createAnnotationTemplate = function (parentElement, annotation, annotationIndex) {\n    var _this = this;\n\n    var left;\n    var top;\n    var templateFn;\n    var map = this.map;\n    var templateElement;\n    var availSize = map.availableSize;\n    var id = map.element.id + '_Annotation_' + annotationIndex;\n    var childElement = createElement('div', {\n      id: map.element.id + '_Annotation_' + annotationIndex,\n      styles: 'position: absolute; z-index:' + annotation.zIndex + ';'\n    });\n    var argsData = {\n      cancel: false,\n      name: annotationRendering,\n      content: annotation.content,\n      annotation: annotation\n    };\n    this.map.trigger(annotationRendering, argsData, function (annotationArgs) {\n      if (argsData.cancel) {\n        return;\n      }\n\n      var blazor = 'Blazor';\n      templateFn = getTemplateFunction(argsData.content);\n\n      if (templateFn && (!window[blazor] ? templateFn(_this.map, null, null, _this.map.element.id + '_ContentTemplate_' + annotationIndex).length : {})) {\n        templateElement = Array.prototype.slice.call(templateFn(!window[blazor] ? _this.map : {}, null, null, _this.map.element.id + '_ContentTemplate_' + annotationIndex));\n        var length_1 = templateElement.length;\n\n        for (var i = 0; i < length_1; i++) {\n          childElement.appendChild(templateElement[i]);\n        }\n      } else {\n        childElement.appendChild(createElement('div', {\n          innerHTML: argsData.content\n        }));\n      }\n    });\n    var offset = getElementOffset(childElement.cloneNode(true), map.element);\n    var elementRect = map.element.getBoundingClientRect();\n    var bounds = map.svgObject.getBoundingClientRect();\n    left = Math.abs(bounds.left - elementRect.left);\n    top = Math.abs(bounds.top - elementRect.top);\n    var annotationXValue = annotation.x.indexOf('%') > -1 ? availSize.width / 100 * parseFloat(annotation.x) : parseFloat(annotation.x);\n    var annotationYValue = annotation.y.indexOf('%') > -1 ? availSize.height / 100 * parseFloat(annotation.y) : parseFloat(annotation.y);\n    left = annotation.horizontalAlignment === 'None' ? left + annotationXValue : left;\n    top = annotation.verticalAlignment === 'None' ? top + annotationYValue : top;\n\n    switch (annotation.verticalAlignment) {\n      case 'Near':\n        top = top + annotationYValue;\n        break;\n\n      case 'Center':\n        top = top + annotationYValue + (bounds.height / 2 - offset.height / 2);\n        break;\n\n      case 'Far':\n        top = top + bounds.height + annotationYValue - offset.height;\n        break;\n    }\n\n    switch (annotation.horizontalAlignment) {\n      case 'Near':\n        left = left + annotationXValue;\n        break;\n\n      case 'Center':\n        left = left + annotationXValue + (bounds.width / 2 - offset.width / 2);\n        break;\n\n      case 'Far':\n        left = left + bounds.width + annotationXValue - offset.width;\n        break;\n    }\n\n    childElement.style.left = left + 'px';\n    childElement.style.top = top + 'px';\n    parentElement.appendChild(childElement);\n  };\n  /*\n  * Get module name.\n  */\n\n\n  Annotations.prototype.getModuleName = function () {\n    return 'Annotations';\n  };\n  /**\n   * To destroy the annotation.\n   * @return {void}\n   * @private\n   */\n\n\n  Annotations.prototype.destroy = function (map) {// Destroy method performed here\n  };\n\n  return Annotations;\n}();\n\nexport { Annotations };","map":null,"metadata":{},"sourceType":"module"}