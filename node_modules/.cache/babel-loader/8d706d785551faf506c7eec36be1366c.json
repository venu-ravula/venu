{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nimport { markerRendering, convertTileLatLongToPoint, MapLocation } from '../index';\nimport { markerClick, markerMouseMove, markerClusterClick, markerClusterMouseMove } from '../index';\nimport { isNullOrUndefined, createElement } from '@syncfusion/ej2-base';\nimport { getTranslate, convertGeoToPoint, clusterTemplate, marker, markerTemplate, getZoomTranslate } from '../utils/helper';\nimport { getElementByID, mergeSeparateCluster, clusterSeparate } from '../utils/helper';\n/**\n * Marker class\n */\n\nvar Marker =\n/** @class */\nfunction () {\n  function Marker(maps) {\n    this.maps = maps;\n    this.trackElements = [];\n    this.sameMarkerData = [];\n  }\n  /* tslint:disable:no-string-literal */\n\n\n  Marker.prototype.markerRender = function (layerElement, layerIndex, factor, type) {\n    var _this = this;\n\n    var templateFn;\n    var currentLayer = this.maps.layersCollection[layerIndex];\n    this.markerSVGObject = this.maps.renderer.createGroup({\n      id: this.maps.element.id + '_Markers_Group',\n      style: 'pointer-events: auto;'\n    });\n    var markerTemplateEle = createElement('div', {\n      id: this.maps.element.id + '_LayerIndex_' + layerIndex + '_Markers_Template_Group',\n      className: 'template',\n      styles: 'overflow: hidden; position: absolute;pointer-events: none;' + 'top:' + (this.maps.isTileMap ? 0 : this.maps.mapAreaRect.y) + 'px;' + 'left:' + (this.maps.isTileMap ? 0 : this.maps.mapAreaRect.x) + 'px;' + 'height:' + this.maps.mapAreaRect.height + 'px;' + 'width:' + this.maps.mapAreaRect.width + 'px;'\n    }); //tslint:disable\n\n    currentLayer.markerSettings.map(function (markerSettings, markerIndex) {\n      var markerData = markerSettings.dataSource;\n      markerData.forEach(function (data, dataIndex) {\n        var eventArgs = {\n          cancel: false,\n          name: markerRendering,\n          fill: markerSettings.fill,\n          height: markerSettings.height,\n          width: markerSettings.width,\n          imageUrl: markerSettings.imageUrl,\n          shape: markerSettings.shape,\n          template: markerSettings.template,\n          data: data,\n          maps: _this.maps,\n          marker: markerSettings,\n          border: markerSettings.border\n        };\n\n        if (_this.maps.isBlazor) {\n          var maps = eventArgs.maps,\n              marker_1 = eventArgs.marker,\n              blazorEventArgs = __rest(eventArgs, [\"maps\", \"marker\"]);\n\n          eventArgs = blazorEventArgs;\n        }\n\n        _this.maps.trigger('markerRendering', eventArgs, function (MarkerArgs) {\n          var lng = data['longitude'];\n          var lat = data['latitude'];\n          var data1 = {};\n          var text = [];\n          var j = 0;\n\n          for (var i = 0; i < Object.keys(data).length; i++) {\n            if (Object.keys(data)[i].toLowerCase() !== 'latitude' && Object.keys(data)[i].toLowerCase() !== 'longitude' && Object.keys(data)[i].toLowerCase() !== 'name') {\n              text[j] = data[Object.keys(data)[i].toLowerCase()];\n              data1['text'] = text;\n              j++;\n            }\n          }\n\n          data['text'] = data1['text'];\n          var offset = markerSettings.offset;\n\n          if (!eventArgs.cancel && markerSettings.visible && !isNullOrUndefined(lng) && !isNullOrUndefined(lat)) {\n            var markerID = _this.maps.element.id + '_LayerIndex_' + layerIndex + '_MarkerIndex_' + markerIndex + '_dataIndex_' + dataIndex;\n            var location_1 = _this.maps.isTileMap ? convertTileLatLongToPoint(new MapLocation(lng, lat), factor, _this.maps.tileTranslatePoint, true) : convertGeoToPoint(lat, lng, factor, currentLayer, _this.maps);\n            var animate = currentLayer.animationDuration !== 0 || isNullOrUndefined(_this.maps.zoomModule);\n            var translate = _this.maps.isTileMap ? new Object() : !isNullOrUndefined(_this.maps.zoomModule) && _this.maps.zoomSettings.zoomFactor > 1 ? getZoomTranslate(_this.maps, currentLayer, animate) : getTranslate(_this.maps, currentLayer, animate);\n            var scale = type === 'AddMarker' ? _this.maps.scale : translate['scale'];\n            var transPoint = type === 'AddMarker' ? _this.maps.translatePoint : translate['location'];\n\n            if (eventArgs.template) {\n              markerTemplate(eventArgs, templateFn, markerID, data, markerIndex, markerTemplateEle, location_1, scale, offset, _this.maps);\n            } else {\n              marker(eventArgs, markerSettings, markerData, dataIndex, location_1, transPoint, markerID, offset, scale, _this.maps, _this.markerSVGObject);\n            }\n          }\n        });\n      });\n    });\n\n    if (this.markerSVGObject.childElementCount > 0) {\n      layerElement.appendChild(this.markerSVGObject);\n\n      if (currentLayer.markerClusterSettings.allowClustering) {\n        this.maps.svgObject.appendChild(this.markerSVGObject);\n        this.maps.element.appendChild(this.maps.svgObject);\n        this.markerSVGObject = clusterTemplate(currentLayer, this.markerSVGObject, this.maps, layerIndex, this.markerSVGObject);\n        layerElement.appendChild(this.markerSVGObject);\n      }\n    }\n\n    if (markerTemplateEle.childElementCount > 0 && getElementByID(this.maps.element.id + '_Secondary_Element')) {\n      getElementByID(this.maps.element.id + '_Secondary_Element').appendChild(markerTemplateEle);\n\n      if (currentLayer.markerClusterSettings.allowClustering) {\n        markerTemplateEle = clusterTemplate(currentLayer, markerTemplateEle, this.maps, layerIndex, this.markerSVGObject);\n        getElementByID(this.maps.element.id + '_Secondary_Element').appendChild(markerTemplateEle);\n      }\n    }\n  };\n  /**\n   * To check and trigger marker click event\n   */\n\n\n  Marker.prototype.markerClick = function (e) {\n    var target = e.target.id;\n\n    if (target.indexOf('_LayerIndex_') === -1 || target.indexOf('_cluster_') > 0) {\n      return;\n    }\n\n    var options = this.getMarker(target);\n\n    if (isNullOrUndefined(options)) {\n      return;\n    }\n\n    var eventArgs = {\n      cancel: false,\n      name: markerClick,\n      data: options.data,\n      maps: this.maps,\n      marker: options.marker,\n      target: target,\n      x: e.clientX,\n      y: e.clientY,\n      latitude: options.data[\"latitude\"] || options.data[\"Latitude\"],\n      longitude: options.data[\"longitude\"] || options.data[\"Longitude\"]\n    };\n\n    if (this.maps.isBlazor) {\n      var maps = eventArgs.maps,\n          marker_2 = eventArgs.marker,\n          data = eventArgs.data,\n          blazorEventArgs = __rest(eventArgs, [\"maps\", \"marker\", \"data\"]);\n\n      eventArgs = blazorEventArgs;\n    }\n\n    this.maps.trigger(markerClick, eventArgs);\n  };\n  /**\n   * To check and trigger Cluster click event\n   */\n\n\n  Marker.prototype.markerClusterClick = function (e) {\n    var target = e.target.id;\n\n    if (target.indexOf('_LayerIndex_') === -1 || target.indexOf('_cluster_') === -1) {\n      return;\n    }\n\n    var options = this.getMarker(target);\n\n    if (isNullOrUndefined(options)) {\n      return;\n    }\n\n    var textElement = document.getElementById(target.indexOf('_datalabel_') > -1 ? target : target + '_datalabel_' + target.split('_cluster_')[1]);\n\n    if (options.clusterCollection.length > 0) {\n      var textElement_1 = document.getElementById(target.indexOf('_datalabel_') > -1 ? target : target + '_datalabel_' + target.split('_cluster_')[1]);\n\n      if (+textElement_1.textContent === options.clusterCollection[0].data.length) {\n        if (this.sameMarkerData.length > 0) {\n          mergeSeparateCluster(this.sameMarkerData, this.maps, this.markerSVGObject);\n        }\n\n        this.sameMarkerData = options.clusterCollection;\n        clusterSeparate(this.sameMarkerData, this.maps, this.markerSVGObject, true);\n      } else {\n        this.sameMarkerData = [];\n      }\n    }\n\n    var eventArgs = {\n      cancel: false,\n      name: markerClusterClick,\n      data: options.data,\n      maps: this.maps,\n      target: target,\n      x: e.clientX,\n      y: e.clientY,\n      latitude: options.data[\"latitude\"] || options.data[\"Latitude\"],\n      longitude: options.data[\"longitude\"] || options.data[\"Longitude\"]\n    };\n\n    if (this.maps.isBlazor) {\n      var maps = eventArgs.maps,\n          data = eventArgs.data,\n          blazorEventArgs = __rest(eventArgs, [\"maps\", \"data\"]);\n\n      eventArgs = blazorEventArgs;\n    }\n\n    this.maps.trigger(markerClusterClick, eventArgs);\n  };\n  /**\n   * To get marker from target id\n   */\n\n\n  Marker.prototype.getMarker = function (target) {\n    var id = target.split('_LayerIndex_');\n    var index = parseInt(id[1].split('_')[0], 10);\n    var layer = this.maps.layers[index];\n    var data;\n    var clusterCollection = [];\n    var marker;\n\n    if (target.indexOf('_MarkerIndex_') > -1) {\n      var markerIndex = parseInt(id[1].split('_MarkerIndex_')[1].split('_')[0], 10);\n      var dataIndex = parseInt(id[1].split('_dataIndex_')[1].split('_')[0], 10);\n      marker = layer.markerSettings[markerIndex];\n\n      if (!isNaN(markerIndex)) {\n        data = marker.dataSource[dataIndex];\n        var colo_1 = [];\n\n        if (this.maps.layers[index].markerClusterSettings.allowClusterExpand && target.indexOf('_cluster_') > -1) {\n          marker.dataSource.forEach(function (loc, index) {\n            if (loc['latitude'] === data['latitude'] && loc['longitude'] === data['longitude']) {\n              colo_1.push({\n                data: data,\n                index: index\n              });\n            }\n          });\n          clusterCollection.push({\n            data: colo_1,\n            layerIndex: index,\n            markerIndex: markerIndex,\n            targetClusterIndex: +(target.split('_cluster_')[1].indexOf('_datalabel_') > -1 ? target.split('_cluster_')[1].split('_datalabel_')[0] : target.split('_cluster_')[1])\n          });\n        }\n\n        return {\n          marker: marker,\n          data: data,\n          clusterCollection: clusterCollection\n        };\n      }\n    }\n\n    return null;\n  };\n  /**\n   * To check and trigger marker move event\n   */\n\n\n  Marker.prototype.markerMove = function (e) {\n    var targetId = e.target.id;\n\n    if (targetId.indexOf('_LayerIndex_') === -1 || targetId.indexOf('_cluster_') > 0) {\n      return;\n    }\n\n    var options = this.getMarker(targetId);\n\n    if (isNullOrUndefined(options)) {\n      return;\n    }\n\n    var eventArgs = {\n      cancel: false,\n      name: markerMouseMove,\n      data: options.data,\n      maps: this.maps,\n      target: targetId,\n      x: e.clientX,\n      y: e.clientY\n    };\n\n    if (this.maps.isBlazor) {\n      var maps = eventArgs.maps,\n          blazorEventArgs = __rest(eventArgs, [\"maps\"]);\n\n      eventArgs = blazorEventArgs;\n    }\n\n    this.maps.trigger(markerMouseMove, eventArgs);\n  };\n  /**\n   * To check and trigger cluster move event\n   */\n\n\n  Marker.prototype.markerClusterMouseMove = function (e) {\n    var targetId = e.target.id;\n\n    if (targetId.indexOf('_LayerIndex_') === -1 || targetId.indexOf('_cluster_') === -1) {\n      return;\n    }\n\n    var options = this.getMarker(targetId);\n\n    if (isNullOrUndefined(options)) {\n      return;\n    }\n\n    var eventArgs = {\n      cancel: false,\n      name: markerClusterMouseMove,\n      data: options.data,\n      maps: this.maps,\n      target: targetId,\n      x: e.clientX,\n      y: e.clientY\n    };\n\n    if (this.maps.isBlazor) {\n      var maps = eventArgs.maps,\n          blazorEventArgs = __rest(eventArgs, [\"maps\"]);\n\n      eventArgs = blazorEventArgs;\n    }\n\n    this.maps.trigger(markerClusterMouseMove, eventArgs);\n  };\n  /**\n   * Get module name.\n   */\n\n\n  Marker.prototype.getModuleName = function () {\n    return 'Marker';\n  };\n  /**\n   * To destroy the layers.\n   * @return {void}\n   * @private\n   */\n\n\n  Marker.prototype.destroy = function (maps) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return Marker;\n}();\n\nexport { Marker };","map":null,"metadata":{},"sourceType":"module"}