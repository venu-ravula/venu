{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nimport { Point, getElementByID, PathOption, Rect, convertGeoToPoint, CircleOption, convertTileLatLongToPoint } from '../utils/helper';\nimport { RectOption, createTooltip, calculateScale, getTouchCenter, getTouches, targetTouches } from '../utils/helper';\nimport { MapLocation, zoomAnimate, smoothTranslate, measureText, textTrim, clusterTemplate, marker, markerTemplate, removeElement, getElement, clusterSeparate } from '../utils/helper';\nimport { isNullOrUndefined, EventHandler, Browser, remove, createElement } from '@syncfusion/ej2-base';\nimport { changeBorderWidth, markerRendering } from '../index';\nimport { zoomIn, zoomOut, pan } from '../model/constants';\n/**\n * Zoom module used to process the zoom for maps\n */\n\n/* tslint:disable:max-line-length */\n\nvar Zoom =\n/** @class */\nfunction () {\n  function Zoom(maps) {\n    this.isPanning = false;\n    this.mouseEnter = false;\n    this.isTouch = false;\n    this.rectZoomingStart = false;\n    this.pinchRect = new Rect(0, 0, 0, 0);\n    this.browserName = Browser.info.name;\n    this.isPointer = Browser.isPointer;\n    this.handled = false;\n    this.pinchFactor = 1;\n    this.startTouches = [];\n    this.shapeZoomLocation = [];\n    this.intersect = [];\n    /**\n     * @private\n     */\n\n    this.flag = false;\n    this.maps = maps;\n    this.wheelEvent = this.browserName === 'mozilla' ? this.isPointer ? 'mousewheel' : 'DOMMouseScroll' : 'mousewheel';\n    this.cancelEvent = this.isPointer ? 'pointerleave' : 'mouseleave';\n    this.selectionColor = this.maps.zoomSettings.selectionColor;\n    this.fillColor = this.maps.zoomSettings.color;\n    this.addEventListener();\n    this.groupElements = [];\n  }\n  /* tslint:disable:no-string-literal */\n\n  /**\n   * To perform zooming for maps\n   * @param position\n   * @param newZoomFactor\n   * @param type\n   */\n\n\n  Zoom.prototype.performZooming = function (position, newZoomFactor, type) {\n    var map = this.maps;\n    map.previousProjection = map.projectionType;\n    var prevLevel = map.tileZoomLevel;\n    var scale = map.previousScale = map.scale;\n    var maxZoom = map.zoomSettings.maxZoom;\n    var minZoom = map.zoomSettings.minZoom;\n    var translatePoint = map.previousPoint = map.translatePoint;\n    var prevTilePoint = map.tileTranslatePoint;\n\n    if (!map.isTileMap && (type === 'ZoomIn' ? newZoomFactor >= minZoom && newZoomFactor <= maxZoom : newZoomFactor >= minZoom)) {\n      var availSize = map.mapAreaRect;\n      var minBounds = map.baseMapRectBounds['min'];\n      var maxBounds = map.baseMapRectBounds['max'];\n      var mapTotalWidth = Math.abs(minBounds['x'] - maxBounds['x']);\n      var mapTotalHeight = Math.abs(minBounds['y'] - maxBounds['y']);\n      var point = map.translatePoint;\n      var translatePointX = point.x - (availSize.width / scale - availSize.width / newZoomFactor) / (availSize.width / position.x);\n      var translatePointY = point.y - (availSize.height / scale - availSize.height / newZoomFactor) / (availSize.height / position.y);\n      var currentHeight = Math.abs(map.baseMapRectBounds['max']['y'] - map.baseMapRectBounds['min']['y']) * newZoomFactor;\n      translatePointX = currentHeight < map.mapAreaRect.height ? availSize.x + (-minBounds['x'] + (availSize.width / 2 - mapTotalWidth / 2)) : translatePointX;\n      translatePointY = currentHeight < map.mapAreaRect.height ? availSize.y + (-minBounds['y'] + (availSize.height / 2 - mapTotalHeight / 2)) : translatePointY;\n      map.translatePoint = new Point(translatePointX, translatePointY);\n      map.scale = newZoomFactor;\n      this.triggerZoomEvent(prevTilePoint, prevLevel);\n    } else if (map.isTileMap && newZoomFactor >= minZoom && newZoomFactor <= maxZoom) {\n      this.getTileTranslatePosition(prevLevel, newZoomFactor, position);\n      map.tileZoomLevel = newZoomFactor;\n      map.scale = Math.pow(2, newZoomFactor - 1);\n      map.translatePoint.x = (map.tileTranslatePoint.x - 0.01 * map.scale) / map.scale;\n      map.translatePoint.y = (map.tileTranslatePoint.y - 0.01 * map.scale) / map.scale;\n      this.triggerZoomEvent(prevTilePoint, prevLevel);\n      map.mapLayerPanel.generateTiles(newZoomFactor, map.tileTranslatePoint);\n    }\n\n    this.applyTransform();\n  };\n\n  Zoom.prototype.triggerZoomEvent = function (prevTilePoint, prevLevel) {\n    var map = this.maps;\n    var zoomArgs;\n\n    if (!map.isTileMap) {\n      zoomArgs = {\n        cancel: false,\n        name: 'zoom',\n        type: map.scale > map.previousScale ? zoomIn : zoomOut,\n        maps: !map.isBlazor ? map : null,\n        tileTranslatePoint: {},\n        translatePoint: {\n          previous: map.previousPoint,\n          current: map.translatePoint\n        },\n        tileZoomLevel: {},\n        scale: {\n          previous: map.previousScale,\n          current: map.scale\n        }\n      };\n    } else {\n      zoomArgs = {\n        cancel: false,\n        name: 'zoom',\n        type: map.tileZoomLevel > prevLevel ? zoomIn : zoomOut,\n        maps: !map.isBlazor ? map : null,\n        tileTranslatePoint: {\n          previous: prevTilePoint,\n          current: map.tileTranslatePoint\n        },\n        translatePoint: {\n          previous: map.previousPoint,\n          current: map.translatePoint\n        },\n        tileZoomLevel: {\n          previous: prevLevel,\n          current: map.tileZoomLevel\n        },\n        scale: {\n          previous: map.previousScale,\n          current: map.scale\n        }\n      };\n    }\n\n    map.trigger('zoom', zoomArgs);\n  };\n\n  Zoom.prototype.getTileTranslatePosition = function (prevLevel, currentLevel, position) {\n    var map = this.maps;\n    var tileDefaultSize = 256;\n    var bounds = getElementByID(this.maps.element.id).getBoundingClientRect();\n    var prevSize = Math.pow(2, prevLevel) * 256;\n    var totalSize = Math.pow(2, currentLevel) * 256;\n    var x = (position.x - map.tileTranslatePoint.x) / prevSize * 100;\n    var y = (position.y - map.tileTranslatePoint.y) / prevSize * 100;\n    map.tileTranslatePoint.x = currentLevel === 1 ? bounds.width / 2 - tileDefaultSize * 2 / 2 : position.x - x * totalSize / 100;\n    map.tileTranslatePoint.y = currentLevel === 1 ? bounds.height / 2 - tileDefaultSize * 2 / 2 : position.y - y * totalSize / 100;\n  };\n\n  Zoom.prototype.performRectZooming = function () {\n    var map = this.maps;\n    var size = map.availableSize;\n    var prevLevel = map.tileZoomLevel;\n    var zoomRect = this.zoomingRect;\n\n    if (zoomRect.height > 0 && zoomRect.width > 0) {\n      var x = this.zoomingRect.x + this.zoomingRect.width / 2;\n      var y = this.zoomingRect.y + this.zoomingRect.height / 2;\n      var zoomCalculationFactor = void 0;\n\n      if (!map.isTileMap) {\n        var scale = map.previousScale = map.scale;\n        zoomCalculationFactor = scale + Math.round((size.width / zoomRect.width + size.height / zoomRect.height) / 2);\n        var translatePoint = map.previousPoint = map.translatePoint;\n        var translatePointX = translatePoint.x - (size.width / scale - size.width / zoomCalculationFactor) / (size.width / x);\n        var translatePointY = translatePoint.y - (size.height / scale - size.height / zoomCalculationFactor) / (size.height / y);\n        map.translatePoint = new Point(translatePointX, translatePointY);\n        map.scale = zoomCalculationFactor;\n      } else {\n        zoomCalculationFactor = prevLevel + Math.round(prevLevel + (size.width / zoomRect.width + size.height / zoomRect.height) / 2);\n        this.getTileTranslatePosition(prevLevel, zoomCalculationFactor, {\n          x: x,\n          y: y\n        });\n        map.tileZoomLevel = zoomCalculationFactor;\n        map.mapLayerPanel.generateTiles(zoomCalculationFactor, map.tileTranslatePoint);\n        map.translatePoint.x = (map.tileTranslatePoint.x - 0.5 * Math.pow(2, zoomCalculationFactor)) / Math.pow(2, zoomCalculationFactor);\n        map.translatePoint.y = (map.tileTranslatePoint.y - 0.5 * Math.pow(2, zoomCalculationFactor)) / Math.pow(2, zoomCalculationFactor);\n        map.scale = Math.pow(2, zoomCalculationFactor);\n      }\n\n      this.applyTransform(true);\n      this.zoomingRect = null;\n    }\n  };\n\n  Zoom.prototype.setInteraction = function (newInteraction) {\n    this.lastScale = 1;\n    this.interaction = newInteraction;\n  };\n\n  Zoom.prototype.updateInteraction = function () {\n    if (this.fingers === 2) {\n      this.setInteraction('zoom');\n    } else {\n      this.setInteraction(null);\n    }\n  };\n\n  Zoom.prototype.performPinchZooming = function (e) {\n    var map = this.maps;\n    var prevLevel = map.tileZoomLevel;\n    var availSize = map.mapAreaRect;\n    map.previousScale = map.scale;\n    map.previousPoint = map.translatePoint;\n    var prevTilePoint = map.tileTranslatePoint;\n    var scale = calculateScale(this.touchStartList, this.touchMoveList);\n    var touchCenter = getTouchCenter(getTouches(this.touchMoveList, this.maps));\n    var newScale = scale / this.lastScale;\n    this.lastScale = scale;\n    this.pinchFactor *= newScale;\n    this.pinchFactor = Math.min(this.maps.zoomSettings.maxZoom, Math.max(this.pinchFactor, this.maps.zoomSettings.minZoom));\n    var zoomCalculationFactor = this.pinchFactor;\n    var zoomArgs;\n\n    if (!map.isTileMap) {\n      var minBounds = map.baseMapRectBounds['min'];\n      var maxBounds = map.baseMapRectBounds['max'];\n      var mapTotalWidth = Math.abs(minBounds['x'] - maxBounds['x']);\n      var mapTotalHeight = Math.abs(minBounds['y'] - maxBounds['y']);\n      var translatePoint = map.translatePoint;\n      var currentHeight = Math.abs(map.baseMapRectBounds['max']['y'] - map.baseMapRectBounds['min']['y']) * zoomCalculationFactor;\n      var translatePointX = translatePoint.x - (availSize.width / map.scale - availSize.width / zoomCalculationFactor) / (availSize.width / touchCenter.x);\n      var translatePointY = translatePoint.y - (availSize.height / map.scale - availSize.height / zoomCalculationFactor) / (availSize.height / touchCenter.y);\n      translatePointX = currentHeight < map.mapAreaRect.height ? availSize.x + (-minBounds['x'] + (availSize.width / 2 - mapTotalWidth / 2)) : translatePointX;\n      translatePointY = currentHeight < map.mapAreaRect.height ? availSize.y + (-minBounds['y'] + (availSize.height / 2 - mapTotalHeight / 2)) : translatePointY;\n      map.translatePoint = new Point(translatePointX, translatePointY);\n      map.scale = zoomCalculationFactor;\n      this.triggerZoomEvent(prevTilePoint, prevLevel);\n    } else {\n      var newTileFactor = zoomCalculationFactor;\n      this.getTileTranslatePosition(prevLevel, newTileFactor, {\n        x: touchCenter.x,\n        y: touchCenter.y\n      });\n      map.tileZoomLevel = newTileFactor;\n      map.translatePoint.x = (map.tileTranslatePoint.x - 0.5 * Math.pow(2, newTileFactor)) / Math.pow(2, newTileFactor);\n      map.translatePoint.y = (map.tileTranslatePoint.y - 0.5 * Math.pow(2, newTileFactor)) / Math.pow(2, newTileFactor);\n      map.scale = Math.pow(2, newTileFactor);\n      this.triggerZoomEvent(prevTilePoint, prevLevel);\n      map.mapLayerPanel.generateTiles(newTileFactor, map.tileTranslatePoint);\n    }\n\n    this.applyTransform();\n  };\n\n  Zoom.prototype.drawZoomRectangle = function () {\n    var map = this.maps;\n    var down = this.mouseDownPoints;\n    var move = this.mouseMovePoints;\n    var x;\n    var y;\n    var width;\n    var height;\n    var border = {\n      width: 1,\n      color: '#009900'\n    };\n    width = Math.abs(move.x - down.x);\n    height = Math.abs(move.y - down.y);\n    x = move.x > down.x ? down.x : down.x - width;\n    y = move.y > down.y ? down.y : down.y - height;\n    var elementRect = getElementByID(map.element.id).getBoundingClientRect();\n\n    if (x > map.mapAreaRect.x && x < map.mapAreaRect.x + map.mapAreaRect.width && y > map.mapAreaRect.y && y < map.mapAreaRect.y + map.mapAreaRect.height) {\n      this.zoomingRect = new Rect(x, y, width, height);\n      var rectSVGObject = map.renderer.createSvg({\n        id: map.element.id + '_Selection_Rect_Zooming',\n        width: map.availableSize.width,\n        height: map.availableSize.height\n      });\n      var rectOption = new RectOption(map.element.id + '_ZoomRect', '#d3d3d3', border, 0.5, this.zoomingRect, 0, 0, '', '3');\n      rectSVGObject.appendChild(map.renderer.drawRectangle(rectOption));\n      getElementByID(map.element.id + '_Secondary_Element').appendChild(rectSVGObject);\n    }\n  };\n  /**\n   * To animate the zooming process\n   */\n\n\n  Zoom.prototype.animateTransform = function (element, animate, x, y, scale) {\n    var duration = this.currentLayer.animationDuration;\n\n    if (!animate || duration === 0) {\n      element.setAttribute('transform', 'scale(' + scale + ') translate( ' + x + ' ' + y + ' )');\n      return;\n    }\n\n    zoomAnimate(element, 0, duration, new MapLocation(x, y), scale, this.maps.mapAreaRect, this.maps);\n  }; //tslint:disable:max-func-body-length\n\n\n  Zoom.prototype.applyTransform = function (animate) {\n    var layerIndex;\n    this.templateCount = 0;\n    var layer;\n    var zoomshapelocation;\n    var i;\n    var scale = this.maps.scale;\n    var x = this.maps.translatePoint.x;\n    var y = this.maps.translatePoint.y;\n    var collection = [];\n    this.maps.zoomShapeCollection = [];\n\n    if (this.layerCollectionEle) {\n      for (var i_1 = 0; i_1 < this.layerCollectionEle.childElementCount; i_1++) {\n        var layerElement = this.layerCollectionEle.childNodes[i_1];\n\n        if (layerElement.tagName === 'g') {\n          this.templateCount++;\n          this.index = layerElement.id.indexOf('_LayerIndex_') > -1 && parseFloat(layerElement.id.split('_LayerIndex_')[1].split('_')[0]);\n          this.currentLayer = this.maps.layersCollection[this.index];\n          var factor = this.maps.mapLayerPanel.calculateFactor(this.currentLayer);\n\n          for (var j = 0; j < layerElement.childElementCount; j++) {\n            var currentEle = layerElement.childNodes[j];\n\n            if (!(currentEle.id.indexOf('_Markers_Group') > -1) && !(currentEle.id.indexOf('_bubble_Group') > -1) && !(currentEle.id.indexOf('_dataLableIndex_Group') > -1)) {\n              if (this.maps.isTileMap && currentEle.id.indexOf('_line_Group') > -1) {\n                currentEle.remove();\n\n                if (layerElement.children.length > 0 && layerElement.children[0]) {\n                  layerElement.insertBefore(this.maps.navigationLineModule.renderNavigation(this.currentLayer, this.maps.tileZoomLevel, this.index), layerElement.children[0]);\n                } else {\n                  layerElement.appendChild(this.maps.navigationLineModule.renderNavigation(this.currentLayer, this.maps.tileZoomLevel, this.index));\n                }\n              } else {\n                changeBorderWidth(currentEle, this.index, scale, this.maps);\n                this.maps.zoomTranslatePoint = this.maps.translatePoint;\n                this.animateTransform(currentEle, animate, x, y, scale);\n                this.shapeZoomLocation = currentEle.childNodes;\n              }\n            } else if (currentEle.id.indexOf('_Markers_Group') > -1) {\n              this.markerTranslates(currentEle.childNodes[0], factor, x, y, scale, 'Marker', layerElement, animate);\n              currentEle = layerElement.childNodes[j];\n\n              for (var k = 0; k < currentEle.childElementCount; k++) {\n                this.markerTranslate(currentEle.childNodes[k], factor, x, y, scale, 'Marker', animate);\n              }\n\n              if (this.isPanning && this.maps.markerModule.sameMarkerData.length > 0) {\n                clusterSeparate(this.maps.markerModule.sameMarkerData, this.maps, currentEle, true);\n              } else if (this.maps.markerModule.sameMarkerData.length > 0) {\n                this.maps.markerModule.sameMarkerData = [];\n\n                if (document.getElementById(this.maps.element.id + '_mapsTooltip')) {\n                  removeElement(this.maps.element.id + '_mapsTooltip');\n                }\n              }\n\n              if (document.getElementById(this.maps.element.id + '_mapsTooltip') && this.maps.mapsTooltipModule.targetID.indexOf('_MarkerIndex_')) {\n                var tooltipElement = currentEle.querySelector('#' + this.maps.mapsTooltipModule.targetID);\n\n                if (tooltipElement['style']['visibility'] === 'hidden') {\n                  removeElement(this.maps.element.id + '_mapsTooltip');\n                } else {\n                  var x_1 = parseFloat(tooltipElement.getAttribute('transform').split('(')[1].split(')')[0].split(' ')[1]);\n                  var y_1 = parseFloat(tooltipElement.getAttribute('transform').split('(')[1].split(')')[0].split(' ')[2]);\n\n                  if (this.maps.isTileMap) {\n                    x_1 += +getElement(this.maps.element.id + '_tile_parent')['style']['left'].split('px')[0];\n                    y_1 += +getElement(this.maps.element.id + '_tile_parent')['style']['top'].split('px')[0];\n                  }\n\n                  this.maps.mapsTooltipModule.svgTooltip.location.x = x_1;\n                  this.maps.mapsTooltipModule.svgTooltip.location.y = y_1;\n                  this.maps.mapsTooltipModule.svgTooltip.enableAnimation = false;\n                }\n              }\n            } else if (currentEle.id.indexOf('_bubble_Group') > -1) {\n              var childElement = void 0;\n\n              for (var k = 0; k < currentEle.childElementCount; k++) {\n                childElement = currentEle.childNodes[k];\n                var bubbleTransform = childElement.getAttribute('transform');\n                layerIndex = parseFloat(childElement.id.split('_LayerIndex_')[1].split('_')[0]);\n                var bubleIndex = parseFloat(childElement.id.split('_BubbleIndex_')[1].split('_')[0]);\n                var dataIndex = parseFloat(childElement.id.split('_BubbleIndex_')[1].split('_')[2]);\n\n                for (var l = 0; l < this.maps.bubbleModule.bubbleCollection.length; l++) {\n                  var bubbleCollection = this.maps.bubbleModule.bubbleCollection[l];\n\n                  if (bubbleCollection['LayerIndex'] === layerIndex && bubbleCollection['BubbleIndex'] === bubleIndex && bubbleCollection['DataIndex'] === dataIndex) {\n                    var centerX = bubbleCollection['center']['x'];\n                    var centerY = bubbleCollection['center']['y'];\n                    var currentX = (centerX + x) * scale;\n                    var currentY = (centerY + y) * scale;\n                    var duration = this.currentLayer.animationDuration;\n\n                    if (!animate || duration === 0) {\n                      childElement.setAttribute('transform', 'translate( ' + currentX + ' ' + currentY + ' )');\n                    } else {\n                      smoothTranslate(childElement, 0, duration, new MapLocation(currentX, currentY));\n                    }\n\n                    break;\n                  }\n                }\n              }\n            } else if (currentEle.id.indexOf('_dataLableIndex_Group') > -1) {\n              this.intersect = [];\n              this.maps.zoomLabelPositions = [];\n              this.maps.zoomLabelPositions = this.maps.dataLabelModule.dataLabelCollections;\n\n              for (var k = 0; k < currentEle.childElementCount; k++) {\n                if (currentEle.childNodes[k]['id'].indexOf('_LabelIndex_') > -1) {\n                  var labelIndex = parseFloat(currentEle.childNodes[k]['id'].split('_LabelIndex_')[1].split('_')[0]);\n                  this.zoomshapewidth = this.shapeZoomLocation[labelIndex].getBoundingClientRect();\n                  this.maps.zoomShapeCollection.push(this.zoomshapewidth);\n                  this.dataLabelTranslate(currentEle.childNodes[k], factor, x, y, scale, 'DataLabel', animate);\n                  var dataLabel = this.maps.layers[this.index].dataLabelSettings;\n                  var border = dataLabel.border;\n\n                  if (k > 0 && border['width'] > 1) {\n                    if (currentEle.childNodes[k - 1]['id'].indexOf('_rectIndex_') > -1) {\n                      var labelX = (this.maps.zoomLabelPositions[labelIndex]['location']['x'] + x) * scale;\n                      var labelY = (this.maps.zoomLabelPositions[labelIndex]['location']['y'] + y) * scale;\n                      var zoomtext = currentEle.childNodes[k]['innerHTML'];\n                      var style = this.maps.layers[this.index].dataLabelSettings.textStyle;\n                      var zoomtextSize = measureText(zoomtext, style);\n                      var padding = 5;\n                      var rectElement = currentEle.childNodes[k - 1];\n                      var rectX = labelX - zoomtextSize['width'] / 2;\n                      var rectY = labelY - zoomtextSize['height'] / 2 - padding;\n                      rectElement['setAttribute']('x', rectX);\n                      rectElement['setAttribute']('y', rectY);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (!isNullOrUndefined(this.currentLayer)) {\n        if (!animate || this.currentLayer.animationDuration === 0) {\n          this.processTemplate(x, y, scale, this.maps);\n        }\n      }\n    }\n  }; //tslint:disable\n\n\n  Zoom.prototype.markerTranslates = function (element, factor, x, y, scale, type, layerElement, animate) {\n    var _this = this;\n\n    if (animate === void 0) {\n      animate = false;\n    }\n\n    var markerSVGObject;\n    var templateFn;\n    var layerIndex = parseInt(element.id.split('_LayerIndex_')[1].split('_')[0], 10);\n    markerSVGObject = this.maps.renderer.createGroup({\n      id: this.maps.element.id + '_Markers_Group',\n      style: 'pointer-events: auto;'\n    });\n\n    if (document.getElementById(markerSVGObject.id)) {\n      removeElement(markerSVGObject.id);\n    }\n\n    var markerTemplateEle = createElement('div', {\n      id: this.maps.element.id + '_LayerIndex_' + layerIndex + '_Markers_Template_Group',\n      className: 'template',\n      styles: 'overflow: hidden; position: absolute;pointer-events: none;' + 'top:' + (this.maps.isTileMap ? 10 : this.maps.mapAreaRect.y) + 'px;' + 'left:' + (this.maps.isTileMap ? 10 : this.maps.mapAreaRect.x) + 'px;' + 'height:' + this.maps.mapAreaRect.height + 'px;' + 'width:' + this.maps.mapAreaRect.width + 'px;'\n    });\n\n    if (document.getElementById(markerTemplateEle.id)) {\n      removeElement(markerTemplateEle.id);\n    }\n\n    var markerIndex = parseInt(element.id.split('_MarkerIndex_')[1].split('_')[0], 10);\n    var currentLayer = this.maps.layersCollection[layerIndex];\n    currentLayer.markerSettings.map(function (markerSettings, markerIndex) {\n      var markerDatas = markerSettings.dataSource;\n      markerDatas.forEach(function (data, dataIndex) {\n        var eventArgs = {\n          template: markerSettings.template,\n          data: data,\n          maps: _this.maps,\n          marker: markerSettings,\n          cancel: false,\n          name: markerRendering,\n          fill: markerSettings.fill,\n          height: markerSettings.height,\n          width: markerSettings.width,\n          imageUrl: markerSettings.imageUrl,\n          shape: markerSettings.shape,\n          border: markerSettings.border\n        };\n\n        if (_this.maps.isBlazor) {\n          var maps = eventArgs.maps,\n              marker_1 = eventArgs.marker,\n              blazorEventArgs = __rest(eventArgs, [\"maps\", \"marker\"]);\n\n          eventArgs = blazorEventArgs;\n        }\n\n        _this.maps.trigger('markerRendering', eventArgs, function (MarkerArgs) {\n          var long = data['longitude'];\n          var lati = data['latitude'];\n          var offset = markerSettings.offset;\n\n          if (!eventArgs.cancel && markerSettings.visible && !isNullOrUndefined(long) && !isNullOrUndefined(lati)) {\n            var markerID = _this.maps.element.id + '_LayerIndex_' + layerIndex + '_MarkerIndex_' + markerIndex + '_dataIndex_' + dataIndex;\n            var location_1 = _this.maps.isTileMap ? convertTileLatLongToPoint(new MapLocation(long, lati), _this.maps.tileZoomLevel, _this.maps.tileTranslatePoint, true) : convertGeoToPoint(lati, long, factor, currentLayer, _this.maps);\n            var animate_1 = currentLayer.animationDuration !== 0 || isNullOrUndefined(_this.maps.zoomModule);\n            var transPoint = {\n              x: x,\n              y: y\n            };\n\n            if (eventArgs.template) {\n              markerTemplate(eventArgs, templateFn, markerID, data, markerIndex, markerTemplateEle, location_1, scale, offset, _this.maps);\n            } else {\n              marker(eventArgs, markerSettings, markerDatas, dataIndex, location_1, transPoint, markerID, offset, scale, _this.maps, markerSVGObject);\n            }\n          }\n        });\n      });\n    });\n\n    if (markerSVGObject.childElementCount > 0 && type !== 'Template') {\n      layerElement.appendChild(markerSVGObject);\n\n      if (currentLayer.markerClusterSettings.allowClustering) {\n        this.maps.svgObject.appendChild(markerSVGObject);\n        this.maps.element.appendChild(this.maps.svgObject);\n        clusterTemplate(currentLayer, markerSVGObject, this.maps, layerIndex, markerSVGObject);\n        layerElement.appendChild(markerSVGObject);\n      }\n    }\n\n    if (markerTemplateEle.childElementCount > 0 && getElementByID(this.maps.element.id + '_Secondary_Element')) {\n      getElementByID(this.maps.element.id + '_Secondary_Element').appendChild(markerTemplateEle);\n\n      if (currentLayer.markerClusterSettings.allowClustering) {\n        clusterTemplate(currentLayer, markerTemplateEle, this.maps, layerIndex, markerSVGObject);\n        getElementByID(this.maps.element.id + '_Secondary_Element').appendChild(markerTemplateEle);\n      }\n    }\n  };\n\n  ;\n  /**\n   * To translate the layer template elements\n   * @private\n   */\n\n  Zoom.prototype.processTemplate = function (x, y, scale, maps) {\n    for (var i = 0; i < this.templateCount; i++) {\n      this.currentLayer = maps.layersCollection[i];\n      var factor = maps.mapLayerPanel.calculateFactor(this.currentLayer);\n      var markerTemplateElement = getElementByID(maps.element.id + '_LayerIndex_' + i + '_Markers_Template_Group');\n      var datalabelTemplateElemement = getElementByID(maps.element.id + '_LayerIndex_' + i + '_Label_Template_Group');\n\n      if (!isNullOrUndefined(markerTemplateElement) && markerTemplateElement.childElementCount > 0) {\n        for (var k = 0; k < markerTemplateElement.childElementCount; k++) {\n          this.markerTranslate(markerTemplateElement.childNodes[k], factor, x, y, scale, 'Template');\n        }\n      }\n\n      if (!isNullOrUndefined(datalabelTemplateElemement) && datalabelTemplateElemement.childElementCount > 0) {\n        for (var k = 0; k < datalabelTemplateElemement.childElementCount; k++) {\n          this.dataLabelTranslate(datalabelTemplateElemement.childNodes[k], factor, x, y, scale, 'Template');\n        }\n      }\n    }\n  }; //tslint:disable:max-func-body-length\n\n\n  Zoom.prototype.dataLabelTranslate = function (element, factor, x, y, scale, type, animate) {\n    if (animate === void 0) {\n      animate = false;\n    }\n\n    var labelCollection = this.maps.dataLabelModule.dataLabelCollections;\n    var zoomelement = element.getBoundingClientRect();\n    var text;\n    var trimmedLable;\n    var style = this.maps.layers[this.index].dataLabelSettings.textStyle;\n    var zoomtext;\n    var zoomtextSize;\n    var zoomtrimLabel;\n    var labelPath = this.maps.layers[this.index].dataLabelSettings.labelPath;\n    var layerIndex = parseFloat(element.id.split('_LayerIndex_')[1].split('_')[0]);\n    var shapeIndex = parseFloat(element.id.split('_shapeIndex_')[1].split('_')[0]);\n    var labelIndex;\n\n    if (element.id.indexOf('_LabelIndex_') > -1) {\n      labelIndex = parseFloat(element.id.split('_LabelIndex_')[1].split('_')[0]);\n    }\n\n    var duration = this.currentLayer.animationDuration;\n\n    for (var l = 0; l < labelCollection.length; l++) {\n      var label = labelCollection[l];\n\n      if (label['layerIndex'] === layerIndex && label['shapeIndex'] === shapeIndex && label['labelIndex'] === labelIndex) {\n        var labelX = label['location']['x'];\n        var labelY = label['location']['y'];\n\n        if (type === 'Template') {\n          var layerEle = getElementByID(this.maps.element.id + '_Layer_Collections');\n          labelX = Math.abs(this.maps.baseMapRectBounds['min']['x'] - labelX) * scale;\n          labelY = Math.abs(this.maps.baseMapRectBounds['min']['y'] - labelY) * scale;\n          var templateOffset = element.getBoundingClientRect();\n          var layerOffset = layerEle.getBoundingClientRect();\n          var elementOffset = element.parentElement.getBoundingClientRect();\n          var x_2 = labelX + (layerOffset.left - elementOffset.left) - templateOffset.width / 2;\n          var y_2 = labelY + (layerOffset.top - elementOffset.top) - templateOffset.height / 2;\n          element.style.left = x_2 + 'px';\n          element.style.top = y_2 + 'px';\n        } else {\n          labelX = (labelX + x) * scale;\n          labelY = (labelY + y) * scale;\n          zoomtext = label['dataLabelText'];\n          zoomtextSize = measureText(zoomtext, style);\n          var start = labelY - zoomtextSize['height'] / 4;\n          var end = labelY + zoomtextSize['height'] / 4;\n          var xpositionEnds = labelX + zoomtextSize['width'] / 2;\n          var xpositionStart = labelX - zoomtextSize['width'] / 2;\n          var textLocations = {\n            rightWidth: xpositionEnds,\n            leftWidth: xpositionStart,\n            heightTop: start,\n            heightBottom: end\n          };\n\n          if (!animate || duration === 0) {\n            element.setAttribute('transform', 'translate( ' + labelX + ' ' + labelY + ' )');\n          }\n\n          if (this.maps.layers[this.index].dataLabelSettings.smartLabelMode === 'Hide') {\n            if (scale > 1) {\n              text = this.zoomshapewidth['width'] >= zoomtextSize['width'] ? zoomtext : '';\n              element.innerHTML = text;\n            } else {\n              text = this.maps.dataLabelShape[l] >= zoomtextSize['width'] ? zoomtext : '';\n              element.innerHTML = text;\n            }\n          }\n\n          if (this.maps.layers[this.index].dataLabelSettings.smartLabelMode === 'Trim') {\n            if (scale > 1) {\n              zoomtrimLabel = textTrim(this.zoomshapewidth['width'], zoomtext, style);\n              text = zoomtrimLabel;\n              element.innerHTML = text;\n            } else {\n              zoomtrimLabel = textTrim(this.maps.dataLabelShape[l], zoomtext, style);\n              text = zoomtrimLabel;\n              element.innerHTML = text;\n            }\n          }\n\n          if (this.maps.layers[this.index].dataLabelSettings.intersectionAction === 'Hide') {\n            for (var m = 0; m < this.intersect.length; m++) {\n              if (!isNullOrUndefined(this.intersect[m])) {\n                if (textLocations['leftWidth'] > this.intersect[m]['rightWidth'] || textLocations['rightWidth'] < this.intersect[m]['leftWidth'] || textLocations['heightTop'] > this.intersect[m]['heightBottom'] || textLocations['heightBottom'] < this.intersect[m]['heightTop']) {\n                  text = !isNullOrUndefined(text) ? text : zoomtext;\n                  element.innerHTML = text;\n                } else {\n                  text = '';\n                  element.innerHTML = text;\n                  break;\n                }\n              }\n            }\n\n            this.intersect.push(textLocations);\n          }\n\n          if (this.maps.layers[this.index].dataLabelSettings.intersectionAction === 'Trim') {\n            for (var j = 0; j < this.intersect.length; j++) {\n              if (!isNullOrUndefined(this.intersect[j])) {\n                if (textLocations['rightWidth'] < this.intersect[j]['leftWidth'] || textLocations['leftWidth'] > this.intersect[j]['rightWidth'] || textLocations['heightBottom'] < this.intersect[j]['heightTop'] || textLocations['heightTop'] > this.intersect[j]['heightBottom']) {\n                  trimmedLable = !isNullOrUndefined(text) ? text : zoomtext;\n\n                  if (scale > 1) {\n                    trimmedLable = textTrim(this.zoomshapewidth['width'], trimmedLable, style);\n                  }\n\n                  element.innerHTML = trimmedLable;\n                } else {\n                  if (textLocations['leftWidth'] > this.intersect[j]['leftWidth']) {\n                    var width = this.intersect[j]['rightWidth'] - textLocations['leftWidth'];\n                    var difference = width - (textLocations['rightWidth'] - textLocations['leftWidth']);\n                    text = !isNullOrUndefined(text) ? text : zoomtext;\n                    trimmedLable = textTrim(difference, text, style);\n                    element.innerHTML = trimmedLable;\n                    break;\n                  }\n\n                  if (textLocations['leftWidth'] < this.intersect[j]['leftWidth']) {\n                    var width = textLocations['rightWidth'] - this.intersect[j]['leftWidth'];\n                    var difference = Math.abs(width - (textLocations['rightWidth'] - textLocations['leftWidth']));\n                    text = !isNullOrUndefined(text) ? text : zoomtext;\n                    trimmedLable = textTrim(difference, text, style);\n                    element.innerHTML = trimmedLable;\n                    break;\n                  }\n                }\n              }\n            }\n\n            this.intersect.push(textLocations);\n\n            if (isNullOrUndefined(trimmedLable)) {\n              trimmedLable = textTrim(this.zoomshapewidth['width'], zoomtext, style);\n              element.innerHTML = trimmedLable;\n            }\n          } else {\n            smoothTranslate(element, 0, duration, new MapLocation(labelX, labelY));\n          }\n        }\n      }\n    }\n  };\n\n  Zoom.prototype.markerTranslate = function (element, factor, x, y, scale, type, animate) {\n    if (animate === void 0) {\n      animate = false;\n    }\n\n    var layerIndex = parseInt(element.id.split('_LayerIndex_')[1].split('_')[0], 10);\n    var markerIndex = parseInt(element.id.split('_MarkerIndex_')[1].split('_')[0], 10);\n    var dataIndex = parseInt(element.id.split('_dataIndex_')[1].split('_')[0], 10);\n    var layer = this.maps.layersCollection[layerIndex];\n    var marker = layer.markerSettings[markerIndex];\n\n    if (!isNullOrUndefined(marker) && !isNullOrUndefined(marker.dataSource) && !isNullOrUndefined(marker.dataSource[dataIndex])) {\n      var lng = marker.dataSource[dataIndex]['longitude'];\n      var lat = marker.dataSource[dataIndex]['latitude'];\n      var duration = this.currentLayer.animationDuration;\n      var location_2 = this.maps.isTileMap ? convertTileLatLongToPoint(new Point(lng, lat), this.maps.tileZoomLevel, this.maps.tileTranslatePoint, true) : convertGeoToPoint(lat, lng, factor, layer, this.maps);\n      location_2.y = this.maps.zoomSettings.enable && this.maps.isTileMap ? location_2.y - 10 : location_2.y;\n\n      if (this.maps.isTileMap) {\n        if (type === 'Template') {\n          var templateOffset = element.getBoundingClientRect();\n          element.style.left = location_2.x - templateOffset.width / 2 + 'px';\n          element.style.top = location_2.y - templateOffset.height / 2 + 'px';\n        } else {\n          element.setAttribute('transform', 'translate( ' + location_2.x + ' ' + location_2.y + ' )');\n        }\n      } else {\n        if (type === 'Template') {\n          location_2.x = Math.abs(this.maps.baseMapRectBounds['min']['x'] - location_2.x) * scale;\n          location_2.y = Math.abs(this.maps.baseMapRectBounds['min']['y'] - location_2.y) * scale;\n          var templateOffset = element.getBoundingClientRect();\n          var layerOffset = getElementByID(this.maps.element.id + '_Layer_Collections').getBoundingClientRect();\n          var elementOffset = element.parentElement.getBoundingClientRect();\n          element.style.left = location_2.x + (layerOffset.left - elementOffset.left) - templateOffset.width / 2 + marker.offset.x + 'px';\n          element.style.top = location_2.y + (layerOffset.top - elementOffset.top) - templateOffset.height / 2 + marker.offset.y + 'px';\n        } else {\n          location_2.x = (location_2.x + x) * scale + marker.offset.x;\n          location_2.y = (location_2.y + y) * scale + marker.offset.y;\n\n          if (!animate || duration === 0) {\n            element.setAttribute('transform', 'translate( ' + location_2.x + ' ' + location_2.y + ' )');\n          } else {\n            smoothTranslate(element, 0, duration, location_2);\n          }\n        }\n      }\n    }\n  };\n\n  Zoom.prototype.panning = function (direction, xDifference, yDifference) {\n    var map = this.maps;\n    var panArgs;\n    var down = this.mouseDownPoints;\n    var move = this.mouseMovePoints;\n    var scale = map.scale;\n    var translatePoint = map.translatePoint;\n    var prevTilePoint = map.tileTranslatePoint;\n    var x;\n    var y;\n    xDifference = !isNullOrUndefined(xDifference) ? xDifference : down.x - move.x;\n    yDifference = !isNullOrUndefined(yDifference) ? yDifference : down.y - move.y;\n\n    if (!map.isTileMap) {\n      x = translatePoint.x - xDifference / scale;\n      y = translatePoint.y - yDifference / scale;\n      var layerRect = getElementByID(map.element.id + '_Layer_Collections').getBoundingClientRect();\n      var elementRect = getElementByID(map.element.id + '_svg').getBoundingClientRect();\n      var panningXDirection = xDifference < 0 ? layerRect.left <= elementRect.left + map.mapAreaRect.x : layerRect.left + layerRect.width >= elementRect.left + elementRect.width + map.mapAreaRect.x + map.margin.left;\n      var panningYDirection = yDifference < 0 ? layerRect.top <= elementRect.top + map.mapAreaRect.y : layerRect.top + layerRect.height >= elementRect.top + elementRect.height + map.mapAreaRect.y + map.margin.top;\n      panArgs = {\n        cancel: false,\n        name: pan,\n        maps: !map.isBlazor ? map : null,\n        tileTranslatePoint: {},\n        translatePoint: {\n          previous: translatePoint,\n          current: new Point(x, y)\n        },\n        scale: map.scale,\n        tileZoomLevel: map.tileZoomLevel\n      };\n      map.trigger(pan, panArgs);\n\n      if (panningXDirection && panningYDirection) {\n        map.translatePoint = new Point(x, y);\n        this.applyTransform();\n      } else if (panningXDirection) {\n        map.translatePoint = new Point(x, map.translatePoint.y);\n        this.applyTransform();\n      } else if (panningYDirection) {\n        map.translatePoint = new Point(map.translatePoint.x, y);\n        this.applyTransform();\n      }\n    } else if (this.maps.tileZoomLevel > 1) {\n      x = map.tileTranslatePoint.x - xDifference;\n      y = map.tileTranslatePoint.y - yDifference;\n      this.distanceX = x - map.tileTranslatePoint.x;\n      this.distanceY = y - map.tileTranslatePoint.y;\n      map.tileTranslatePoint.x = x;\n      map.tileTranslatePoint.y = y;\n      map.translatePoint.x = (map.tileTranslatePoint.x - xDifference) / map.scale;\n      map.translatePoint.y = (map.tileTranslatePoint.y - yDifference) / map.scale;\n      panArgs = {\n        cancel: false,\n        name: pan,\n        maps: !map.isBlazor ? map : null,\n        tileTranslatePoint: {\n          previous: prevTilePoint,\n          current: map.tileTranslatePoint\n        },\n        translatePoint: {\n          previous: translatePoint,\n          current: map.translatePoint\n        },\n        scale: map.scale,\n        tileZoomLevel: map.tileZoomLevel\n      };\n      map.trigger(pan, panArgs);\n      map.mapLayerPanel.generateTiles(map.tileZoomLevel, map.tileTranslatePoint);\n      this.applyTransform();\n    }\n\n    map.zoomTranslatePoint = map.translatePoint;\n    this.mouseDownPoints = this.mouseMovePoints;\n    this.flag = false;\n  };\n\n  Zoom.prototype.toAlignSublayer = function () {\n    this.maps.translatePoint.x = !isNullOrUndefined(this.distanceX) ? this.maps.translatePoint.x - this.distanceX / this.maps.scale : this.maps.translatePoint.x;\n    this.maps.translatePoint.y = !isNullOrUndefined(this.distanceY) ? this.maps.translatePoint.y - this.distanceY / this.maps.scale : this.maps.translatePoint.y;\n    this.applyTransform(false);\n  };\n\n  Zoom.prototype.toolBarZooming = function (zoomFactor, type) {\n    var map = this.maps;\n    var prevLevel = map.tileZoomLevel;\n    var scale = map.previousScale = map.scale;\n    map.mapScaleValue = zoomFactor;\n    var maxZoom = map.zoomSettings.maxZoom;\n    var minZoom = map.zoomSettings.minZoom;\n    var size = map.mapAreaRect;\n    var translatePoint = map.previousPoint = map.translatePoint;\n    var prevTilePoint = map.tileTranslatePoint;\n    map.previousProjection = map.projectionType;\n    zoomFactor = type === 'ZoomOut' ? Math.round(zoomFactor) === 1 ? 1 : zoomFactor : zoomFactor;\n    var zoomArgs;\n\n    if (!map.isTileMap && (type === 'ZoomIn' ? zoomFactor >= minZoom && zoomFactor <= maxZoom : zoomFactor >= minZoom)) {\n      var min = map.baseMapRectBounds['min'];\n      var max = map.baseMapRectBounds['max'];\n      var mapWidth = Math.abs(max['x'] - min['x']);\n      var mapHeight = Math.abs(min['y'] - max['y']);\n      var translatePointX = translatePoint.x - (size.width / scale - size.width / zoomFactor) / 2;\n      var translatePointY = translatePoint.y - (size.height / scale - size.height / zoomFactor) / 2;\n      var currentHeight = Math.abs(map.baseMapRectBounds['max']['y'] - map.baseMapRectBounds['min']['y']) * zoomFactor;\n      translatePointX = currentHeight < map.mapAreaRect.height ? size.x + (-min['x'] + (size.width / 2 - mapWidth / 2)) : translatePointX;\n      translatePointY = currentHeight < map.mapAreaRect.height ? size.y + (-min['y'] + (size.height / 2 - mapHeight / 2)) : translatePointY;\n      map.translatePoint = new Point(translatePointX, translatePointY);\n      map.zoomTranslatePoint = map.translatePoint;\n      map.scale = zoomFactor;\n      this.triggerZoomEvent(prevTilePoint, prevLevel);\n    } else if (map.isTileMap && zoomFactor >= minZoom && zoomFactor <= maxZoom) {\n      var tileZoomFactor = zoomFactor;\n      map.scale = Math.pow(2, tileZoomFactor - 1);\n      map.tileZoomLevel = tileZoomFactor;\n      var position = {\n        x: map.availableSize.width / 2,\n        y: map.availableSize.height / 2\n      };\n      this.getTileTranslatePosition(prevLevel, tileZoomFactor, position);\n      map.translatePoint.x = (map.tileTranslatePoint.x - 0.01 * map.scale) / map.scale;\n      map.translatePoint.y = (map.tileTranslatePoint.y - 0.01 * map.scale) / map.scale;\n      this.triggerZoomEvent(prevTilePoint, prevLevel);\n      map.mapLayerPanel.generateTiles(tileZoomFactor, map.tileTranslatePoint);\n    }\n\n    this.applyTransform(true);\n  };\n  /* tslint:disable:max-func-body-length */\n\n\n  Zoom.prototype.createZoomingToolbars = function () {\n    var map = this.maps;\n    this.toolBarGroup = map.renderer.createGroup({\n      id: map.element.id + '_Zooming_KitCollection',\n      opacity: 0.3\n    });\n    var kitHeight = 16;\n    var kitWidth = 16;\n    var xSpacing = 15;\n    var ySpacing = 15;\n    var padding = 20;\n    var orientation = map.zoomSettings.toolBarOrientation;\n    var toolbarsCollection = map.zoomSettings.toolbars;\n    var shadowElement = '<filter id=\"chart_shadow\" height=\"130%\"><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"5\"/>';\n    shadowElement += '<feOffset dx=\"-3\" dy=\"4\" result=\"offsetblur\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"1\"/>';\n    shadowElement += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n    var toolBarLength = map.zoomSettings.toolbars.length;\n    var toolWidth = map.zoomSettings.toolBarOrientation === 'Horizontal' ? toolBarLength * kitWidth + toolBarLength * padding : kitWidth * 2;\n    var toolHeight = map.zoomSettings.toolBarOrientation === 'Horizontal' ? kitHeight * 2 : toolBarLength * kitHeight + toolBarLength * padding;\n    this.toolBarGroup.appendChild(map.renderer.drawRectangle(new RectOption(map.element.id + '_Zooming_Rect', 'transparent', {\n      color: 'transparent',\n      width: 1\n    }, 1, new Rect(0, 0, toolWidth, toolHeight), 0, 0)));\n    var defElement = map.renderer.createDefs();\n    defElement.innerHTML = shadowElement;\n    this.toolBarGroup.appendChild(defElement);\n    var outerElement = map.renderer.drawRectangle(new RectOption(map.element.id + '_Zooming_Rect', 'transparent', {\n      color: 'transparent',\n      width: 1\n    }, 0.1, new Rect(0, 0, toolWidth, toolHeight), 0, 0));\n    outerElement.setAttribute('filter', 'url(#chart_shadow)');\n    this.toolBarGroup.appendChild(outerElement);\n    var performFunction;\n\n    for (var i = 0; i < toolbarsCollection.length; i++) {\n      var toolbar_1 = toolbarsCollection[i];\n      var pathOptions = void 0;\n      var polyOptions = void 0;\n      this.currentToolbarEle = map.renderer.createGroup({\n        id: map.element.id + '_Zooming_ToolBar_' + toolbar_1 + '_Group',\n        transform: 'translate( ' + xSpacing + ' ' + ySpacing + ' ) '\n      });\n      this.currentToolbarEle.setAttribute('class', 'e-maps-toolbar');\n      var fillColor = '';\n      var fill = 'transparent';\n      var direction = '';\n      var polygonDirection = '';\n\n      switch (toolbar_1.toLowerCase()) {\n        case 'zoom':\n          direction = 'M0.001,14.629L1.372,16l4.571-4.571v-0.685l0.228-0.274c1.051,0.868,2.423,1.417,3.885,1.417c3.291,0,';\n          direction += '5.943-2.651,5.943-5.943S13.395,0,10.103,0S4.16,2.651,4.16,5.943c0,1.508,0.503,2.834,1.417,3.885l-0.274,0.228H4.571';\n          direction = direction + 'L0.001,14.629L0.001,14.629z M5.943,5.943c0-2.285,1.828-4.114,4.114-4.114s4.114,1.828,4.114,';\n          this.currentToolbarEle.appendChild(map.renderer.drawPath(new PathOption(map.element.id + '_Zooming_ToolBar_' + toolbar_1, fill, 1, this.maps.themeStyle.zoomFillColor, 1, null, direction + '4.114s-1.828,4.114-4.114,4.114S5.943,8.229,5.943,5.943z')));\n          this.zoomElements = this.currentToolbarEle;\n          this.wireEvents(this.currentToolbarEle, this.performToolBarAction);\n          break;\n\n        case 'zoomin':\n          direction = 'M 8, 0 L 8, 16 M 0, 8 L 16, 8';\n          this.currentToolbarEle.appendChild(map.renderer.drawPath(new PathOption(map.element.id + '_Zooming_ToolBar_' + toolbar_1 + '_Path', fill, 3, this.maps.themeStyle.zoomFillColor, 1, null, direction)));\n          this.zoomInElements = this.currentToolbarEle;\n          this.wireEvents(this.currentToolbarEle, this.performToolBarAction);\n          break;\n\n        case 'zoomout':\n          direction = 'M 0, 8 L 16, 8';\n          this.currentToolbarEle.appendChild(map.renderer.drawPath(new PathOption(map.element.id + '_Zooming_ToolBar_' + toolbar_1, fill, 3, this.maps.themeStyle.zoomFillColor, 1, null, direction)));\n          this.zoomOutElements = this.currentToolbarEle;\n          this.wireEvents(this.currentToolbarEle, this.performToolBarAction);\n          break;\n\n        case 'pan':\n          direction = 'M5,3h2.3L7.275,5.875h1.4L8.65,3H11L8,0L5,3z M3,11V8.7l2.875,0.025v-1.4L3,7.35V5L0,8L3,';\n          direction += '11z M11,13H8.7l0.025-2.875h-1.4L7.35,13H5l3,3L11,13z M13,5v2.3l-2.875-0.025v1.4L13,8.65V11l3-3L13,5z';\n          this.currentToolbarEle.appendChild(map.renderer.drawPath(new PathOption(map.element.id + '_Zooming_ToolBar_' + toolbar_1, this.selectionColor, 1, this.selectionColor, 1, null, direction)));\n          this.panColor = this.selectionColor;\n          this.panElements = this.currentToolbarEle;\n          this.wireEvents(this.currentToolbarEle, this.performToolBarAction);\n          break;\n\n        case 'reset':\n          direction = 'M12.364,8h-2.182l2.909,3.25L16,8h-2.182c0-3.575-2.618-6.5-5.818-6.5c-1.128,0-2.218,0.366-3.091,';\n          direction += '1.016l1.055,1.178C6.581,3.328,7.272,3.125,8,3.125C10.4,3.125,12.363,5.319,12.364,8L12.364,8z M11.091,';\n          direction += '13.484l-1.055-1.178C9.419,12.672,8.728,12.875,8,12.875c-2.4,0-4.364-2.194-4.364-4.875h2.182L2.909,4.75L0,8h2.182c0,';\n          this.currentToolbarEle.appendChild(map.renderer.drawPath(new PathOption(map.element.id + '_Zooming_ToolBar_' + toolbar_1, this.fillColor, null, this.maps.themeStyle.zoomFillColor, 1, null, direction + '3.575,2.618,6.5,5.818,6.5C9.128,14.5,10.219,14.134,11.091,13.484L11.091,13.484z')));\n          this.wireEvents(this.currentToolbarEle, this.performToolBarAction);\n          break;\n      }\n\n      this.currentToolbarEle.appendChild(map.renderer.drawCircle(new CircleOption(map.element.id + '_Zooming_ToolBar_' + toolbar_1 + '_Rect', fill, {\n        color: this.maps.themeStyle.zoomFillColor,\n        width: 1\n      }, 1, 8, 8, 16, '')));\n      xSpacing = orientation === 'Horizontal' ? xSpacing + (kitWidth + padding) : xSpacing;\n      ySpacing = orientation === 'Horizontal' ? ySpacing : ySpacing + (kitHeight + padding);\n      this.toolBarGroup.appendChild(this.currentToolbarEle);\n    }\n  };\n\n  Zoom.prototype.performToolBarAction = function (e) {\n    var target = e.target;\n    e.stopImmediatePropagation();\n    var isTouch = e.pointerType === 'touch' || e.pointerType === '2' || e.type.indexOf('touch') > -1;\n    var toolbar = target.id.split('_Zooming_ToolBar_')[1].split('_')[0];\n\n    if (isTouch) {\n      this.handled = true;\n      this.performZoomingByToolBar(toolbar);\n    } else if ((e.type === 'mousedown' || e.type === 'pointerdown') && !this.handled) {\n      this.handled = false;\n      this.performZoomingByToolBar(toolbar);\n    } else {\n      this.handled = false;\n    }\n  };\n  /**\n   *\n   * @private\n   */\n\n\n  Zoom.prototype.performZoomingByToolBar = function (type) {\n    var map = this.maps;\n\n    switch (type.toLowerCase()) {\n      case 'zoom':\n        this.panColor = this.fillColor;\n        this.zoomColor = this.selectionColor;\n        this.applySelection(this.zoomElements, this.selectionColor);\n        this.applySelection(this.panElements, this.fillColor);\n        break;\n\n      case 'pan':\n        this.panColor = this.selectionColor;\n        this.zoomColor = this.fillColor;\n        this.applySelection(this.zoomElements, this.fillColor);\n        this.applySelection(this.panElements, this.selectionColor);\n        break;\n\n      case 'zoomin':\n        this.toolBarZooming((map.isTileMap ? map.tileZoomLevel : map.scale) + 1, 'ZoomIn');\n        break;\n\n      case 'zoomout':\n        this.toolBarZooming((map.isTileMap ? map.tileZoomLevel : map.scale) - 1, 'ZoomOut');\n        break;\n\n      case 'reset':\n        this.toolBarZooming(1, 'ZoomOut');\n        this.applySelection(this.zoomElements, this.fillColor);\n        this.applySelection(this.panElements, this.selectionColor);\n    }\n\n    this.panningStyle(type.toLowerCase());\n  };\n\n  Zoom.prototype.panningStyle = function (toolbar) {\n    var svg = getElementByID(this.maps.element.id + '_svg');\n\n    if (toolbar === 'pan' || this.isPanning) {\n      svg.setAttribute('class', 'e-maps-panning');\n    } else {\n      svg.setAttribute('class', '');\n    }\n  };\n\n  Zoom.prototype.applySelection = function (elements, color) {\n    if (!elements) {\n      return;\n    }\n\n    var childElement;\n\n    for (var i = 0; i < elements.childElementCount; i++) {\n      childElement = elements.childNodes[i];\n\n      if (childElement.tagName !== 'circle') {\n        childElement.setAttribute('fill', color);\n        childElement.setAttribute('stroke', color);\n      }\n    }\n  };\n\n  Zoom.prototype.showTooltip = function (e) {\n    var text = e.target.id.split('_Zooming_ToolBar_')[1].split('_')[0];\n\n    if (!this.isTouch) {\n      createTooltip('EJ2_Map_Toolbar_Tip', this.maps.getLocalizedLabel(text), e.pageY + 10, e.pageX + 10, '10px');\n    }\n  };\n\n  Zoom.prototype.removeTooltip = function () {\n    if (getElementByID('EJ2_Map_Toolbar_Tip')) {\n      remove(getElementByID('EJ2_Map_Toolbar_Tip'));\n    }\n  };\n\n  Zoom.prototype.alignToolBar = function () {\n    var map = this.maps;\n    var padding = 10;\n    var element = createElement('div', {\n      id: map.element.id + '_ToolBar',\n      styles: 'position:absolute;z-index:2'\n    });\n    var rectSVGObject = map.renderer.createSvg({\n      id: map.element.id + '_Zooming_ToolBar',\n      width: 10,\n      height: 10\n    });\n    rectSVGObject.appendChild(this.toolBarGroup);\n    element.appendChild(rectSVGObject);\n\n    if (getElementByID(map.element.id + '_Secondary_Element')) {\n      getElementByID(map.element.id + '_Secondary_Element').appendChild(element);\n    }\n\n    var toolBarSize = this.toolBarGroup.getBoundingClientRect();\n    rectSVGObject.setAttribute('height', (toolBarSize.height + padding / 2).toString());\n    rectSVGObject.setAttribute('width', (toolBarSize.width + padding / 2).toString());\n    var size = map.mapAreaRect;\n    var x = 0;\n    var y = 0;\n\n    switch (map.zoomSettings.verticalAlignment) {\n      case 'Near':\n        y = size.y;\n        break;\n\n      case 'Center':\n        y = size.height / 2 - toolBarSize.height / 2;\n        break;\n\n      case 'Far':\n        y = size.height - toolBarSize.height - padding;\n        break;\n    }\n\n    switch (map.zoomSettings.horizontalAlignment) {\n      case 'Near':\n        x = size.x;\n        break;\n\n      case 'Center':\n        x = size.width / 2 - toolBarSize.width / 2;\n        break;\n\n      case 'Far':\n        x = size.width - toolBarSize.width - padding;\n        break;\n    }\n\n    element.style.left = x + 'px';\n    element.style.top = y + 'px';\n    var color = this.maps.zoomSettings.highlightColor;\n    var css = ' .e-maps-toolbar:hover > circle { stroke:' + color + '; } .e-maps-toolbar:hover > path { fill: ' + color + ' ;  stroke: ' + color + '; }' + '.e-maps-toolbar:hover { cursor: pointer; } .e-maps-cursor-disable:hover { cursor: not-allowed; } .e-maps-panning:hover { cursor: pointer; } ' + '.e-maps-popup-close { display: block; opacity: 0; }';\n    var style = document.createElement('style');\n    style.appendChild(document.createTextNode(css));\n    element.appendChild(style);\n  };\n  /**\n   * To bind events.\n   * @return {void}\n   * @private\n   */\n\n\n  Zoom.prototype.wireEvents = function (element, process) {\n    EventHandler.add(element, Browser.touchStartEvent, process, this);\n    EventHandler.add(element, 'mouseover', this.showTooltip, this);\n    EventHandler.add(element, 'mouseout', this.removeTooltip, this);\n  };\n\n  Zoom.prototype.mapMouseWheel = function (e) {\n    if (this.maps.zoomSettings.enable && this.maps.zoomSettings.mouseWheelZoom) {\n      var position = this.getMousePosition(e.pageX, e.pageY);\n      var map = this.maps;\n      var size = map.availableSize;\n      var prevLevel = map.tileZoomLevel;\n      var prevScale = map.scale;\n      var delta = 1;\n      var value = map.isTileMap ? prevLevel : prevScale;\n\n      if (position.x > map.mapAreaRect.x && position.x < map.mapAreaRect.x + map.mapAreaRect.width && position.y > map.mapAreaRect.y && position.y < map.mapAreaRect.y + map.mapAreaRect.height) {\n        e.preventDefault();\n        var direction = this.browserName === 'mozilla' && !this.isPointer ? -e.detail / 3 > 0 ? 'ZoomIn' : 'ZoomOut' : e.wheelDelta / 120 > 0 ? 'ZoomIn' : 'ZoomOut';\n\n        if (direction === 'ZoomIn') {\n          this.performZooming(position, value + delta, direction);\n        } else {\n          this.performZooming(position, value - delta, direction);\n        }\n      }\n    }\n  };\n\n  Zoom.prototype.doubleClick = function (e) {\n    var pageX = e.pageX;\n    var pageY = e.pageY;\n    var target = e.target;\n\n    if (this.maps.zoomSettings.enable && this.maps.zoomSettings.doubleClickZoom) {\n      var position = this.getMousePosition(pageX, pageY);\n      var map = this.maps;\n      var size = map.availableSize;\n      var prevLevel = map.tileZoomLevel;\n      var prevScale = map.scale;\n      var value = map.isTileMap ? prevLevel : prevScale;\n\n      if (position.x > map.mapAreaRect.x && position.x < map.mapAreaRect.x + map.mapAreaRect.width && position.y > map.mapAreaRect.y && position.y < map.mapAreaRect.y + map.mapAreaRect.height) {\n        this.performZooming(position, value + 1, 'ZoomIn');\n      }\n    }\n  };\n\n  Zoom.prototype.mouseDownHandler = function (e) {\n    var pageX;\n    var pageY;\n    var target;\n    var touches = null;\n    var element = e.target;\n\n    if (e.type === 'touchstart') {\n      this.isTouch = true;\n      touches = e.touches;\n      target = e.target;\n      pageX = touches[0].clientX;\n      pageY = touches[0].clientY;\n    } else {\n      pageX = e.pageX;\n      pageY = e.pageY;\n      target = e.target;\n    }\n\n    this.isPanning = this.panColor === this.selectionColor ? true : this.zoomColor !== this.selectionColor;\n    this.rectZoomingStart = !this.isPanning && this.maps.zoomSettings.enable;\n    this.mouseDownPoints = this.getMousePosition(pageX, pageY);\n\n    if (this.isTouch) {\n      this.firstMove = true;\n      this.pinchFactor = this.maps.scale;\n      this.fingers = touches.length;\n    }\n\n    this.flag = true;\n  };\n\n  Zoom.prototype.mouseMoveHandler = function (e) {\n    var pageX;\n    var pageY;\n    var map = this.maps;\n    var touchArg;\n    var target;\n    var touches = null;\n    var zoom = this.maps.zoomSettings;\n\n    if (e.type === 'touchmove') {\n      this.isTouch = true;\n      target = e.target;\n      touches = e.touches;\n      pageX = touches[0].clientX;\n      pageY = touches[0].clientY;\n    } else {\n      pageX = e.pageX;\n      pageY = e.pageY;\n      target = e.target;\n    }\n\n    if (getElementByID(map.element.id + '_Zooming_KitCollection')) {\n      if (target.id.indexOf('_Zooming_') > -1) {\n        getElementByID(map.element.id + '_Zooming_KitCollection').setAttribute('opacity', '1');\n      } else {\n        getElementByID(map.element.id + '_Zooming_KitCollection').setAttribute('opacity', '0.3');\n      }\n    }\n\n    if (this.isTouch) {\n      if (this.maps.zoomSettings.pinchZooming) {\n        if (this.firstMove && touches.length === 2) {\n          this.rectZoomingStart = false;\n          this.updateInteraction();\n          this.touchStartList = targetTouches(e);\n        } else if (this.touchStartList.length === 2 && touches.length === 2) {\n          this.touchMoveList = targetTouches(e);\n          e.preventDefault();\n          this.rectZoomingStart = false;\n          this.performPinchZooming(e);\n        }\n\n        this.firstMove = false;\n      }\n    }\n\n    this.mouseMovePoints = this.getMousePosition(pageX, pageY);\n    var targetId = e.target['id'];\n    var targetEle = e.target;\n\n    if (zoom.enable && this.isPanning) {\n      e.preventDefault();\n      this.maps.element.style.cursor = 'pointer';\n      this.panning('None', null, null);\n    }\n\n    if (this.isTouch ? touches.length === 1 && this.rectZoomingStart : this.rectZoomingStart) {\n      e.preventDefault();\n      this.drawZoomRectangle();\n    }\n  };\n\n  Zoom.prototype.mouseUpHandler = function (e) {\n    var map = this.maps;\n    this.rectZoomingStart = false;\n    this.isPanning = false;\n    this.flag = this.flag ? true : false;\n    this.isTouch = false;\n    this.touchStartList = [];\n    this.touchMoveList = [];\n    this.lastScale = 1;\n    this.maps.element.style.cursor = 'auto';\n\n    if ((!isNullOrUndefined(this.distanceX) || !isNullOrUndefined(this.distanceY)) && this.currentLayer.type === 'SubLayer') {\n      this.toAlignSublayer();\n      this.distanceX = this.distanceY = null;\n    }\n\n    var zoomRectElement = getElementByID(this.maps.element.id + '_Selection_Rect_Zooming');\n\n    if (zoomRectElement && this.maps.zoomSettings.enable) {\n      remove(zoomRectElement);\n      this.performRectZooming();\n    }\n  };\n\n  Zoom.prototype.mouseCancelHandler = function (e) {\n    this.isPanning = false;\n    this.isTouch = false;\n    this.rectZoomingStart = false;\n    var zoomRectElement = getElementByID(this.maps.element.id + '_Selection_Rect_Zooming');\n\n    if (zoomRectElement && this.maps.zoomSettings.enable) {\n      remove(zoomRectElement);\n      this.performRectZooming();\n    }\n  };\n  /**\n   * To handle the click event for maps.\n   * @param e\n   */\n\n\n  Zoom.prototype.click = function (e) {\n    var map = this.maps;\n\n    if (map.markerModule && map.markerModule.sameMarkerData.length > 0 || +(e.target['id'].indexOf('MarkerIndex') > -1 && e.target['id'].indexOf('cluster') == -1)) {\n      return null;\n    }\n\n    if (this.flag && map.zoomSettings.zoomOnClick && !(e.target['id'].indexOf('_Zooming_') > -1) && !map.zoomSettings.doubleClickZoom && this.zoomColor !== this.selectionColor) {\n      var pageX = e.pageX;\n      var pageY = e.pageY;\n      var position = this.getMousePosition(pageX, pageY);\n      var prevLevel = map.tileZoomLevel;\n      var prevScale = map.scale;\n      var value = map.isTileMap ? prevLevel : prevScale;\n\n      if (position.x > map.mapAreaRect.x && position.x < map.mapAreaRect.x + map.mapAreaRect.width && position.y > map.mapAreaRect.y && position.y < map.mapAreaRect.y + map.mapAreaRect.height) {\n        this.performZooming(position, value + 1, 'ZoomIn');\n      }\n    }\n  };\n\n  Zoom.prototype.getMousePosition = function (pageX, pageY) {\n    var map = this.maps;\n    var elementRect = map.element.getBoundingClientRect();\n    var pageXOffset = map.element.ownerDocument.defaultView.pageXOffset;\n    var pageYOffset = map.element.ownerDocument.defaultView.pageYOffset;\n    var clientTop = map.element.ownerDocument.documentElement.clientTop;\n    var clientLeft = map.element.ownerDocument.documentElement.clientLeft;\n    var positionX = elementRect.left + pageXOffset - clientLeft;\n    var positionY = elementRect.top + pageYOffset - clientTop;\n    return new Point(pageX - positionX, pageY - positionY);\n  };\n\n  Zoom.prototype.addEventListener = function () {\n    if (this.maps.isDestroyed) {\n      return;\n    }\n\n    EventHandler.add(this.maps.element, this.wheelEvent, this.mapMouseWheel, this);\n    EventHandler.add(this.maps.element, 'click', this.click, this);\n    EventHandler.add(this.maps.element, 'dblclick', this.doubleClick, this);\n    this.maps.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);\n    this.maps.on(Browser.touchStartEvent, this.mouseDownHandler, this);\n    this.maps.on(Browser.touchEndEvent, this.mouseUpHandler, this);\n    EventHandler.add(this.maps.element, this.cancelEvent, this.mouseCancelHandler, this);\n  };\n\n  Zoom.prototype.removeEventListener = function () {\n    if (this.maps.isDestroyed) {\n      return;\n    }\n\n    EventHandler.remove(this.maps.element, this.wheelEvent, this.mapMouseWheel);\n    EventHandler.remove(this.maps.element, 'click', this.click);\n    EventHandler.remove(this.maps.element, 'dblclick', this.doubleClick);\n    this.maps.off(Browser.touchMoveEvent, this.mouseMoveHandler);\n    this.maps.off(Browser.touchStartEvent, this.mouseDownHandler);\n    this.maps.off(Browser.touchEndEvent, this.mouseUpHandler);\n    this.maps.off(this.cancelEvent, this.mouseCancelHandler);\n  };\n  /**\n   * Get module name.\n   */\n\n\n  Zoom.prototype.getModuleName = function () {\n    return 'Zoom';\n  };\n  /**\n   * To destroy the zoom.\n   * @return {void}\n   * @private\n   */\n\n\n  Zoom.prototype.destroy = function (maps) {\n    this.removeEventListener();\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return Zoom;\n}();\n\nexport { Zoom };","map":null,"metadata":{},"sourceType":"module"}