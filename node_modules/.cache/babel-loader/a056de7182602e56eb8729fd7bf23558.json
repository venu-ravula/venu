{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nimport { ColorMapping, bubbleRendering } from '../index';\nimport { bubbleClick, bubbleMouseMove } from '../index';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { CircleOption, MapLocation, findMidPointOfPolygon, Point, drawCircle, elementAnimate, getTranslate } from '../utils/helper';\nimport { RectOption, Rect, drawRectangle, checkPropertyPath, getZoomTranslate, getRatioOfBubble } from '../utils/helper';\n/**\n * Bubble module class\n */\n\nvar Bubble =\n/** @class */\nfunction () {\n  function Bubble(maps) {\n    /**\n     * Bubble Id for current layer\n     */\n    this.id = '';\n    this.maps = maps;\n    this.bubbleCollection = [];\n  }\n  /**\n   * To render bubble\n   */\n\n  /* tslint:disable:no-string-literal */\n\n  /* tslint:disable-next-line:max-func-body-length */\n\n\n  Bubble.prototype.renderBubble = function (bubbleSettings, shapeData, color, range, bubbleIndex, dataIndex, layerIndex, layer, group, bubbleID) {\n    var _this = this;\n\n    var layerData = layer.layerData;\n    var colorValuePath = bubbleSettings.colorValuePath;\n    var equalValue = shapeData[colorValuePath];\n    var colorValue = Number(shapeData[colorValuePath]);\n    var bubbleValue = Number(shapeData[bubbleSettings.valuePath]);\n    var opacity;\n    var bubbleColor;\n\n    if (isNaN(bubbleValue) && isNaN(colorValue) && isNullOrUndefined(equalValue)) {\n      return null;\n    }\n\n    var radius = getRatioOfBubble(bubbleSettings.minRadius, bubbleSettings.maxRadius, bubbleValue, range.min, range.max);\n    var colorMapping = new ColorMapping(this.maps);\n    var shapeColor = colorMapping.getColorByValue(bubbleSettings.colorMapping, colorValue, equalValue);\n    bubbleColor = Object.prototype.toString.call(shapeColor) === '[object Object]' && !isNullOrUndefined(shapeColor['fill']) ? shapeColor['fill'] : color;\n    opacity = Object.prototype.toString.call(shapeColor) === '[object Object]' && !isNullOrUndefined(shapeColor['opacity']) ? shapeColor['opacity'] : bubbleSettings.opacity;\n    var shapePoints = [[]];\n    var midIndex = 0;\n    var pointsLength = 0;\n    var currentLength = 0;\n\n    for (var i = 0, len = layerData.length; i < len; i++) {\n      var shape = layerData[i];\n      shape = shape['property'];\n      var shapePath = checkPropertyPath(shapeData[layer.shapeDataPath], layer.shapePropertyPath, shape);\n\n      if (shapeData[layer.shapeDataPath] === shape[shapePath]) {\n        if (layerData[i]['type'] === 'Point') {\n          shapePoints.push(this.getPoints(layerData[i], []));\n        } else if (!layerData[i]['_isMultiPolygon']) {\n          shapePoints.push(this.getPoints(layerData[i], []));\n          currentLength = shapePoints[shapePoints.length - 1].length;\n\n          if (pointsLength < currentLength) {\n            pointsLength = currentLength;\n            midIndex = shapePoints.length - 1;\n          }\n        } else {\n          var layer_1 = layerData[i];\n\n          for (var j = 0; j < layer_1.length; j++) {\n            shapePoints.push(this.getPoints(layer_1[j], []));\n            currentLength = shapePoints[shapePoints.length - 1].length;\n\n            if (pointsLength < currentLength) {\n              pointsLength = currentLength;\n              midIndex = shapePoints.length - 1;\n            }\n          }\n        }\n      }\n    }\n\n    var projectionType = this.maps.projectionType;\n    var centerY;\n    var eventArgs;\n    var center = findMidPointOfPolygon(shapePoints[midIndex], projectionType);\n\n    if (bubbleSettings.visible) {\n      if (!isNullOrUndefined(center)) {\n        centerY = this.maps.projectionType === 'Mercator' ? center['y'] : -center['y'];\n        eventArgs = {\n          cancel: false,\n          name: bubbleRendering,\n          border: bubbleSettings.border,\n          cx: center['x'],\n          cy: centerY,\n          data: shapeData,\n          fill: bubbleColor,\n          maps: this.maps.isBlazor ? null : this.maps,\n          radius: radius\n        };\n      } else {\n        var shapePointsLength = shapePoints.length - 1;\n\n        if (shapePoints[shapePointsLength]['x'] && shapePoints[shapePointsLength]['y']) {\n          eventArgs = {\n            cancel: false,\n            name: bubbleRendering,\n            border: bubbleSettings.border,\n            cx: shapePoints[shapePointsLength]['x'],\n            cy: shapePoints[shapePointsLength]['y'],\n            data: shapeData,\n            fill: bubbleColor,\n            maps: this.maps.isBlazor ? null : this.maps,\n            radius: radius\n          };\n        } else {\n          return;\n        }\n\n        if (this.maps.isBlazor) {\n          var maps = eventArgs.maps,\n              blazorEventArgs = __rest(eventArgs, [\"maps\"]);\n\n          eventArgs = blazorEventArgs;\n        }\n      }\n\n      this.maps.trigger('bubbleRendering', eventArgs, function (bubbleArgs) {\n        if (eventArgs.cancel) {\n          return;\n        }\n\n        var bubbleElement;\n\n        if (bubbleSettings.bubbleType === 'Circle') {\n          var circle = new CircleOption(bubbleID, eventArgs.fill, eventArgs.border, opacity, 0, 0, eventArgs.radius, null);\n          bubbleElement = drawCircle(_this.maps, circle, group);\n        } else {\n          var y = _this.maps.projectionType === 'Mercator' ? eventArgs.cy - radius : eventArgs.cy + radius;\n          var rectangle = new RectOption(bubbleID, eventArgs.fill, eventArgs.border, opacity, new Rect(0, 0, radius * 2, radius * 2), 2, 2);\n          eventArgs.cx -= radius;\n          eventArgs.cy = y;\n          bubbleElement = drawRectangle(_this.maps, rectangle, group);\n        }\n\n        _this.bubbleCollection.push({\n          LayerIndex: layerIndex,\n          BubbleIndex: bubbleIndex,\n          DataIndex: dataIndex,\n          element: bubbleElement,\n          center: {\n            x: eventArgs.cx,\n            y: eventArgs.cy\n          }\n        });\n\n        var translate;\n        var animate = layer.animationDuration !== 0 || isNullOrUndefined(_this.maps.zoomModule);\n\n        if (_this.maps.zoomSettings.zoomFactor > 1 && !isNullOrUndefined(_this.maps.zoomModule)) {\n          translate = getZoomTranslate(_this.maps, layer, animate);\n        } else {\n          translate = getTranslate(_this.maps, layer, animate);\n        }\n\n        var scale = translate['scale'];\n        var transPoint = translate['location'];\n        var position = new MapLocation(_this.maps.isTileMap ? eventArgs.cx : (eventArgs.cx + transPoint.x) * scale, _this.maps.isTileMap ? eventArgs.cy : (eventArgs.cy + transPoint.y) * scale);\n        bubbleElement.setAttribute('transform', 'translate( ' + position.x + ' ' + position.y + ' )');\n        var bubble = bubbleSettings.dataSource.length - 1 === dataIndex ? 'bubble' : null;\n\n        if (bubbleSettings.bubbleType === 'Square') {\n          position.x += radius;\n          position.y += radius * (_this.maps.projectionType === 'Mercator' ? 1 : -1);\n        } else {\n          radius = 0;\n        }\n\n        if (bubbleSettings.animationDuration > 0) {\n          elementAnimate(bubbleElement, bubbleSettings.animationDelay, bubbleSettings.animationDuration, position, _this.maps, bubble, radius);\n        }\n      });\n    }\n  };\n\n  Bubble.prototype.getPoints = function (shape, points) {\n    if (isNullOrUndefined(shape.map)) {\n      points = shape['point'];\n    } else {\n      shape.map(function (current, index) {\n        points.push(new Point(current['point']['x'], current['point']['y']));\n      });\n    }\n\n    return points;\n  };\n  /**\n   * To check and trigger bubble click event\n   */\n\n\n  Bubble.prototype.bubbleClick = function (e) {\n    var target = e.target.id;\n\n    if (target.indexOf('_LayerIndex_') === -1) {\n      return;\n    }\n\n    var data = this.getbubble(target);\n\n    if (isNullOrUndefined(data)) {\n      return;\n    }\n\n    var eventArgs = {\n      cancel: false,\n      name: bubbleClick,\n      data: data,\n      maps: this.maps,\n      target: target,\n      x: e.clientX,\n      y: e.clientY\n    };\n\n    if (this.maps.isBlazor) {\n      var maps = eventArgs.maps,\n          blazorEventArgs = __rest(eventArgs, [\"maps\"]);\n\n      eventArgs = blazorEventArgs;\n    }\n\n    this.maps.trigger(bubbleClick, eventArgs);\n  };\n  /**\n   * To get bubble from target id\n   */\n\n\n  Bubble.prototype.getbubble = function (target) {\n    var id = target.split('_LayerIndex_');\n    var index = parseInt(id[1].split('_')[0], 10);\n    var layer = this.maps.layers[index];\n    var data;\n\n    if (target.indexOf('_BubbleIndex_') > -1) {\n      var bubbleIndex = parseInt(id[1].split('_BubbleIndex_')[1], 10);\n      var dataIndex = parseInt(id[1].split('_BubbleIndex_')[1].split('_dataIndex_')[1], 10);\n\n      if (!isNaN(bubbleIndex)) {\n        data = layer.bubbleSettings[bubbleIndex].dataSource[dataIndex];\n        return data;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * To check and trigger bubble move event\n   */\n\n\n  Bubble.prototype.bubbleMove = function (e) {\n    var target = e.target.id;\n\n    if (target.indexOf('_LayerIndex_') === -1) {\n      return;\n    }\n\n    var data = this.getbubble(target);\n\n    if (isNullOrUndefined(data)) {\n      return;\n    }\n\n    var eventArgs = {\n      cancel: false,\n      name: bubbleMouseMove,\n      data: data,\n      maps: this.maps,\n      target: target,\n      x: e.clientX,\n      y: e.clientY\n    };\n\n    if (this.maps.isBlazor) {\n      var maps = eventArgs.maps,\n          blazorEventArgs = __rest(eventArgs, [\"maps\"]);\n\n      eventArgs = blazorEventArgs;\n    }\n\n    this.maps.trigger(bubbleMouseMove, eventArgs);\n  };\n  /**\n   * Get module name.\n   */\n\n\n  Bubble.prototype.getModuleName = function () {\n    return 'Bubble';\n  };\n  /**\n   * To destroy the bubble.\n   * @return {void}\n   * @private\n   */\n\n\n  Bubble.prototype.destroy = function (maps) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return Bubble;\n}();\n\nexport { Bubble };","map":null,"metadata":{},"sourceType":"module"}