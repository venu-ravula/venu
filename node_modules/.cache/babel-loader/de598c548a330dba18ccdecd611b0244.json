{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { NotifyPropertyChanges, Property, Event, Complex, updateBlazorTemplate } from '@syncfusion/ej2-base';\nimport { extend, compile as templateComplier, Component, resetBlazorTemplate } from '@syncfusion/ej2-base';\nimport { SvgRenderer } from '../svg-render/index';\nimport { ChildProperty, createElement, remove, Browser, Animation } from '@syncfusion/ej2-base';\nimport { getTooltipThemeColor } from './interface';\nimport { Size, Rect, Side, measureText, getElement, findDirection, drawSymbol, textElement } from './helper';\nimport { removeElement, TextOption, TooltipLocation, PathOption } from './helper';\n/**\n * Configures the fonts in charts.\n * @private\n */\n\nvar TextStyle =\n/** @class */\nfunction (_super) {\n  __extends(TextStyle, _super);\n\n  function TextStyle() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(null)], TextStyle.prototype, \"size\", void 0);\n\n  __decorate([Property('')], TextStyle.prototype, \"color\", void 0);\n\n  __decorate([Property('Segoe UI')], TextStyle.prototype, \"fontFamily\", void 0);\n\n  __decorate([Property('Normal')], TextStyle.prototype, \"fontWeight\", void 0);\n\n  __decorate([Property('Normal')], TextStyle.prototype, \"fontStyle\", void 0);\n\n  __decorate([Property(1)], TextStyle.prototype, \"opacity\", void 0);\n\n  return TextStyle;\n}(ChildProperty);\n\nexport { TextStyle };\n/**\n * Configures the borders in the chart.\n * @private\n */\n\nvar TooltipBorder =\n/** @class */\nfunction (_super) {\n  __extends(TooltipBorder, _super);\n\n  function TooltipBorder() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property('')], TooltipBorder.prototype, \"color\", void 0);\n\n  __decorate([Property(1)], TooltipBorder.prototype, \"width\", void 0);\n\n  return TooltipBorder;\n}(ChildProperty);\n\nexport { TooltipBorder };\n/**\n * Configures the borders in the chart.\n * @private\n */\n\nvar AreaBounds =\n/** @class */\nfunction (_super) {\n  __extends(AreaBounds, _super);\n\n  function AreaBounds() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(0)], AreaBounds.prototype, \"x\", void 0);\n\n  __decorate([Property(0)], AreaBounds.prototype, \"y\", void 0);\n\n  __decorate([Property(0)], AreaBounds.prototype, \"width\", void 0);\n\n  __decorate([Property(0)], AreaBounds.prototype, \"height\", void 0);\n\n  return AreaBounds;\n}(ChildProperty);\n\nexport { AreaBounds };\n/**\n * Configures the borders in the chart.\n * @private\n */\n\nvar ToolLocation =\n/** @class */\nfunction (_super) {\n  __extends(ToolLocation, _super);\n\n  function ToolLocation() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(0)], ToolLocation.prototype, \"x\", void 0);\n\n  __decorate([Property(0)], ToolLocation.prototype, \"y\", void 0);\n\n  return ToolLocation;\n}(ChildProperty);\n\nexport { ToolLocation };\n/**\n * Represents the Tooltip control.\n * ```html\n * <div id=\"tooltip\"/>\n * <script>\n *   var tooltipObj = new Tooltip({ isResponsive : true });\n *   tooltipObj.appendTo(\"#tooltip\");\n * </script>\n * ```\n * @private\n */\n\nvar Tooltip =\n/** @class */\nfunction (_super) {\n  __extends(Tooltip, _super);\n  /**\n   * Constructor for creating the widget\n   * @hidden\n   */\n\n\n  function Tooltip(options, element) {\n    return _super.call(this, options, element) || this;\n  }\n  /**\n   * Initialize the event handler.\n   *  @private.\n   */\n\n\n  Tooltip.prototype.preRender = function () {\n    this.initPrivateVariable();\n\n    if (!this.isCanvas) {\n      this.removeSVG();\n    }\n\n    this.createTooltipElement();\n  };\n\n  Tooltip.prototype.initPrivateVariable = function () {\n    this.renderer = new SvgRenderer(this.element.id);\n    this.themeStyle = getTooltipThemeColor(this.theme);\n    this.formattedText = [];\n    this.padding = 5;\n    this.isFirst = true;\n    this.markerPoint = [];\n  };\n\n  Tooltip.prototype.removeSVG = function () {\n    var svgObject = document.getElementById(this.element.id + '_svg');\n    var templateObject = document.getElementById(this.element.id + 'parent_template');\n\n    if (this.blazorTemplate) {\n      resetBlazorTemplate(this.element.id + 'parent_template' + '_blazorTemplate');\n    }\n\n    if (svgObject && svgObject.parentNode) {\n      remove(svgObject);\n    }\n\n    if (templateObject && templateObject.parentNode) {\n      remove(templateObject);\n    }\n  };\n  /**\n   * To Initialize the control rendering.\n   */\n\n\n  Tooltip.prototype.render = function () {\n    this.fadeOuted = false;\n\n    if (!this.template) {\n      this.renderText(this.isFirst);\n      var argsData = {\n        cancel: false,\n        name: 'tooltipRender',\n        tooltip: this\n      };\n      this.trigger('tooltipRender', argsData);\n      var markerSide = this.renderTooltipElement(this.areaBounds, this.location);\n      this.drawMarker(markerSide.isBottom, markerSide.isRight, this.markerSize);\n    } else {\n      this.updateTemplateFn();\n      this.createTemplate(this.areaBounds, this.location);\n    }\n\n    this.trigger('loaded', {\n      tooltip: this\n    });\n    var element = document.getElementById('chartmeasuretext');\n\n    if (element) {\n      remove(element);\n    }\n  };\n\n  Tooltip.prototype.createTooltipElement = function () {\n    this.textElements = [];\n\n    if (!this.template || this.shared) {\n      // SVG element for tooltip\n      var svgObject = this.renderer.createSvg({\n        id: this.element.id + '_svg'\n      });\n      this.element.appendChild(svgObject); // Group to hold text and path.\n\n      var groupElement = document.getElementById(this.element.id + '_group');\n\n      if (!groupElement) {\n        groupElement = this.renderer.createGroup({\n          id: this.element.id + '_group'\n        });\n        groupElement.setAttribute('transform', 'translate(0,0)');\n      }\n\n      svgObject.appendChild(groupElement);\n      var pathElement = this.renderer.drawPath({\n        'id': this.element.id + '_path',\n        'stroke-width': this.theme === 'Bootstrap4' ? 0 : this.border.width,\n        'fill': this.fill || this.themeStyle.tooltipFill,\n        'opacity': this.theme === 'Bootstrap4' ? 0.9 : this.opacity,\n        'stroke': this.border.color\n      });\n      groupElement.appendChild(pathElement);\n    }\n  };\n\n  Tooltip.prototype.drawMarker = function (isBottom, isRight, size) {\n    if (this.shapes.length <= 0) {\n      return null;\n    }\n\n    var shapeOption;\n    var count = 0;\n    var markerGroup = this.renderer.createGroup({\n      id: this.element.id + '_trackball_group'\n    });\n    var groupElement = getElement(this.element.id + '_group');\n    var x = this.marginX * 2 + size / 2 + (isRight ? this.arrowPadding : 0);\n\n    for (var _i = 0, _a = this.shapes; _i < _a.length; _i++) {\n      var shape = _a[_i];\n      shapeOption = new PathOption(this.element.id + '_Trackball_' + count, this.palette[count], 1, '#cccccc', 1, null);\n\n      if (this.markerPoint[count]) {\n        markerGroup.appendChild(drawSymbol(new TooltipLocation(x, this.markerPoint[count] - this.padding + (isBottom ? this.arrowPadding : 0)), shape, new Size(size, size), '', shapeOption, null));\n      }\n\n      count++;\n    }\n\n    groupElement.appendChild(markerGroup);\n  };\n\n  Tooltip.prototype.renderTooltipElement = function (areaBounds, location) {\n    var tooltipDiv = getElement(this.element.id);\n    var arrowLocation = new TooltipLocation(0, 0);\n    var tipLocation = new TooltipLocation(0, 0);\n    var textHeights;\n    var svgObject = getElement(this.element.id + '_svg');\n    var groupElement = getElement(this.element.id + '_group');\n    var pathElement = getElement(this.element.id + '_path');\n    var rect;\n    var isTop = false;\n    var isLeft = false;\n    var isBottom = false;\n    var x = 0;\n    var y = 0;\n    this.tipRadius = 1;\n\n    if (this.header !== '') {\n      this.elementSize.height += this.marginY;\n    }\n\n    if (this.content.length > 1) {\n      rect = this.sharedTooltipLocation(areaBounds, this.location.x, this.location.y);\n      isTop = true;\n    } else {\n      rect = this.tooltipLocation(areaBounds, location, arrowLocation, tipLocation);\n\n      if (!this.inverted) {\n        isTop = rect.y < location.y + this.clipBounds.y;\n        isBottom = !isTop;\n        y = isTop ? 0 : this.arrowPadding;\n      } else {\n        isLeft = rect.x < location.x + this.clipBounds.x;\n        x = isLeft ? 0 : this.arrowPadding;\n      }\n    }\n\n    if (this.header !== '') {\n      var headerSize = measureText(this.header, this.textStyle).height + this.marginY * 2 + (isBottom ? this.arrowPadding : 0); //header padding;\n\n      var xLength = this.marginX * 3 + (!isLeft && !isTop && !isBottom ? this.arrowPadding : 0);\n      var direction = 'M ' + xLength + ' ' + headerSize + 'L ' + (rect.width + (!isLeft && !isTop && !isBottom ? this.arrowPadding : 0) - this.marginX * 2) + ' ' + headerSize;\n      var pathElement_1 = this.renderer.drawPath({\n        'id': this.element.id + '_header_path',\n        'stroke-width': 1,\n        'fill': null,\n        'opacity': 0.8,\n        'stroke': this.themeStyle.tooltipHeaderLine,\n        'd': direction\n      });\n      groupElement.appendChild(pathElement_1);\n    }\n\n    var start = this.border.width / 2;\n    var pointRect = new Rect(start + x, start + y, rect.width - start, rect.height - start);\n    groupElement.setAttribute('opacity', '1');\n\n    if (this.enableAnimation && !this.shared && !this.isFirst) {\n      this.animateTooltipDiv(tooltipDiv, rect);\n    } else {\n      this.updateDiv(tooltipDiv, rect.x, rect.y);\n    }\n\n    svgObject.setAttribute('height', (rect.height + this.border.width + (!!this.inverted ? 0 : this.arrowPadding) + 5).toString());\n    svgObject.setAttribute('width', (rect.width + this.border.width + (!this.inverted ? 0 : this.arrowPadding) + 5).toString());\n    svgObject.setAttribute('opacity', '1');\n    pathElement.setAttribute('d', findDirection(this.rx, this.ry, pointRect, arrowLocation, this.arrowPadding, isTop, isBottom, isLeft, tipLocation.x, tipLocation.y, this.tipRadius));\n\n    if (this.enableShadow && this.theme !== 'Bootstrap4') {\n      // To fix next chart initial tooltip opacity issue in tab control\n      var shadowId = this.element.id + '_shadow';\n      pathElement.setAttribute('filter', Browser.isIE ? '' : 'url(#' + shadowId + ')');\n      var shadow = '<filter id=\"' + shadowId + '\" height=\"130%\"><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"3\"/>';\n      shadow += '<feOffset dx=\"3\" dy=\"3\" result=\"offsetblur\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"0.5\"/>';\n      shadow += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n      var defElement = this.renderer.createDefs();\n      defElement.setAttribute('id', this.element.id + 'SVG_tooltip_definition');\n      groupElement.appendChild(defElement);\n      defElement.innerHTML = shadow;\n    }\n\n    pathElement.setAttribute('stroke', this.border.color);\n    this.changeText(new TooltipLocation(x, y), isBottom, !isLeft && !isTop && !isBottom, rect);\n    return new Side(isBottom, !isLeft && !isTop && !isBottom);\n  };\n\n  Tooltip.prototype.changeText = function (point, isBottom, isRight, rect) {\n    var element = document.getElementById(this.element.id + '_text');\n\n    if (isBottom) {\n      element.setAttribute('transform', 'translate(0,' + this.arrowPadding + ')');\n    }\n\n    if (isRight) {\n      element.setAttribute('transform', 'translate(' + this.arrowPadding + ' 0)');\n    }\n  };\n\n  Tooltip.prototype.findFormattedText = function () {\n    this.formattedText = [];\n\n    if (this.header.replace(/<b>/g, '').replace(/<\\/b>/g, '').trim() !== '') {\n      this.formattedText = this.formattedText.concat(this.header);\n    }\n\n    this.formattedText = this.formattedText.concat(this.content);\n  };\n\n  Tooltip.prototype.renderText = function (isRender) {\n    var height = 0;\n    var width = 0; // Padding for text;\n\n    var subWidth = 0;\n    var size;\n    var lines;\n    var key = 'properties';\n    var font = extend({}, this.textStyle, null, true)[key];\n    var groupElement = getElement(this.element.id + '_group');\n    var tspanElement;\n    var tspanStyle = '';\n    var line;\n    var tspanOption;\n    this.findFormattedText();\n    var headerContent = this.header.replace(/<b>/g, '').replace(/<\\/b>/g, '').trim();\n    var headerSpace = headerContent !== '' ? this.marginY : 0;\n    var isRow = true;\n    var isColumn = true;\n    this.markerPoint = [];\n    var markerSize = this.shapes.length > 0 ? 10 : 0;\n    var markerPadding = this.shapes.length > 0 ? 5 : 0;\n    var spaceWidth = 4;\n    var fontSize = '13px';\n    var fontWeight = 'Normal';\n    var labelColor = this.themeStyle.tooltipLightLabel;\n    var dy = 22 / parseFloat(fontSize) * parseFloat(font.size);\n\n    if (!isRender || this.isCanvas) {\n      removeElement(this.element.id + '_text');\n      removeElement(this.element.id + '_header_path');\n      removeElement(this.element.id + '_trackball_group');\n      removeElement(this.element.id + 'SVG_tooltip_definition');\n    }\n\n    var options = new TextOption(this.element.id + '_text', this.marginX * 2, this.marginY * 2 + this.padding * 2 + (this.marginY === 2 ? 3 : 0), 'start', '');\n    var parentElement = textElement(options, font, null, groupElement);\n\n    for (var k = 0, pointsLength = this.formattedText.length; k < pointsLength; k++) {\n      var textCollection = this.formattedText[k].replace(/<(b|strong)>/g, '<b>').replace(/<\\/(b|strong)>/g, '</b>').split(/<br.*?>/g);\n\n      if (textCollection[0] === '') {\n        continue;\n      }\n\n      size = measureText(this.formattedText[k], font);\n\n      if (k !== 0 || headerContent === '') {\n        this.markerPoint.push((headerContent !== '' ? this.marginY : 0) + options.y + height);\n      }\n\n      for (var i = 0, len = textCollection.length; i < len; i++) {\n        // string value of unicode for LTR is \\u200E\n        lines = textCollection[i].replace(/<b>/g, '<br><b>').replace(/<\\/b>/g, '</b><br>').replace(/:/g, '<br>\\u200E:<br>').split('<br>');\n        subWidth = 0;\n        isColumn = true;\n        height += dy;\n\n        for (var k_1 = 0, len_1 = lines.length; k_1 < len_1; k_1++) {\n          line = lines[k_1];\n\n          if (!/\\S/.test(line) && line !== '') {\n            line = ' '; //to trim multiple white spaces to single white space\n          }\n\n          if (!isColumn && line === ' ' || line.replace(/<b>/g, '').replace(/<\\/b>/g, '').trim() !== '') {\n            subWidth += line !== ' ' ? spaceWidth : 0;\n\n            if (isColumn && !isRow) {\n              tspanOption = {\n                x: this.marginX * 2 + (markerSize + markerPadding),\n                dy: dy + (isColumn ? headerSpace : 0),\n                fill: ''\n              };\n              headerSpace = null;\n            } else {\n              if (isRow && isColumn) {\n                tspanOption = {\n                  x: headerContent === '' ? this.marginX * 2 + (markerSize + markerPadding) : this.marginX * 2\n                };\n              } else {\n                tspanOption = {};\n              }\n            }\n\n            isColumn = false;\n            tspanElement = this.renderer.createTSpan(tspanOption, '');\n            parentElement.appendChild(tspanElement);\n\n            if (line.indexOf('<b>') > -1) {\n              fontWeight = 'bold';\n              labelColor = this.themeStyle.tooltipBoldLabel;\n              tspanStyle = 'font-weight:' + fontWeight;\n              font.fontWeight = fontWeight;\n              tspanElement.setAttribute('fill', this.textStyle.color || labelColor);\n            } else {\n              tspanStyle = fontWeight === 'bold' ? 'font-weight:' + fontWeight : '';\n              font.fontWeight = fontWeight;\n              tspanElement.setAttribute('fill', this.textStyle.color || labelColor);\n            }\n\n            if (line.indexOf('</b>') > -1) {\n              fontWeight = 'Normal';\n              labelColor = this.themeStyle.tooltipLightLabel;\n            }\n\n            tspanElement.textContent = line = line.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, '');\n            subWidth += measureText(line, font).width;\n\n            if (tspanStyle !== '') {\n              tspanElement.setAttribute('style', tspanStyle);\n            }\n\n            isRow = false;\n          }\n        }\n\n        subWidth -= spaceWidth;\n        width = Math.max(width, subWidth);\n      }\n    }\n\n    this.elementSize = new Size(width + (width > 0 ? 2 * this.marginX : 0), height);\n    this.elementSize.width += markerSize + markerPadding; // marker size + marker Spacing\n\n    var element = parentElement.childNodes[0];\n\n    if (headerContent !== '' && element) {\n      font.fontWeight = 'bold';\n      var width_1 = (this.elementSize.width + 2 * this.padding) / 2 - measureText(headerContent, font).width / 2;\n      element.setAttribute('x', width_1.toString());\n    }\n  };\n\n  Tooltip.prototype.createTemplate = function (areaBounds, location) {\n    var argsData = {\n      cancel: false,\n      name: 'tooltipRender',\n      tooltip: this\n    };\n    this.trigger('tooltipRender', argsData);\n    var parent = document.getElementById(this.element.id);\n    var blazor = 'Blazor';\n    var isBlazor = window[blazor];\n\n    if (this.isCanvas) {\n      this.removeSVG();\n    }\n\n    var firstElement = parent.firstElementChild;\n\n    if (firstElement) {\n      remove(firstElement);\n    }\n\n    if (!argsData.cancel) {\n      var elem = createElement('div', {\n        id: this.element.id + 'parent_template'\n      });\n      var templateElement = this.templateFn(this.data, null, null, elem.id + '_blazorTemplate', '');\n\n      while (templateElement && templateElement.length > 0) {\n        if (isBlazor) {\n          elem.appendChild(templateElement[0]);\n          templateElement = null;\n        } else {\n          elem.appendChild(templateElement[0]);\n        }\n      }\n\n      parent.appendChild(elem);\n      var element = this.isCanvas ? elem : this.element;\n      var rect = element.getBoundingClientRect();\n      this.padding = 0;\n      this.elementSize = new Size(rect.width, rect.height);\n      var tooltipRect = this.tooltipLocation(areaBounds, location, new TooltipLocation(0, 0), new TooltipLocation(0, 0));\n\n      if (this.enableAnimation && !this.shared && !this.isFirst) {\n        this.animateTooltipDiv(this.element, tooltipRect);\n      } else {\n        this.updateDiv(element, tooltipRect.x, tooltipRect.y);\n      }\n\n      if (this.blazorTemplate) {\n        updateBlazorTemplate(this.element.id + 'parent_template' + '_blazorTemplate', this.blazorTemplate.name, this.blazorTemplate.parent);\n      }\n    } else {\n      remove(getElement(this.element.id + '_tooltip'));\n    }\n  };\n\n  Tooltip.prototype.sharedTooltipLocation = function (bounds, x, y) {\n    var width = this.elementSize.width + 2 * this.marginX;\n    var height = this.elementSize.height + 2 * this.marginY;\n    var tooltipRect = new Rect(x + 2 * this.padding, y - height - this.padding, width, height);\n\n    if (tooltipRect.y < bounds.y) {\n      tooltipRect.y += tooltipRect.height + 2 * this.padding;\n    }\n\n    if (tooltipRect.x + tooltipRect.width > bounds.x + bounds.width) {\n      tooltipRect.x -= tooltipRect.width + 4 * this.padding;\n    }\n\n    return tooltipRect;\n  };\n\n  Tooltip.prototype.tooltipLocation = function (bounds, symbolLocation, arrowLocation, tipLocation) {\n    var location = new TooltipLocation(symbolLocation.x, symbolLocation.y);\n    var width = this.elementSize.width + 2 * this.marginX;\n    var height = this.elementSize.height + 2 * this.marginY;\n    var markerHeight = this.offset;\n    var clipX = this.clipBounds.x;\n    var clipY = this.clipBounds.y;\n    var boundsX = bounds.x;\n    var boundsY = bounds.y;\n\n    if (!this.inverted) {\n      location = new TooltipLocation(location.x + clipX - this.elementSize.width / 2 - this.padding, location.y + clipY - this.elementSize.height - 2 * this.padding - this.arrowPadding - markerHeight);\n      arrowLocation.x = tipLocation.x = width / 2;\n\n      if (location.y < boundsY || this.isNegative) {\n        location.y = (symbolLocation.y < 0 ? 0 : symbolLocation.y) + clipY + markerHeight;\n      }\n\n      if (location.y + height + this.arrowPadding > boundsY + bounds.height) {\n        location.y = (symbolLocation.y > bounds.height ? bounds.height : symbolLocation.y) + clipY - this.elementSize.height - 2 * this.padding - this.arrowPadding - markerHeight;\n      }\n\n      tipLocation.x = width / 2;\n\n      if (location.x < boundsX) {\n        arrowLocation.x -= boundsX - location.x;\n        tipLocation.x -= boundsX - location.x;\n        location.x = boundsX;\n      }\n\n      if (location.x + width > boundsX + bounds.width) {\n        arrowLocation.x += location.x + width - (boundsX + bounds.width);\n        tipLocation.x += location.x + width - (boundsX + bounds.width);\n        location.x -= location.x + width - (boundsX + bounds.width);\n      }\n\n      if (arrowLocation.x + this.arrowPadding / 2 > width - this.rx) {\n        arrowLocation.x = width - this.rx - this.arrowPadding / 2;\n        tipLocation.x = width;\n        this.tipRadius = 0;\n      }\n\n      if (arrowLocation.x - this.arrowPadding / 2 < this.rx) {\n        arrowLocation.x = this.rx + this.arrowPadding / 2;\n        tipLocation.x = 0;\n        this.tipRadius = 0;\n      }\n    } else {\n      location = new TooltipLocation(location.x + clipX + markerHeight, location.y + clipY - this.elementSize.height / 2 - this.padding);\n      arrowLocation.y = tipLocation.y = height / 2;\n\n      if (location.x + width + this.arrowPadding > boundsX + bounds.width || this.isNegative) {\n        location.x = (symbolLocation.x > bounds.width ? bounds.width : symbolLocation.x) + clipX - markerHeight - (width + this.arrowPadding);\n      }\n\n      if (location.x < boundsX) {\n        location.x = (symbolLocation.x < 0 ? 0 : symbolLocation.x) + clipX + markerHeight;\n      }\n\n      if (location.y <= boundsY) {\n        arrowLocation.y -= boundsY - location.y;\n        tipLocation.y -= boundsY - location.y;\n        location.y = boundsY;\n      }\n\n      if (location.y + height >= boundsY + bounds.height) {\n        arrowLocation.y += location.y + height - (boundsY + bounds.height);\n        tipLocation.y += location.y + height - (boundsY + bounds.height);\n        location.y -= location.y + height - (boundsY + bounds.height);\n      }\n\n      if (arrowLocation.y + this.arrowPadding / 2 > height - this.ry) {\n        arrowLocation.y = height - this.ry - this.arrowPadding / 2;\n        tipLocation.y = height;\n        this.tipRadius = 0;\n      }\n\n      if (arrowLocation.y - this.arrowPadding / 2 < this.ry) {\n        arrowLocation.y = this.ry + this.arrowPadding / 2;\n        tipLocation.y = 0;\n        this.tipRadius = 0;\n      }\n    }\n\n    return new Rect(location.x, location.y, width, height);\n  };\n\n  Tooltip.prototype.animateTooltipDiv = function (tooltipDiv, rect) {\n    var _this = this;\n\n    var x = parseFloat(tooltipDiv.style.left);\n    var y = parseFloat(tooltipDiv.style.top);\n    var currenDiff;\n    new Animation({}).animate(tooltipDiv, {\n      duration: this.duration,\n      progress: function (args) {\n        currenDiff = args.timeStamp / args.duration;\n        tooltipDiv.style.animation = null;\n        tooltipDiv.style.left = x + currenDiff * (rect.x - x) + 'px';\n        tooltipDiv.style.top = y + currenDiff * (rect.y - y) + 'px';\n      },\n      end: function (model) {\n        _this.updateDiv(tooltipDiv, rect.x, rect.y);\n\n        _this.trigger('animationComplete', {\n          tooltip: _this\n        });\n      }\n    });\n  };\n\n  Tooltip.prototype.updateDiv = function (tooltipDiv, x, y) {\n    tooltipDiv.style.left = x + 'px';\n    tooltipDiv.style.top = y + 'px';\n  };\n\n  Tooltip.prototype.updateTemplateFn = function () {\n    if (this.template) {\n      var e = void 0;\n\n      try {\n        if (document.querySelectorAll(this.template).length) {\n          this.templateFn = templateComplier(document.querySelector(this.template).innerHTML.trim());\n        }\n      } catch (e) {\n        this.templateFn = templateComplier(this.template);\n      }\n    }\n  };\n  /** @private */\n\n\n  Tooltip.prototype.fadeOut = function () {\n    var _this = this;\n\n    var tooltipElement = this.isCanvas && !this.template ? getElement(this.element.id + '_svg') : getElement(this.element.id);\n\n    if (tooltipElement) {\n      var tooltipGroup_1 = tooltipElement.firstChild;\n\n      if (this.isCanvas && !this.template) {\n        tooltipGroup_1 = document.getElementById(this.element.id + '_group') ? document.getElementById(this.element.id + '_group') : tooltipGroup_1;\n      }\n\n      var opacity_1;\n\n      if (tooltipGroup_1) {\n        opacity_1 = parseFloat(tooltipGroup_1.getAttribute('opacity')) || 1;\n      }\n\n      new Animation({}).animate(tooltipGroup_1, {\n        duration: 200,\n        progress: function (args) {\n          //  tooltipGroup.removeAttribute('e-animate');\n          _this.progressAnimation(tooltipGroup_1, opacity_1, args.timeStamp / args.duration);\n        },\n        end: function (model) {\n          _this.fadeOuted = true;\n\n          _this.endAnimation(tooltipGroup_1);\n        }\n      });\n    }\n  };\n\n  Tooltip.prototype.progressAnimation = function (tooltipGroup, opacity, timeStamp) {\n    tooltipGroup.style.animation = '';\n    tooltipGroup.setAttribute('opacity', (opacity - timeStamp).toString());\n  };\n  /*\n   * @hidden\n   */\n\n\n  Tooltip.prototype.endAnimation = function (tooltipGroup) {\n    tooltipGroup.setAttribute('opacity', '0');\n\n    if (this.template && !this.shared) {\n      tooltipGroup.style.display = 'none';\n    }\n\n    this.trigger('animationComplete', {\n      tooltip: this\n    });\n  };\n  /**\n   * Get the properties to be maintained in the persisted state.\n   * @private\n   */\n\n\n  Tooltip.prototype.getPersistData = function () {\n    var keyEntity = [];\n    return this.addOnPersist(keyEntity);\n  };\n  /**\n   * Get component name\n   *  @private\n   */\n\n\n  Tooltip.prototype.getModuleName = function () {\n    return 'tooltip';\n  };\n  /**\n   * To destroy the accumulationcharts\n   * @private\n   */\n\n\n  Tooltip.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    this.element.classList.remove('e-tooltip');\n  };\n  /**\n   * Called internally if any of the property value changed.\n   * @return {void}\n   * @private\n   */\n\n\n  Tooltip.prototype.onPropertyChanged = function (newProp, oldProp) {\n    if (this.blazorTemplate) {\n      resetBlazorTemplate(this.element.id + 'parent_template' + '_blazorTemplate');\n    }\n\n    this.isFirst = false;\n    this.render();\n  };\n\n  __decorate([Property(false)], Tooltip.prototype, \"enable\", void 0);\n\n  __decorate([Property(false)], Tooltip.prototype, \"shared\", void 0);\n\n  __decorate([Property(true)], Tooltip.prototype, \"enableShadow\", void 0);\n\n  __decorate([Property(null)], Tooltip.prototype, \"fill\", void 0);\n\n  __decorate([Property('')], Tooltip.prototype, \"header\", void 0);\n\n  __decorate([Property(0.75)], Tooltip.prototype, \"opacity\", void 0);\n\n  __decorate([Complex({\n    size: '13px',\n    fontWeight: 'Normal',\n    color: null,\n    fontStyle: 'Normal',\n    fontFamily: 'Segoe UI'\n  }, TextStyle)], Tooltip.prototype, \"textStyle\", void 0);\n\n  __decorate([Property(null)], Tooltip.prototype, \"template\", void 0);\n\n  __decorate([Property(true)], Tooltip.prototype, \"enableAnimation\", void 0);\n\n  __decorate([Property(300)], Tooltip.prototype, \"duration\", void 0);\n\n  __decorate([Property(false)], Tooltip.prototype, \"inverted\", void 0);\n\n  __decorate([Property(false)], Tooltip.prototype, \"isNegative\", void 0);\n\n  __decorate([Complex({\n    color: '#cccccc',\n    width: 0.5\n  }, TooltipBorder)], Tooltip.prototype, \"border\", void 0);\n\n  __decorate([Property([])], Tooltip.prototype, \"content\", void 0);\n\n  __decorate([Property(10)], Tooltip.prototype, \"markerSize\", void 0);\n\n  __decorate([Complex({\n    x: 0,\n    y: 0\n  }, ToolLocation)], Tooltip.prototype, \"clipBounds\", void 0);\n\n  __decorate([Property([])], Tooltip.prototype, \"palette\", void 0);\n\n  __decorate([Property([])], Tooltip.prototype, \"shapes\", void 0);\n\n  __decorate([Complex({\n    x: 0,\n    y: 0\n  }, ToolLocation)], Tooltip.prototype, \"location\", void 0);\n\n  __decorate([Property(0)], Tooltip.prototype, \"offset\", void 0);\n\n  __decorate([Property(2)], Tooltip.prototype, \"rx\", void 0);\n\n  __decorate([Property(2)], Tooltip.prototype, \"ry\", void 0);\n\n  __decorate([Property(5)], Tooltip.prototype, \"marginX\", void 0);\n\n  __decorate([Property(5)], Tooltip.prototype, \"marginY\", void 0);\n\n  __decorate([Property(12)], Tooltip.prototype, \"arrowPadding\", void 0);\n\n  __decorate([Property(null)], Tooltip.prototype, \"data\", void 0);\n\n  __decorate([Property('Material')], Tooltip.prototype, \"theme\", void 0);\n\n  __decorate([Complex({\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  }, AreaBounds)], Tooltip.prototype, \"areaBounds\", void 0);\n\n  __decorate([Property(null)], Tooltip.prototype, \"availableSize\", void 0);\n\n  __decorate([Property()], Tooltip.prototype, \"blazorTemplate\", void 0);\n\n  __decorate([Property(false)], Tooltip.prototype, \"isCanvas\", void 0);\n\n  __decorate([Event()], Tooltip.prototype, \"tooltipRender\", void 0);\n\n  __decorate([Event()], Tooltip.prototype, \"loaded\", void 0);\n\n  __decorate([Event()], Tooltip.prototype, \"animationComplete\", void 0);\n\n  Tooltip = __decorate([NotifyPropertyChanges], Tooltip);\n  return Tooltip;\n}(Component);\n\nexport { Tooltip };","map":null,"metadata":{},"sourceType":"module"}